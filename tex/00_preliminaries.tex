% 
% Literature Review https://arxiv.org/pdf/2501.07209
% 


\begin{definition}[LRSW Assumption in Bilinear Groups]
For any PPT adversary $\mathcal{A}$, we say the LRSW assumption holds if there exists a negligible function $\negl$ such that:
$$\Pr\left[\begin{array}{l}
    \BG = (p, \G_1, \G_2, \G_T, e, g, \tilde{g}) \sample \BGGen(1^\lambda) \\
    x,y \sample \Z_p, X \gets g^x, \tilde{Y} \gets \tilde{g}^y \\
    (m^*, A, B, C) \sample \mathcal{A}^{\mathcal{O}_{x,y}}(\BG, X, \tilde{Y})
\end{array} : \begin{array}{l}
    m^* \notin Q \quad \land \quad \exists r \in \Z_p :\\
    A = g^r \land B = A^y \land C = A^{x+m^*xy}
\end{array}\right] \leq \negl(\lambda)$$
where $Q$ is the set of queries made to $\mathcal{O}_{x,y}$ with access to $x,y$ is defined by:
\[
\text{Oracle }\mathcal{O}_{x,y}(m): \text{ Samples } r \sample \Z_p, \text{ Returns } (g^r, (g^r)^y, (g^r)^{x+mxy})
\]
\end{definition}


\begin{definition}[PS-LRSW Assumption in Bilinear Groups]
For any PPT adversary $\mathcal{A}$, we say the PS-LRSW assumption holds if there exists a negligible function $\negl$ such that:
$$\Pr\left[\begin{array}{l}
    \BG = (p, \G_1, \G_2, \G_T, e, g, \tilde{g}) \sample \BGGen(1^\lambda) \\
    x,y \sample \Z_p, X \gets g^x, Y \gets g^y \\
    \tilde{X} \gets \tilde{g}^x, \tilde{Y} \gets \tilde{g}^y \\
    (m^*, P_1, P_2) \sample \mathcal{A}^{\mathcal{O}_{x,y}}(\BG, X, Y, \tilde{X}, \tilde{Y})
\end{array} : \begin{array}{l}
    m^* \notin Q \land P_1 \neq 1_{\G_1} \land \\
    e(P_1, \tilde{X} \cdot \tilde{Y}^{m^*}) = e(P_2, \tilde{g})
\end{array}\right] \leq \negl$$
where $Q$ is the set of queries made to $\mathcal{O}_{x,y}$ with access to $x,y$ is defined by:
\[
\text{Oracle }\mathcal{O}_{x,y}(m): \text{ Samples } h \sample \G_1, \text{ Returns the pair }P = (h, h^{x+my})
\]
\end{definition}



\begin{definition}[Type-3 PS-LRSW Assumption]
For any PPT adversary $\mathcal{A}$, we say the Type-3 PS-LRSW assumption holds in the generic bilinear group model if there exists a negligible function $\negl$ such that:
$$\Pr\left[\begin{array}{l}
    \BG = (p, \G_1, \G_2, \G_T, e, g, \tilde{g}) \sample \BGGen(1^\lambda) \\
    x,y \sample \Z_p, X \gets g^x, \tilde{Y} \gets \tilde{g}^y \\
    (m^*, P_1, P_2) \sample \mathcal{A}^{\mathcal{O}_{x,y}}(\BG, X, \tilde{Y})
\end{array} : \begin{array}{l}
    m^* \notin Q \land P_1 \neq 1_{\G_1} \land \\
    e(P_1, \tilde{X} \cdot \tilde{Y}^{m^*}) = e(P_2, \tilde{g})
\end{array}\right] \leq \negl$$
where $Q$ is the set of queries made to $\mathcal{O}_{x,y}$ with access to $x,y$ is defined by:
\[
\text{Oracle }\mathcal{O}_{x,y}(m): \text{ Samples } h \sample \G_1, \text{ Returns the pair } P = (h, h^{x+my})
\]

\noindent Furthermore, in the generic group model after $q$ oracle queries and $q_G$ group-oracle queries, the probability of success is bounded by $\mathcal{O}((q + q_G)^2/p)$.
\end{definition}



\begin{definition}[XDDH/SXDH Assumption in Bilinear Groups]
For any PPT adversary $\mathcal{A}$, we say the XDDH assumption holds in $\G_i$ ($i \in \{1,2\}$) if there exists a negligible function $\negl$ such that:
$$\left|\Pr\left[\begin{array}{l}
    \BG = (p, \G_1, \G_2, \G_T, e, g, \tilde{g}) \sample \BGGen(1^\lambda) \\
    a, b \sample \Z_p, c \gets ab \bmod p \\
    d \sample \mathcal{A}(\BG, g_i^a, g_i^b, g_i^c)
\end{array}\right] - 
\Pr\left[\begin{array}{l}
    \BG = (p, \G_1, \G_2, \G_T, e, g, \tilde{g}) \sample \BGGen(1^\lambda) \\
    a, b, r \sample \Z_p \\
    d \sample \mathcal{A}(\BG, g_i^a, g_i^b, g_i^r)
\end{array}\right]\right| \leq \negl$$
where $g_i$ is the generator of $\G_i$. The SXDH assumption holds if XDDH holds in both $\G_1$ and $\G_2$.
\end{definition}




\begin{definition}[Symmetric Discrete Logarithm Assumption (SDLP)]\label{sdlp}
For any PPT adversary $\mathcal{A}$, we say the SDLP assumption holds if there exists a negligible function $\negl$ such that:
$$\Pr\left[\begin{array}{l}
    \BG = (p, \G_1, \G_2, \G_T, e, g, \tilde{g}) \sample \BGGen(1^\lambda) \\
    x \sample \Z_p \\
    x' \sample \mathcal{A}(\BG, g^x, \tilde{g}^x)
\end{array} : x = x'\right] \leq \negl$$
where validity of input can be verified by checking $e(g, \tilde{g}^x) = e(g^x, \tilde{g})$.
\end{definition}



Assumptions from here - as discussed by UTT paper commitment instantiation
The binding property holds under the SDL assumption of \cite{hutchison_get_2010}
which follows from 1-SDH of \cite{boneh_short_2008}. (See Section I for details.) 



\subsection{Digital Signatures}

\begin{definition}[Signature Scheme]
A signature scheme $\mathsf{Sig}$ is a tuple of probabilistic polynomial-time algorithms $(\mathsf{KeyGen}, \mathsf{Sign}, \mathsf{Verify})$ where:

\begin{itemize}
    \item $\mathsf{KeyGen}(1^\lambda) \rightarrow (\mathsf{sk}, \mathsf{pk})$: is a probabilistic algorithm that takes as input a security parameter $\lambda$ and outputs a secret signing key $\mathsf{sk}$ and a public verification key $\mathsf{pk}$. The message space $\mathcal{M}$ is implicitly defined by $\mathsf{pk}$.
    
    \item $\mathsf{Sign}(\mathsf{sk}, m; r) \rightarrow \sigma$: is a probabilistic algorithm that takes as input the secret key $\mathsf{sk}$, a message $m \in \mathcal{M}$, and random coins $r$ sampled from the randomness space $\mathcal{R}$. It outputs a signature $\sigma$.
    
    \item $\mathsf{Verify}(\mathsf{pk}, m, \sigma) \rightarrow b$: is a deterministic algorithm that takes as input the public key $\mathsf{pk}$, a message $m \in \mathcal{M}$, and a signature $\sigma$. It outputs a bit $b \in \{0,1\}$, where 1 indicates acceptance and 0 indicates rejection.
\end{itemize}

The scheme must satisfy the following correctness property:
For all $\lambda \in \mathbb{N}$, all $(\mathsf{sk}, \mathsf{pk}) \leftarrow \mathsf{KeyGen}(1^\lambda)$, all messages $m \in \mathcal{M}$, and all random coins $r \in \mathcal{R}$:

$$\Pr[\mathsf{Verify}(\mathsf{pk}, m, \mathsf{Sign}(\mathsf{sk}, m; r)) = 1] = 1$$

\end{definition}

\begin{definition}[Correctness]
A signature scheme $(\mathsf{KeyGen}, \mathsf{Sign}, \mathsf{Verify})$ is correct if for all $k \in \mathbb{N}$, all key pairs $(\mathsf{sk}, \mathsf{pk}) \in [\mathsf{KeyGen}(1^k)]$ and all $m \in \mathcal{M}$ we have:

$$\Pr[\mathsf{Verify}(m, \mathsf{Sign}(m, \mathsf{sk}), \mathsf{pk}) = 1] = 1.$$
\end{definition}

\begin{definition}[EUF-CMA Security]
A signature scheme $(\mathsf{KeyGen}, \mathsf{Sign}, \mathsf{Verify})$ is existentially unforgeable under adaptive chosen-message attacks if for all PPT algorithms $\mathcal{A}$, there exists a negligible function $\negl$ such that:
$$\Pr\left[\begin{array}{l}
    (\mathsf{sk}, \mathsf{pk}) \sample \mathsf{KeyGen}(1^\lambda) \\
    (m^*, \sigma^*) \sample \mathcal{A}^{\mathcal{O}_{\mathsf{sk}}}(\mathsf{pk})
\end{array} : \begin{array}{l}
    m^* \notin Q \land \\
    \mathsf{Verify}(m^*, \sigma^*, \mathsf{pk}) = 1
\end{array}\right] \leq \negl$$
where $Q$ is the set of queries made to $\mathcal{O}_{\mathsf{sk}}$ with access to $\mathsf{sk}$ is defined by:
\[
\text{Oracle }\mathcal{O}_{\mathsf{sk}}(m): \text{ Returns } \sigma \gets \mathsf{Sign}(m, \mathsf{sk})
\]
\end{definition}





% % % % % % % % % % 
% 
% END PRELIMINARIES
% 
% % % % % % % % % % 


























% % % % % % % % % % 
% 
% Randomizable Vector Commitments
% 
% % % % % % % % % % 


\newpage
\section{Symmetric Rerandomizable Vector Commitments}\label{sec:commitment}
We now introduce a specialized Pedersen commitment scheme from \cite{tomescu2022utt} and prove tight security as the building block for our anonymous credential system. Our construction extends the classical Pedersen Commitment scheme with three properties that are required for our multi-issuer, multi-credential setting construction:
\begin{enumerate}
    \item \textbf{Position Binding: } we need to commit to a vector of attributes $\{m_1, \ldots, m_n\}$ while ensuring the individual positions within the commitment remain binding. Position binding is useful when proving relations about specific committed attributes across multiple credentials. 
    
    \item \textbf{Symmetric across bilinear groups: } in order to support our pairing-based signatures and efficient zero-knowledge proofs, we require commitments to be represented and verified in both $\G_1, \G_2$ curve groups. 
    
    \item \textbf{Rerandomization: } we need the ability to rerandomize commitments while preserving their structure which supports unlinkability in credential presentations
\end{enumerate}

\noindent Furthermore, our scheme often leverages Pedersen Commitments homomorphic properties, allowing us to combine multiple commitments with group operations. This enables us to bind credential attributes and hide secrets while maintaining privacy. 

\subsubsection{Definition}

\begin{definition}[Rerandomizable Vector Commitment scheme] 
    A rerandomizable vector commitment scheme $\mathsf{RVC}$ is a tuple $(\mathsf{Setup}, \mathsf{Commit}, \mathsf{Open}, \mathsf{Rerand})$ of PPT algorithms where:
    
    \begin{itemize}
        \item $\mathsf{Setup}(1^\lambda, 1^n) \to \mathsf{ck}$ probabilistic algorithm that takes as input the security parameter $\lambda$ and vector length $n$ both in unary. It outputs the commitment key $\mathsf{ck}$ of length $n$
        
        \item $\mathsf{Commit}(\mathsf{ck}, \vect{m}) \to (\cm, r)$: probabilistic algorithm takes as input the commitment key $\mathsf{ck}$ and message vector $\vect{m} \in \mathcal{M}^n$ . Outputs the commitment $\cm$ and opening key $r$

        \item $\mathsf{Open}(\mathsf{ck, cm}, \vec{m}, r) \to \bit$: deterministic algorithm, takes as input the commitment key $\mathsf{ck}$, commitment $\mathsf{cm}$, messages $\vec{m}$ and randomness $r$, outputs 1 if success, 0 for failure

        \item $\mathsf{Rerand}(\mathsf{ck, cm}) \to (cm', r')$: probabilistic algorithm, takes as input the commitment key $\mathsf{ck}$, commitment $\mathsf{cm}$ outputs randomized commitment $\cm'$ and new randomness $r'$. 
        
    \end{itemize}
\end{definition}

\noindent A rerandomizable vector commitment scheme is secure if it's correct, hiding, binding, position binding, rerandomizable, and symmetric group correct. We use standard definitions for correctness, hiding, and binding.


\begin{definition}[Correctness] A rerandomizable vector commitment scheme $\mathsf{RVC}$ is correct if for all $n \in \N$ and all $\vec{m} \in \mathcal{M}^n$:
        \[
        \Pr
            \left [
                \begin{array}{l}
                    \mathsf{ck} \gets \mathsf{Setup}(1^\lambda, 1^n) \\
                    (\cm, r) \gets \mathsf{Commit}(\mathsf{ck}, \vec{m}) \\
                \end{array}
                : 1 \gets \mathsf{Open}(\mathsf{ck}, \cm, \vec{m}, r)
            \right ] = 1
    \]
\end{definition}


\begin{definition}[Perfect Hiding] A rerandomizable vector commitment scheme $\mathsf{RVC}$ is perfectly hiding if for all (unbounded) adversaries $\AdvA$ and all message vectors $\vec{m}_0, \vec{m}_1$ of equal length:
\[
    \Pr
        \left [
            \begin{array}{l}
                \mathsf{ck} \gets \mathsf{Setup}(1^\lambda, 1^n) \\
                (\vec{m}_0, \vec{m}_1) \gets \mathcal{A}(\mathsf{ck}) \\
                b \sample \bit \\
                (\cm_b, r_b) \gets \mathsf{Commit}(\mathsf{ck}, \vec{m}_b) \\
                b' \gets \AdvA(\mathsf{ck}, \cm_b) \\
            \end{array}
            : b' = b
        \right ]
        = \frac{1}{2}
\]
\end{definition}


\begin{definition}[Binding] A rerandomizable vector commitment scheme $\mathsf{RVC}$ is binding if for all $\PPT$ adversaries $\AdvA$ and all message vectors $\vec{m}_0, \vec{m}_1$ of equal length, there is a negligible function $\negl$ such that:
    \[
        \Pr
        \left [
            \begin{array}{l}
            \mathsf{ck} \gets \mathsf{Setup}(1^\lambda, 1^n) \\
            (\vec{m}_0, \vec{m}_1, r_0, r_1) \gets \AdvA(\mathsf{ck}) \\
            \cm_0 \gets \mathcal{A}(\mathsf{CM.Com}(\ck, \vec{m}_0, r_0)) \\
            b_0 \gets \mathsf{Open}(\mathsf{ck}, \cm, \vec{m}_0, r_0) \\
            b_1 \gets \mathsf{Open}(\mathsf{ck}, \cm, \vec{m}_1, r_1) \\
            \end{array}
            \quad : \quad  b_0 = b_1 = 1 \quad \land \quad  \vec{m}_0 \neq  \vec{m}_1
        \right ] \leq \negl
    \]
Informally, No adversary $\AdvA$ should be able to open a commitment to two different messages, even when allowed to use different randomness values. This captures the "unforgeability" aspect of commitments. 
\end{definition}


\begin{definition}[Position Binding]
A rerandomizable vector commitment scheme $\mathsf{RVC}$ is position binding if for all $\PPT$ adversaries $\AdvA$ and where $\vec{m}_0, \vec{m}_1$ are vectors that differ only at position $i$, there is a negligible function $\negl$ such that:
\[
    \Pr
    \left[
        \begin{array}{l}
        \mathsf{ck} \sample \mathsf{Setup}(1^\lambda, 1^n) \\
        (\cm, i, \vec{m}_0, \vec{m}_1, r_0, r_1) \sample \mathcal{A}(\mathsf{ck}) \\
        \mathsf{Open}(\ck, \cm, \vec{m}_0, r_0, i) = 1 \\
        \mathsf{Open}(\ck, \cm, \vec{m}_1, r_1, i) = 1 \\
        \end{array}
        : \begin{array}{l}
            \vec{m}_0 \neq \vec{m}_1 \quad \wedge\\
            \vec{m}_0[j] = \vec{m}_1[j] \; \forall \; j \neq i \\
          \end{array}
    \right] \leq \negl
\]
Informally, this states that an adversary $\AdvA$ should not be able to open a commitment $\cm$ to index $i$ unless both commitments use the same message, even when the commitments only differ by position $i$
\end{definition}





\begin{definition}[Symmetric Group Correctness]
A rerandomizable vector commitment scheme $\mathsf{RVC}$ satisfies symmetric group correctness if for all $n \in \mathbb{N}$ and all $\vec{m} \in \mathcal{M}^n$:
  \[
        \Pr\left[
        \begin{array}{l}
            \mathsf{ck} \sample \mathsf{Setup}(1^\lambda, 1^n) \\
            (\cm, \widehat{\cm}, r) \sample \mathsf{Commit}(\mathsf{ck}, \vec{m})
        \end{array}
        : e(\cm, \widehat{g}) = e(g, \widehat{cm})
        \right] = 1
    \]
    \[
        \Pr\left[
        \begin{array}{l}
            (\cm', \widehat{\cm'}, r') \sample \mathsf{Rerand}(\mathsf{ck}, \cm, \widehat{\cm}, r)
        \end{array}
        : e(\cm', \widehat{g}) = e(g, \widehat{\cm'})
        \right] = 1
    \]
\noindent where $g, \widehat{g}$ are the generators specified in $\mathsf{ck}$ for $\G_1, \G_2$ respectively.
\end{definition}




\begin{definition}[Additive Homomorphism]
A rerandomizable vector commitment scheme $\mathsf{RVC}$ is additively homomorphic if for all $\vec{m}_1, \vec{m}_2 \in \mathcal{M}^n$ and randomness $r_1, r_2 \in \Z_p$:
\[
    \Pr\left[
    \begin{array}{l}
        \mathsf{ck} \sample \mathsf{Setup}(1^\lambda, 1^n) \\
        (\cm_1, r_1) \sample \mathsf{Commit}(\mathsf{ck}, \vec{m}_1) \\
        (\cm_2, r_2) \sample \mathsf{Commit}(\mathsf{ck}, \vec{m}_2)
    \end{array}
    : \cm_1 \cdot \cm_2 = \mathsf{Commit}(\mathsf{ck}, \vec{m}_1 + \vec{m}_2, r_1 + r_2)
    \right] = 1
\]

\noindent Furthermore, for symmetric group correctness, the homomorphism must hold across groups:
\[
    e(\cm_1 \cdot \cm_2, \widehat{g}) = e(g, \widehat{\cm_1} \cdot \widehat{\cm_2})
\]
\end{definition}

% The homomorphic operation is the standard component-wise addition over Zp, and therefore one can add a value to a single entry without changing the other entries (by adding zeroes in all other locations). From UTT


\subsection{Construction}
We instantiate a dual-group Pedersen Vector Commitment scheme with groups $\G_1, \G_2$ to enable efficient verification within our signature construction. For commitments $\cm \in \G_1, \widetilde{\cm} \in \G_2$, we verify consistency via the pairing relation $e(\cm, \tilde{g}) = e(g, \widetilde{\cm})$.

Let $\G_1, \G_2$ be cyclic groups of prime order $p$ with an efficient Type-3 pairing $e: \G_1 \times \G_2 \to \G_T$. For message vector $\vec{m} = (m_1, \ldots, m_\ell) \in \Z_p^\ell$, our rerandomizable commitment scheme consists of the following algorithms:

\begin{itemize}
    \item $\mathsf{CM.Setup}(\secparam, \ell) \to \ck$:
    Sample generators $(g, \tilde{g}) \sample \G_1 \times \G_2$
    For $i \in [1,\ell]$: Sample $y_i \sample \Z_p$, compute $(g_i, \tilde{g}_i) \gets (g^{y_i}, \tilde{g}^{y_i})$
    Return $\ck \gets (g, (g_1,\ldots,g_\ell), \tilde{g}, (\tilde{g}_1,\ldots,\tilde{g}_\ell))$
    
    \item $\mathsf{CM.Com}(\ck, \vec{m}) \to (\cm, \widetilde{\cm}, r)$:
    Parse $\ck$ as $(g, (g_1,\ldots,g_\ell), \tilde{g}, (\tilde{g}_1,\ldots,\tilde{g}_\ell))$
    Sample $r \sample \Z_p$
    Compute $\cm \gets g^r \prod_{i=1}^\ell g_i^{m_i}$ and $\widetilde{\cm} \gets \tilde{g}^r \prod_{i=1}^\ell \tilde{g}_i^{m_i}$
    Return $(\cm, \widetilde{\cm}, r)$
    
    \item $\mathsf{CM.Rerand}(\ck, \cm, \widetilde{\cm}, r_\Delta) \to (\cm', \widetilde{\cm'})$:
    Parse $\ck$ as $(g, \cdot, \tilde{g}, \cdot)$
    Compute $\cm' \gets \cm \cdot g^{r_\Delta}$ and $\widetilde{\cm'} \gets \widetilde{\cm} \cdot \tilde{g}^{r_\Delta}$
    Return $(\cm', \widetilde{\cm'})$

    \item $\mathsf{CM.Open}$
\end{itemize}

\paragraph{Homomorphic Properties}
The scheme inherits the additive homomorphic properties of Pedersen commitments:

\begin{itemize}
    \item \textbf{Rerandomization:} For commitment $\cm = g^r\prod_{i=1}^\ell g_i^{m_i}$ and fresh randomness $r_\Delta \sample \Z_p$, the rerandomized commitment $\cm' = \cm \cdot g^{r_\Delta} = g^{r+r_\Delta}\prod_{i=1}^\ell g_i^{m_i}$ preserves the message vector while updating the randomness from $r$ to $r + r_\Delta$. By the DDH assumption in $\G_1$, $\cm'$ is computationally indistinguishable from $\cm$.
    
    \item \textbf{Two-Party Protocol:} For joint randomness generation:
    \begin{enumerate}
        \item User samples $s_1, r \sample \Z_p$ and commits: $\cm_1 \gets g^r g_1^{s_1}$
        \item Authority samples $s_2 \sample \Z_p$ and computes: $\cm_2 \gets \cm_1 \cdot g_1^{s_2} = g^r g_1^{s_1 + s_2}$
        \item Authority returns $(\cm_2, s_2)$, establishing shared secret $s_1 + s_2$
    \end{enumerate}
    
    Security holds bidirectionally:
    \begin{itemize}
        \item \textbf{Unforgeability:} Computational binding under DL prevents malicious users from changing $s_1$ post-commitment
        \item \textbf{Anonymity:} Perfect hiding of $\cm_1$ ensures zero knowledge of $s_1$ against malicious issuers
    \end{itemize}
\end{itemize}

\subsection{Security of our Construction}



% 
% 
% 
% 
% Proof in the AGM
% 
% 

\sam{Why are we using AGM}

\begin{theorem}
    In the Algebraic Group Model, if the Symmetric Discrete Logarithm Problem (SDLP) is hard in the bilinear group $\BG$, then our RVC scheme satisfies position binding. Specifically, for any algebraic PPT adversary $\mathcal{A}$ against position binding, there exists a PPT reduction $\mathcal{B}$ against SDLP such that:
    \[
        \mathsf{Adv}^{\mathsf{pos\text{-}bind}}_{\mathcal{A},\mathsf{RVC}}(\lambda) \leq \ell \cdot \mathsf{Adv}^{\mathsf{SDLP}}_{\mathcal{B},\mathbb{G}}(\lambda)
    \]
    where $\ell$ is the vector length.
\end{theorem}

\begin{proof}
We prove via reduction in the AGM. Given an algebraic PPT adversary $\mathcal{A}$ that breaks position binding with non-negligible probability $\epsilon$, we construct a PPT algorithm $\mathcal{B}$ that solves SDLP with probability $\epsilon/\ell$. For clarity, we illustrate with $\ell = 3$; the proof generalizes naturally.

Algorithm $\mathcal{B}$ works as follows:
\begin{enumerate}
    \item \textbf{Setup}: On input SDLP instance $(g^x, \tilde{g}^x) \in \mathbb{G}_1 \times \mathbb{G}_2$, $\mathcal{B}$ proceeds to:
    \begin{enumerate}
        \item Sample $i^* \sample [1,\ell]$ uniformly at random
        \item For position $i^*$: set $(g_{i^*}, \tilde{g}_{i^*}) \gets (g^x, \tilde{g}^x)$
        \item For positions $j \neq i^*$: sample $y_j \sample \mathbb{Z}_p$, set $(g_j, \tilde{g}_j) \gets (g^{y_j}, \tilde{g}^{y_j})$
        \item Give $\mathsf{ck} = ((g_1, g_2, g_3), (\tilde{g}_1, \tilde{g}_2, \tilde{g}_3))$ to $\mathcal{A}$
    \end{enumerate}
    
    \item \textbf{Position Binding Break}: Since $\mathcal{A}$ is algebraic, when it outputs $(\mathsf{cm}, i, \vec{m}_0, \vec{m}_1, r_0, r_1)$, it also provides the representation of $\mathsf{cm}$ in terms of the generators:
    \begin{itemize}
        \item $\mathsf{cm} \in \mathbb{G}_1$ with its algebraic representation
        \item $i \in [1,\ell]$ is the position where binding breaks
        \item $\vec{m}_0, \vec{m}_1 \in \mathbb{Z}_p^\ell$ differ only at position $i$
        \item $r_0, r_1 \in \mathbb{Z}_p$ are opening randomness values
    \end{itemize}
    
    \item \textbf{Extracting SDLP}: If $i \neq i^*$, abort. Otherwise:
    \begin{enumerate}
        \item By the algebraic property of $\mathcal{A}$, we have explicit representations of the commitment openings:
        \[
            g^{r_0}g_1^{m_{0,1}}g_2^{x \cdot m_{0,2}}g_3^{m_{0,3}} = g^{r_1}g_1^{m_{1,1}}g_2^{x \cdot m_{1,2}}g_3^{m_{1,3}}
        \]
        
        \item Since these representations are explicit in the AGM, we can directly compare exponents:
        \[
            r_0 + y_1m_{0,1} + xm_{0,2} + y_3m_{0,3} = r_1 + y_1m_{1,1} + xm_{1,2} + y_3m_{1,3}
        \]
        
        \item Since $\vec{m}_0$ and $\vec{m}_1$ differ only at position $i^*=2$, we have $m_{0,1}=m_{1,1}$ and $m_{0,3}=m_{1,3}$. Terms cancel:
        \[
            r_0 + xm_{0,2} = r_1 + xm_{1,2}
        \]
        
        \item Solve for $x$:
        \[
            x \equiv \frac{r_1-r_0}{m_{0,2}-m_{1,2}} \pmod{p}
        \]
        Note: Division is well-defined as $m_{0,2} \neq m_{1,2}$ by assumption.
    \end{enumerate}
\end{enumerate}

The reduction succeeds whenever $i = i^*$ and $\mathcal{A}$ succeeds, which occurs with probability $\epsilon/\ell$. This is non-negligible when $\epsilon$ is non-negligible, contradicting the SDLP assumption.
\end{proof}


\paragraph{Analysis:}
We analyze the reduction's properties in detail:
\begin{itemize}
    \item \textbf{Perfect Simulation:} The commitment key distribution is identical to the real scheme:
        \begin{itemize}
            \item At position $i^*$: $(g_{i^*}, \tilde{g}_{i^*}) = (g^x, \tilde{g}^x)$ is uniformly distributed in $\G_1 \times \G_2$ by the SDLP instance properties
            \item At positions $j \neq i^*$: $(g_j, \tilde{g}_j) = (g^{y_j}, \tilde{g}^{y_j})$ is uniform due to $y_j \sample \Z_p$
            \item Therefore, from $\mathcal{A}$'s view, $\mathsf{ck}$ is distributed identically to the real scheme
        \end{itemize}
    
    \item \textbf{Extraction Success:} $\mathcal{B}$ successfully extracts the SDLP solution when:
        \begin{itemize}
            \item $\mathcal{A}$ outputs a valid position binding break (occurs with probability $\epsilon$)
            \item The guessed position matches: $i = i^*$ (occurs with probability $1/\ell$)
            \item The extraction equation is solvable: $m_{0,i^*} \neq m_{1,i^*}$ (guaranteed by definition of position binding break)
        \end{itemize}
    
    \item \textbf{Advantage Analysis:} Combining these probabilities:
        \begin{itemize}
            \item Events are independent as $i^*$ is chosen before $\mathcal{A}$'s execution
            \item $\mathsf{Pr}[\mathcal{B} \text{ succeeds}] = \epsilon \cdot \frac{1}{\ell}$
            \item Therefore: $\mathsf{Adv}^{\mathsf{SDLP}}_{\mathcal{B},\G}(\lambda) \geq \frac{1}{\ell} \cdot \mathsf{Adv}^{\mathsf{pos\text{-}bind}}_{\mathcal{A},\mathsf{RVC}}(\lambda)$
        \end{itemize}
\end{itemize}

Thus, if $\mathcal{A}$ breaks position binding with non-negligible probability $\epsilon$, then $\mathcal{B}$ solves SDLP with non-negligible probability $\epsilon/\ell$, contradicting the SDLP hardness assumption in $\G$.





% % % % % % % % % % 
% 
% END Randomizable Vector Commitments
% 
% % % % % % % % % % 















% % % % % % % % % % 
% 
% PS Signature
% 
% % % % % % % % % % 
\newpage
\section{Rerandomizable Signature over Commitments}\label{sec:pssignature}
\subsubsection{Definition}
\begin{definition}[Rerandomizable Signature over Commitments]
    A rerandomizable signature scheme over commitments $\mathsf{RS}$ is a tuple $(\mathsf{KeyGen}, \mathsf{Sign}, \mathsf{Rerand}, \mathsf{Ver}, \mathsf{VerKey})$ of PPT algorithms where:
        \begin{itemize}
            \item $\mathsf{RS.KeyGen(pp, ck)} \to \mathsf{(sk, pk = (pp, vk, ck))}$ is a probabilistic algorithm that takes in the public parameters $\mathsf{pp}$ and commitment key $\mathsf{ck}$, outputs a signing key $\sk$, a public verification key $\vk$ and outputs $\mathsf{(sk, pk = (pp, vk, ck))}$

            \item $\mathsf{RS.Sign}(\mathsf{sk, cm};u ) \to \sigma$: probabilistic algorithm takes the signing key $\sk$, commitment $\cm$ from the commitment space $\mathcal{C}$ and random coins $u$ sampled from random space of the signature scheme. Output $\sigma$

            \item $\mathsf{RS.Rerand}(\pk, \sigma, r_\Delta, u_\Delta) \rightarrow \sigma'$ is a deterministic algorithm that enables signature rerandomization. Takes a public key $\pk = (\mathsf{ck,vk})$, a signature $\sigma$, and randomization elements $r_\Delta, u_\Delta$, as input, outputs a new signature $\sigma'$. 

            \item $\mathsf{RS.Ver}(\mathsf{pk = (pp, vk, ck), cm}, \sigma) \rightarrow \bit$: is a deterministic algorithm, takes as input the public key $\mathsf{pk}$, $\cm \in \mathcal{C}$ and signature $\sigma$, outputs 1 for successful verification, otherwise 0. 

            \item $\mathsf{RS.VerKey}(\mathsf{sk, pk = (pp, vk, ck)}) \to \bit:$ is a deterministic algorithm that takes in a secret key $\sk$ and verification key $\vk$, checks for consistency and returns 1 for success, 0 for failure
        \end{itemize}
\end{definition}


\begin{definition}[Correctness] 
A rerandomizable signature scheme over commitments is correct if for all security parameters $\secparam$, for all $\ell > 1$, all bilinear groups $\mathsf{BG} = (p, \G_1, \G_2, \G_T, e, g, \tilde{g}) \in [\mathsf{BGGen}(\secparam)]$, all key pairs $(\sk, \pk) \in [\mathsf{KeyGen}(\mathsf{BG, 1^{\ell}})]$, all messages $m \in \mathcal{M}$, all commitments $\cm \in \mathcal{C}$, all commitment keys $\mathsf{ck} \in [\mathsf{CM.KeyGen}(\secparam)]$, and all randomness $r, u, r_\Delta, u_\Delta \in \Z_p$ we have:
    \begin{align*}
        &\mathsf{RS.VerKey}(\sk, \pk) = 1 \qquad \wedge \\
        &\Pr \left[ \mathsf{RS.Ver}(\pk, \left(\mathsf{RS.Sign}(\mathsf{sk}, \mathsf{CM.Com}(\mathsf{ck}, m, r), u)\right), m) = 1 \right] =1 \qquad \wedge \\
        &\Pr \left[ \mathsf{RS.Ver}(\pk, \mathsf{RS.Rerand}(\pk,\left(\mathsf{RS.Sign}(\mathsf{sk}, \mathsf{CM.Com}(\mathsf{ck}, m, r), u)\right),r_\Delta, u_\Delta), m) = 1 \right] =1 \qquad \wedge \\
        &\Pr \left[ \mathsf{RS.Ver}(\pk, \left(\mathsf{RS.Sign}(\mathsf{sk}, \mathsf{CM.Com}(\mathsf{ck}, m, r+r_\Delta), u+u_\Delta)\right), m) = 1 \right] = 1\\
    \end{align*}
\end{definition}



\begin{definition}[EUF-CMA]
A rerandomizable signature scheme over commitments is existentially unforgeable under adaptive chosen message (commitment) attacks if for all PPT adversaries $\mathcal{A}$, there exists a negligible function $\negl$ such that:
    \begin{align*}
        &\Pr\left[
            \begin{array}{l}
                \mathsf{BG} \gets \mathsf{BGGen}(1^{\secparam}), \\
                \mathsf{ck} \gets \mathsf{CM.KeyGen}(\mathsf{BG}), \\
                (\sk, \pk) \gets \mathsf{KeyGen}(\mathsf{BG}), \\
                (m^*, \cm^*, \sigma^*) \gets \mathcal{A}^{\mathsf{Sign}(\sk, \cdot)}(\pk) \\
                \end{array}
                \quad : \quad
                \begin{array}{l}
                \cm^* = \mathsf{CM.Com}(\mathsf{ck}, m^*, r^*) \land \\
                \mathsf{RS.Ver}(\pk, \sigma^*, m^*) = 1 \land \\
                \cm^* \notin Q_{\cm}
            \end{array}
        \right] \leq \negl
    \end{align*}
where $Q_{\cm}$ is the set of all commitments queried to the signing oracle
\end{definition}


\begin{definition}[$\mathsf{RS}$ Signature Adaptation Under Malicious Keys]
A rerandomizable signature scheme $\mathsf{RS}$ satisfies \emph{signature adaptation under malicious keys} if for all tuples $(\pk, \cm, \sigma, r)$ where:
\begin{itemize}
    \item $\cm \in \mathcal{C}$ is a valid commitment,
    \item $\sigma$ is a valid signature under $\pk$ (i.e., $\mathsf{RS.Ver}(\pk, \cm, \sigma) = 1$),
    \item $r \in \Z_p^*$,
\end{itemize}
the distribution of $\mathsf{RS.Rerand}(\pk, \sigma, \mu)$ is identical to $\mathsf{RS.Sign}(\sk, \mathsf{CM.Rerand}(\ck, \cm, r))$, even when $\pk$ is adversarially generated.
\end{definition}




\subsubsection{Construction}\label{sig-construction}
We assume the existence of a commitment key $\ck$ from $\mathsf{CM.Setup}$ as input into our rerandomizable signature scheme $\mathsf{RS}$. We copy the algorithm below for convenience.
\begin{itemize}
    \item $\mathsf{CM.Setup}(\secparam, \ell, (y_i, \ldots, y_{\ell} \in \Z_p^{\ell})) \to \ck:$  
    Sample $(g, \tilde{g}) \sample \G_1 \times \G_2$, For $i \in [1,\ell]$: Compute $g_i = g^{y_i}$ and $\tilde{g}_i = \tilde{g}^{y_i}$. Return $\ck \gets (g, (g_1,\ldots,g_\ell), \tilde{g}, (\tilde{g}_1,\ldots,\tilde{g}_\ell))$
    
    \item $\mathsf{RS.KeyGen}(\secparam, \ck) \to (\sk, \vk):$ 
        Retrieve $(g, \cdot, \tilde{g}, \cdot)$ from $\mathsf{ck}$,
        Sample $x \sample \Z_p$,
        Set $(\sk, \vk) \gets (g^x, \tilde{g}^x)$, return $(\sk, \vk))$
        % Return $(\mathsf{sk} = (x,g), \mathsf{pk} = (\mathsf{pp}, \mathsf{vk}, \mathsf{ck}))$
    
    \item $\mathsf{RS.Sign}(\mathsf{sk}, \mathsf{cm}; u) \to \sigma:$ 
        Let $h \gets g^u$
        Return $\sigma \gets (h, (\sk \cdot \mathsf{cm})^u)$
    
    \item $\mathsf{RS.Rerand}(\sigma, r_\Delta, u_\Delta) \to \sigma':$
        Parse $\sigma$ as $(\sigma_1, \sigma_2)$
        Set $\sigma_1' \gets \sigma_1^{u_\Delta}$
        Set $\sigma_2' \gets (\sigma_2 \cdot \sigma_1^{r_\Delta})^{u_\Delta}$
        Return $\sigma' \gets (\sigma_1', \sigma_2')$
    
    \item $\mathsf{RS.Ver}(\vk, \cm, \sigma) \to \bit:$
        Parse $\sigma$ as $(\sigma_1, \sigma_2)$, The prover $\Prover$ runs a Proof of Knowledge protocol with the following relation 
    \[
        \mathcal{R} \gets \mathsf{PoK}\{(m_1,\ldots,m_\ell, r + r_\Delta): 
    \]
    \[
         e(\sigma_2', \tilde{g}) = e(\sigma_1', \vk)\cdot e(\sigma_1', \widehat{\cm}') \quad \wedge \quad
        e(\cm', \tilde{g}) = e(g, \widetilde{\cm}') \quad \wedge \quad
        \cm' = g^{r + r_\Delta} \prod_{i=1}^\ell g_i^{m_i}
        \}
    \]

        \item $\mathsf{RS.VerKey}(\sk, \vk, \ck) \to \bit:$ verifies the correctness of the issuers secret and verification key $(\sk, \vk)$ and commitment key $\ck$:
        \[
        \mathcal{R}_{\mathsf{verkey}} = \{\pk = (\vk, \ck),(\sk, x, \{y_i\}_{i=1}^\ell) | sk = g^x \wedge vk = \tilde{g}^x \bigwedge_{i=1}^\ell (g_i = g^{y_i} \wedge \tilde{g}_i = \tilde{g}^{y_i})\}
        \]
        
\end{itemize}




\subsubsection{Security of our Construction}
\begin{theorem}
    RS is correct
\end{theorem}
\begin{proof}
    First we demonstrate the provers rerandomized signature verifies with the verification key $\vk$ and the rerandomized commitment. Essentially, we need the following pairing to hold
    \[
          e(\sigma_2', \tilde{g}) = e(\sigma_1', \vk \cdot \widetilde{\cm'})
    \]

    We manipulate the bilinearity properties of the pairing groups to verify the initial pairing.
    
    \begin{align*}
        e(\sigma_2', \tilde{g}) &= e((\sk \cdot \cm)^{u \cdot u\Delta}\cdot h^{u_\Delta \cdot r_\Delta}, \tilde{g}) \\
        &= e(h^{x \cdot u_\Delta}\cdot \cm^{u \cdot u_\Delta} \cdot h^{u_\Delta \cdot r_\Delta}, \tilde{g}) \\
        &= e(h^{x \cdot u_\Delta}, \tilde{g}) \cdot e(\cm^{u \cdot u_\Delta}, \tilde{g}) \cdot e(h^{ u_\Delta \cdot r_\Delta}, \tilde{g}) \\
        &= e(h^{u_\Delta}, \tilde{g}^x) \cdot e(\cm, \tilde{g})^{u \cdot u_\Delta} \cdot e(h^{ u_\Delta}, \tilde{g})^{r_\Delta} \\
        &= e(\sigma_1', \vk) \cdot e(g^{u \cdot u_\Delta}, \widetilde{\cm}) \cdot e(\sigma_1', \tilde{g})^{r_\Delta} \\
        &= e(\sigma_1', \vk) \cdot e(\sigma_1', \widetilde{\cm}) \cdot e(\sigma_1', \tilde{g}^{r_\Delta}) \\
        &= e(\sigma_1', \vk \cdot \widetilde{\cm} \cdot \tilde{g}^{r_\Delta}) \\
        &= e(\sigma_1', \vk \cdot \widetilde{\cm'}) \\
    \end{align*}

    Secondly, we need to verify knowledge of messages within the commitment. The Prover used $\widetilde{\cm'} \in \G_2$ during verification and this would be the natural method to for a sigma style proof of knowledge protocol, proving knowledge of the attributes of the commitment with $\G_2$ bases. However, due to the properties of the symmetric bilinear commitment \ref{sdlp}, we can prove the equality of $\cm' \in \G_1$ and $\widetilde{\cm'} \in \G_2$ to reduce $\G_2$ computation on both the prover and verifier during verification. 
    Thus the prover computes 
    \[
        e(\cm', \tilde{g}) = e(g, \widetilde{\cm}')
    \]
    Then runs a sigma protocol to prove
    \[
    \cm' = g^{r \cdot r_\Delta} \prod_{i=1}^\ell g_i^{m_i}
    \]

\end{proof}






\begin{theorem}[EUF-CMA Security]
Assume the PS-LRSW assumption holds and the Pedersen commitment is computationally binding. Then, in the Algebraic Group Model, our rerandomizable signature scheme is existentially unforgeable under adaptive chosen-message(commitment) attacks. For any algebraic PPT adversary $\mathcal{A}$, there exist PPT reductions $\mathcal{B}_0, \mathcal{B}_1$ such that:
\[
\Adv^{\mathsf{euf\mbox{-}cca}}_{\mathsf{RS},\mathcal{A}}(\lambda) \leq \Adv^{\mathsf{PS\mbox{-}LRSW}}_{\mathcal{B}_0}(\lambda) + \Adv^{\mathsf{Binding}}_{\mathcal{B}_1}(\lambda) + \frac{q_v + q_s}{p},
\]
where $q_v$ (verification) and $q_s$ (signing) are query counts.
\end{theorem}

\begin{proof}
We construct two reductions handling different forgery types. Let $\mathcal{A}$ be an adversary with advantage $\epsilon$.

\paragraph{1. Setup}
Given PS-LRSW challenge over bilinear groups $(g, \tilde{g}, X=g^x, \tilde{X}=\tilde{g}^x, Y=g^y, \tilde{Y}=\tilde{g}^y)$:
\begin{enumerate}
    \item \textbf{Commitment Setup:} For 2-slot Pedersen:
    \begin{itemize}
        \item Choose $\alpha_1, \alpha_2, \beta_1, \beta_2 \sample \Z_p$
        \item Set $g_1 = Y^{\alpha_1}g^{\beta_1}$, $\tilde{g}_1 = \tilde{Y}^{\alpha_1}\tilde{g}^{\beta_1}$ 
        \item Set $g_2 = Y^{\alpha_2}g^{\beta_2}$, $\tilde{g}_2 = \tilde{Y}^{\alpha_2}\tilde{g}^{\beta_2}$
    \end{itemize}
    \item \textbf{Public Key:} $\pk = (\tilde{X}, g_1, \tilde{g}_1, g_2, \tilde{g}_2)$
    \item Send $\pk$ to $\mathcal{A}$. Distribution matches real scheme as $\alpha_i, \beta_i$ are random.
\end{enumerate}


\paragraph{2. Oracle Simulation} \textbf{Signing Oracle:}
For query $(m_1, m_2, r)$:
\begin{itemize}
    \item \textbf{Case $\mathcal{B}_0$ (PS Reduction):}
    \begin{enumerate}
        \item Compute $m = \alpha_1m_1 + \alpha_2m_2$
        \item Query PS-LRSW oracle for $(h, h^{x + my})$
        \item Return $\sigma = (h, h^{x + my} \cdot h^{\beta_1m_1 + \beta_2m_2 + r})$
    \end{enumerate}
    \item \textbf{Case $\mathcal{B}_1$ (Binding Reduction):}
    \begin{enumerate}
        \item Compute $\mathsf{cm} = g_1^{m_1}g_2^{m_2}g^r$
        \item Choose $u \sample \Z_p$, return $\sigma = (g^u, (X \cdot \mathsf{cm})^u)$
    \end{enumerate}
\end{itemize}

\noindent \textbf{Verification Oracle:}

\begin{itemize}
    \item Parse $\sigma = (\sigma_1, \sigma_2)$
    \item Check $e(\sigma_2, \tilde{g}) = e(\sigma_1, \tilde{X} \cdot \widetilde{\mathsf{cm}})$ where $\widetilde{\mathsf{cm}} = \tilde{g}_1^{m_1}\tilde{g}_2^{m_2}\tilde{g}^r$
    \item Use AGM to extract exponents from $\sigma_1, \sigma_2$ if needed
\end{itemize}


\paragraph{3. Forgery Extraction}

When $\mathcal{A}$ outputs forgery $(m_1^*, m_2^*, r^*, \sigma^* = (\sigma_1^*, \sigma_2^*))$:

\noindent \textbf{Case 1: New Message Combination}
If $m^* = \alpha_1m_1^* + \alpha_2m_2^*$ is new:
\begin{itemize}
    \item $\mathcal{B}_0$ computes:
    \[
    (U, B/U^{\beta_1m_1^* + \beta_2m_2^* + r^*}) = (g^u, X^uY^{m^*u})
    \]
    \item This breaks PS-LRSW as $m^*$ wasn't queried. Thus:
    \[
    \epsilon_0 \geq \Pr[\text{New } m^*] - \frac{q_s}{p}
    \]
\end{itemize}

\noindent \textbf{Case 2: Commitment Collision}
If $m^*$ exists in prior query $(m_1, m_2) \neq (m_1^*, m_2^*)$:
\begin{itemize}
    \item $\mathcal{B}_1$ finds collision:
    \[
    g_1^{m_1}g_2^{m_2} = g_1^{m_1^*}g_2^{m_2^*}
    \]
    \item Solving gives DLOG relation for $\alpha_i, \beta_i$, breaking binding:
    \[
    \epsilon_1 \geq \Pr[\text{Collision}] - \frac{1}{p}
    \]
\end{itemize}

% \noindent \paragraph{4. Analysis}

% \begin{itemize}
%     \item Total advantage partitions as $\epsilon \leq \epsilon_0 + \epsilon_1 + \frac{q_v + q_s + 1}{p}$
%     \item The $\frac{1}{p}$ term accounts for coefficient collisions in setup
%     \item Verification queries add $\frac{q_v}{p}$ error probability and
% \end{itemize}
% \[
% \Adv^{\mathsf{euf\mbox{-}cca}}_{\mathcal{A}} \leq \Adv^{\mathsf{PS\mbox{-}LRSW}}_{\mathcal{B}_0} + \Adv^{\mathsf{Binding}}_{\mathcal{B}_1} + \frac{q_v + q_s}{p}
% \]
\end{proof}



