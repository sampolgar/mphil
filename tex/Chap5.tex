\mychapter{Threshold Sybil-Resistant Identity System}\label{chap6}

\section{Introduction}\label{sec:threshold-intro}

This chapter presents the Threshold Sybil-Resistant Identity System (T-SIRIS), the culmination of our thesis, integrating the expressive attribute-based credentials (ABCs) from Chapter~\ref{chap2}, the Multi-Issuer Multi-Credential (MIMC) system from Chapter~\ref{chap3}, and the efficient nullifier scheme from Chapter~\ref{chap4} with standard threshold cryptography. T-SIRIS addresses critical gaps in prior privacy-preserving identity systems—such as CanDID's inefficiency~\cite{maram2021candid}, SyRA's lack of multi-issuer support~\cite{crites_syra_2024}, and S3ID's limited expressiveness and slower deduplication~\cite{rabaninejad_attribute-based_2024}—delivering a decentralized, efficient, and feature-rich solution.

\subsection{Motivation and Challenges}

Existing systems struggle to balance privacy, efficiency, and functionality. S3ID~\cite{rabaninejad_attribute-based_2024}, while advancing threshold issuance with anonymous counting tokens (tACT), lacks revocation and expressive proof predicates, and its deduplication via EDDX operations is computationally expensive ($15.7$ ms vs. our $3.2$ ms). Our work in Chapters~\ref{chap2}–\ref{chap4} laid the groundwork for overcoming these limitations, but decentralization via threshold issuance remained unaddressed. T-SIRIS meets this challenge, ensuring no single point of trust while maintaining performance.

\subsection{Contributions}

\begin{itemize}
    \item \textbf{First Comprehensive Threshold System}: T-SIRIS is the first to combine sybil resistance, expressive proofs, revocation, and threshold issuance in a privacy-preserving identity framework.
    \item \textbf{Efficient Deduplication}: Leveraging pairing-free nullifiers, we achieve a $5\times$ faster deduplication () compared to S3ID's EDDX-based approach.
    \item \textbf{Performance Edge}: We demonstrate $2$–$3\times$ improvements over S3ID across key operations, with added functionality (e.g., expressive proofs at $4.1$ ms).
\end{itemize}

\begin{table}[h]
\centering
\caption{Comparison of our construction over previous work.}
\label{tab:comparison-chap5}
\begin{tabular}{l|ccccc}
\toprule
\textbf{Features} & \textbf{Sybil Resist.} & \textbf{Multi Issuer} & \textbf{Revocation} & \textbf{Expressive Proofs}$^{\dagger}$ & \textbf{M.I. Anonymity}$^{\ddagger}$ \\
\midrule
CanDID~\cite{maram2021candid} & \ding{51} & \ding{51} & \ding{51} & \ding{55} & \ding{55} \\
SyRA~\cite{crites_syra_2024} & \ding{51} & \ding{55} & \ding{55} & \ding{55} & \ding{55} \\
S3ID~\cite{rabaninejad_attribute-based_2024} & \ding{51} & \ding{51} & \ding{55} & \ding{55} & \ding{55} \\
Our Work & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} \\
\bottomrule
\end{tabular}
\begin{flushleft}
\footnotesize
$^{\dagger}$ Expressive Predicate Proofs allow users to prove expressive statements about their credentials privately. \\
$^{\ddagger}$ Anonymity in the presence of Malicious Issuers.
\end{flushleft}
\end{table}

\section{System Model and Definitions}
\label{sec:threshold-model}

\subsection{System Overview}

T-SIRIS integrates four key components:
\begin{itemize}
    \item \textbf{Threshold Key Generation}: Uses distributed key generation (DKG) with Shamir secret sharing for decentralized trust across $n$ issuers.
    \item \textbf{Threshold Issuance}: Extends MIMC-ABC (Chapter~\ref{chap3}) to issue credentials with $t$ of $n$ issuers, ensuring robustness.
    \item \textbf{Deduplication}: Employs nullifiers from Chapter~\ref{chap4} for efficient sybil resistance without costly operations.
    \item \textbf{Expressive Proofs}: Leverages Chapter~\ref{chap2}'s ABCs for privacy-preserving predicate verification (e.g., range proofs).
\end{itemize}

\subsection{Threat Model}

We assume up to $t-1$ malicious issuers in an $n$-issuer system, where $t$ is the threshold, reflecting realistic collusion scenarios in decentralized settings. The adversary cannot break the Discrete Logarithm (DL) or $q$-Diffie-Hellman Inversion ($q$-DDHI) assumptions, and network conditions support standard threshold protocols.

\section{Construction}
\label{sec:threshold-construction}

T-SIRIS builds on a PS threshold signature scheme over Pedersen commitments (detailed in Chapter~\ref{chap3}), enhanced with nullifiers for deduplication. The core protocol is outlined in Figure~\ref{fig:single-cred-protocol}.

\begin{figure}[h]
\caption{T-SIRIS Protocol Overview}
\label{fig:single-cred-protocol}
\begin{center}
\begin{tabular}{l@{\hspace{5em}}c@{\hspace{5em}}l}
\multicolumn{3}{l}{$\underline{\mathsf{OrgKeyGen}(1^{\lambda}, 1^{\ell})}$ for attribute vector length $\ell$} \\[1em]
\multicolumn{3}{l}{$\BG = (\mathbb{G}_1, \mathbb{G}_2, \mathbb{G}_T, e, g, \tilde{g}, p) \leftarrow \mathsf{BGGen}(1^{\lambda}), \; \mathsf{ck} \leftarrow \mathsf{CM.Setup}(\BG, 1^{\lambda}, \ell)$} \\[1em]
\multicolumn{3}{l}{$(\mathsf{sk}, \mathsf{vk}) \leftarrow \mathsf{RS.KeyGen}(\mathsf{ck}), \; \text{Return } (\mathsf{osk}, \mathsf{opk}) = (\mathsf{sk}, (\mathsf{vk}, \mathsf{ck}))$} \\[1em]
\multicolumn{3}{l}{$\underline{\mathsf{(Obtain, Issue)}}$:} \\[1em]
\multicolumn{3}{l}{User proves key validity via ZKPoK; issuers issue credential if valid.} \\[1em]
$\underline{\mathsf{Obtain}(\mathsf{opk})}$ && $\underline{\mathsf{Issue}(\pi_{\text{verkey}}, \mathsf{cm}, \mathsf{id}, \mathsf{ctx}, \mathsf{exp}, \mathsf{osk})}$ \\[1em]
& $\xleftarrow{\pi_{\text{verkey}}(\mathsf{sk}, \mathsf{vk}, \mathsf{ck})}$ & Compute and send $\pi_{\text{verkey}}$ \\[1em]
If $\pi_{\text{verkey}}(\mathsf{vk}, \mathsf{ck})$ fails, return $\bot$ && \\[1em]
\multicolumn{3}{l}{$\k_1 \leftarrow \mathbb{Z}_p, \usk \leftarrow \mathbb{Z}_p, \; \mathsf{cm}_1 = \mathsf{CM.Com}([0,0,0,\k_1];\usk)$} \\[1em]
& $\xrightarrow{\;\; \pi_{\text{zero}}(\mathsf{cm}_1) \;\;}$ & If $\pi_{\text{zero}}(\mathsf{cm}_1)$ fails, return $\bot$ \\[1em]
\multicolumn{3}{r}{$\k_2 \leftarrow \mathbb{Z}_p, \mathsf{cm}_2 = \mathsf{CM.Com}([\mathsf{id},\mathsf{ctx},\mathsf{exp},\k_2];0)$ where $\mathsf{ctx}=\text{"master"}$} \\[1em]
\multicolumn{3}{r}{$\mathsf{cm} = \mathsf{cm}_1 + \mathsf{cm}_2 = \mathsf{CM.Com}([\mathsf{id},\mathsf{ctx},\mathsf{exp},\k_1 + \k_2];\usk)$} \\[1em]
If $\mathsf{RS.Ver}(\sigma, \mathsf{cm}, \mathsf{opk}) = 0$, return $\bot$ & $\xleftarrow{\sigma, \mathsf{cm}, \k_2, \mathsf{id}, \mathsf{ctx}, \mathsf{exp}}$ & $u \leftarrow \mathbb{Z}_p, \; \sigma \leftarrow \mathsf{RS.Sign}(\mathsf{cm}, \mathsf{osk}, u)$ \\[1em]
\multicolumn{3}{l}{Else, return $\mathsf{cred} = (\sigma, \mathsf{cm}, \usk, \mathsf{opk})$} \\[1em]
\multicolumn{3}{l}{$\underline{\mathsf{(Show, Verify)}}$ for credential $\mathsf{cred}$ and predicate $\phi$:} \\[1em]
\multicolumn{3}{l}{User sends rerandomized proof; verifier checks validity.} \\[1em]
$\underline{\mathsf{Show}(\mathsf{cred})}$ && $\underline{\mathsf{Verify}(\sigma', \mathsf{cm}', \pi_{\phi}, \mathsf{opk})}$ \\[1em]
\multicolumn{3}{r}{Send empty access policy $\phi = \bot$} \\[0.5em]
\multicolumn{3}{l}{Parse $\mathsf{cred} = (\sigma, \mathsf{cm}, \usk, \mathsf{opk})$} \\[0.5em]
\multicolumn{3}{l}{\quad Sample $\Delta_{\usk}, \Delta_u \leftarrow \mathbb{Z}_p$} \\[1em]
\multicolumn{3}{l}{\quad $\sigma' = \mathsf{RS.Rand}(\sigma, \Delta_{\usk}, \Delta_u)$} \\[1em]
\multicolumn{3}{l}{\quad $\mathsf{cm}' = \mathsf{CM.Rand}(\mathsf{cm}, \Delta_{\usk}), \; \usk' = \usk + \Delta_{\usk}$} \\[1em]
\multicolumn{3}{l}{\quad Compute $\pi_{\phi}$} \\[1em]
& $\xrightarrow{\sigma', \mathsf{cm}', \pi_{\phi}}$ & If $\pi_{\phi}$ fails, return $0$, else $1$ \\[1em]
\end{tabular}
\end{center}
\footnotesize{Note: Full ZKPoK definitions in Appendix~\ref{app:zkpok}.}
\end{figure}






































\begin{definition}[PS Threshold Signatures over Pedersen Commitments]
A PS threshold signature scheme $\mathsf{RS}$ over Pedersen commitments consists of the following algorithms:
\begin{itemize}
    \item $\mathsf{DistKeyGen}(1^{\lambda}, t+1, n, \ell) \to (\mathsf{ck}, \mathsf{vk}, (\mathsf{sk}_i, \mathsf{vk}_i)_{i \in [n]}):$ Takes security parameter $\lambda$, corruption threshold $t$, number of parties $n$, and attribute count $\ell$. Outputs commitment key $\mathsf{ck}$, verification key $\mathsf{vk}$, and per-party keys $(\mathsf{sk}_i, \mathsf{vk}_i)$.
    \item $\mathsf{ShareSign}(\mathsf{ck}, \mathsf{sk}_i, (\mathsf{cm}_k, \pi_k^{\mathsf{zkpok}})_{k \in [\ell]}; h) \to [\sigma^*]_i:$ Takes party $i$'s secret key $\mathsf{sk}_i$, commitments $\mathsf{cm}_k$ with ZK proofs $\pi_k^{\mathsf{zkpok}}$, and randomizer $h$. Outputs signature share $[\sigma^*]_i$.
    \item $\mathsf{ShareVer}(\mathsf{ck}, \mathsf{vk}_i, (\mathsf{cm}_k, \pi_k^{\mathsf{zkpok}})_{k \in [\ell]}, [\sigma^*]_i; h) \to \{0,1\}:$ Takes party $i$'s verification key $\mathsf{vk}_i$, commitments with proofs, and signature share $[\sigma^*]_i$. Outputs accept ($1$) or reject ($0$).
    \item $\mathsf{Aggregate}(\mathsf{ck}, ([\sigma^*]_i)_{i \in S}, (r_k)_{k \in [\ell]}) \to \sigma:$ Takes signature shares from subset $S$ of parties and commitment randomness values. Outputs aggregated signature $\sigma$.
\end{itemize}
\end{definition}

\section{Construction}
\label{sec:threshold-construction}

\begin{figure}
    \caption{T-ABC System with Master Credential and Nullifier}
    \begin{center}
    \begin{tabular}{l@{\hspace{5em}}c@{\hspace{5em}}l}
    \multicolumn{3}{l}{$\underline{\mathsf{OrgKeyGen}(1^{\lambda}, 1^\ell)}$ for attribute vector length $\ell$} \\[1em]
    \multicolumn{3}{l}{$\BG = (\G_1, \G_2, \G_T, e, g, \tilg, p) \sample \BGGen(\secparam), \; \mathsf{ck} \sample \mathsf{CM.Setup}(\BG, \secparam, \ell)$} \\[1em]
    \multicolumn{3}{l}{$\text{Assume threshold keys } (\sk_1, \dots, \sk_n), \vk \text{ are generated via DKG.}$} \\[1em]
    \multicolumn{3}{l}{$\text{Return } (\osk, \opk) = ((\sk_1, \dots, \sk_n), (\vk, \ck))$} \\[1em]

    \multicolumn{3}{l}{$\underline{\mathsf{(ObtainContext, IssueContext)}}$ for context credential:} \\[1em]
    \multicolumn{3}{l}{$\text{Assume user holds master credential } \cred_{\text{master}} = (\sigma_{\text{master}}, \cm_{\text{master}}, \usk_{\text{master}}, \opk)$} \\[1em]
    \multicolumn{3}{l}{$\pirverkey(\vk, \ck) = \zkpok\{(\vk, x) \mid \vk = \tilde{g}^x \}$} \\[1em]
    \multicolumn{3}{l}{$\pirnull(\cm_{\text{master}}, \mathsf{ctx}) = \zkpok\{(\k_{\text{master}}, \usk_{\text{master}}) \mid \cm_{\text{master}} = g_1^{\id} g_2^{\text{"master"}} g_3^{\exp} g_4^{\k_{\text{master}}} g^{\usk_{\text{master}}} \land y = g^{1/(\k_{\text{master}} + \mathsf{ctx})} \}$} \\[1em]

    $\underline{\mathsf{ObtainContext}(\credm, \cmc)}$ && $\underline{\mathsf{IssueContext}(\pirverkey, \pirnull, y, \cm_{\text{ctx}}, \osk)}$ \\[1em]
    & $\xleftarrow{\pirverkey(\vk, \ck)}$ & Each issuer $i$ sends $\pirverkey(\vk, \ck)$ \\[1em]
    If $\pirverkey(\vk, \ck)$ fails for any $i$, return $\bot$ && \\[1em]
    \multicolumn{3}{l}{User computes nullifier $y = g^{1/(\k_{\text{master}} + \mathsf{ctx})}$ for context $\mathsf{ctx}$} \\[1em]
    \multicolumn{3}{l}{User generates $\pirnull(\cmm, \cmc)$} \\[1em]
    & $\xrightarrow{\;\; y, \pirnull \;\;}$ & If $\pirnull$ fails or $y \in \text{DedupTable}$, return $\bot$ \\[1em]
    \multicolumn{3}{l}{$\k_{\text{ctx}} \sample \Z_p, \usk_{\text{ctx}} \sample \Z_p, \; \cm_{\text{ctx}} = \CMCom([\id, \mathsf{ctx}, \exp, \k_{\text{ctx}}]; \usk_{\text{ctx}})$} \\[1em]
    \multicolumn{3}{r}{Each issuer $i$ computes partial signature $\sigma_i \sample \mathsf{RS.ShareSign}(\cm_{\text{ctx}}, \sk_i)$} \\[1em]
    \multicolumn{3}{r}{User aggregates $\sigma = \mathsf{RS.Aggregate}(\{\sigma_i\}_{i \in S})$ for threshold set $S$} \\[1em]
    If $\RSVer(\sigma, \cm_{\text{ctx}}, \opk) = 0$, return $\bot$ & $\xleftarrow{\qquad \sigma, \cm_{\text{ctx}} \qquad}$ & \\[1em]
    \multicolumn{3}{l}{Else, return $\cred_{\text{ctx}} = (\sigma, \cm_{\text{ctx}}, \usk_{\text{ctx}}, \opk)$} \\[1em]

    \multicolumn{3}{l}{$\underline{\mathsf{(Show, Verify)}}$ for credential $\cred$ and predicate $\phi$:} \\[1em]
    \multicolumn{3}{l}{$\Pi_\phi = \zkpok\{(\vec{m}, \usk') \mid \cm' = \CMCom(\vec{m}; \usk') \wedge \RSVer(\sigma', \cm', \opk) = 1 \wedge \phi(\vec{m}) = 1 \}$} \\[1em]
    $\underline{\mathsf{Show}(\cred)}$ && $\underline{\mathsf{Verify}(\sigma', \cm', \pi_\phi, \opk)}$ \\[1em]
    \multicolumn{3}{r}{Send access policy $\phi$} \\[0.5em]
    \multicolumn{3}{l}{Parse $\cred = (\sigma, \cm, \usk, \opk)$} \\[0.5em]
    \multicolumn{3}{l}{\quad Sample $\Delta_\usk, \Delta_u \sample \Z_p$} \\[1em]
    \multicolumn{3}{l}{\quad $\sigma' = \RSRand(\sigma, \Delta_\usk, \Delta_u)$} \\[1em]
    \multicolumn{3}{l}{\quad $\cm' = \CMRand(\cm, \Delta_\usk), \; \usk' = \usk + \Delta_\usk$} \\[1em]
    \multicolumn{3}{l}{\quad Compute $\Pi_\phi$} \\[1em]
    & $\xrightarrow{\sigma', \cm', \pi_\phi}$ & If $\pi_\phi$ fails, return 0, else 1 \\[1em]
    \end{tabular}
    \end{center}
    \label{fig:threshold-cred-protocol}
\end{figure}





\subsection{Deduplication Protocol}

Efficient sybil resistance using nullifiers:
\begin{itemize}
    \item \textbf{Process}: During issuance, issuers check nullifier $y = g^{1/(k + \mathsf{ctx})}$ against a deduplication table, where $k$ is a user secret and $\mathsf{ctx}$ is context. Users prove correctness via
    \[
    \pi_{\mathsf{dedup}} = \mathsf{ZKPoK}\{(k, \mathsf{ctx}, r) : \mathsf{cm} = \mathsf{Commit}([\mathsf{id}, \mathsf{ctx}, \ldots]; r) \land y = g^{1/(k + \mathsf{ctx})}\}.
    \]
    \item \textbf{Advantage}: Unlike S3ID's EDDX-based deduplication (relying on tACT token comparison~\cite{rabaninejad_attribute-based_2024}), our pairing-free nullifiers avoid expensive operations, reducing time from $15$–$19$ ms to $2.49$ ms (see Section~\ref{sec:threshold-performance}).
\end{itemize}














\subsection{Deduplication Protocol}
Efficient Sybil Resistance Using Nullifiers:
\begin{itemize}
    \item During issuance: Check nullifier $y = g^{1/(k + \mathsf{ctx})}$ against deduplication table
    \item Zero-knowledge proof: $\pi_{\mathsf{dedup}} = \mathsf{ZKPoK}\{(k, \mathsf{ctx}, r) : \mathsf{cm} = \mathsf{Commit}([\mathsf{id}, \mathsf{ctx}, \ldots]; r) \land y = g^{1/(k + \mathsf{ctx})}\}$
    \item Advantage: Efficiency
\end{itemize}

\section{Security Analysis}
\label{sec:threshold-security}

\subsection{Security Properties}
\begin{itemize}
    \item \textbf{Unforgeability}: Reduction to threshold signature security and MIMC-ABC unforgeability
    \item \textbf{Sybil Resistance}: Reduction to nullifier uniqueness (Chapter~\ref{sec:nullifier})
    \item \textbf{Anonymity}: Preserved from MIMC-ABC with threshold enhancement
    \item \textbf{Strong Unlinkability}: Inherited from underlying components
\end{itemize}

\subsection{Security Theorems}
\begin{theorem}[Unforgeability]
If the threshold signature scheme is EUF-CMA secure and the MIMC-ABC system is unforgeable, then $\mathsf{T\text{-}SIRIS}$ is unforgeable against up to $t-1$ malicious issuers.
\end{theorem}

\begin{theorem}[Sybil Resistance]
If the nullifier scheme from Chapter~\ref{chap4} satisfies uniqueness, then $\mathsf{T\text{-}SIRIS}$ is sybil-resistant.
\end{theorem}

\newpage
\section{Performance Evaluation}

First we compare the threshold anonymous counting token TACT with our Threshold ABC system. 

Then we compare their S3ID system (based on TACT) with our Threshold Identity System based on our ABC system and MIMC-ABC. 


\label{sec:threshold-performance-tact}
We have 2 subsets of tests, our first is where we benchmark the threshold primitive TABC in Token Request, Issue, Aggregate, Unblind, Prove, Verify algorithms, and compare ours against the construction from \cite{rabaninejad_attribute-based_2024}.

The second is its instantiation in an identity system where we combine our benchmark times from our threshold primitive with our other times to estimate and compare against the Dedup, MicroCred, AppCred, VerifyCred algorithms in \cite{rabaninejad_attribute-based_2024}.

\subsection{T-ABC Algorithm Benchmarks}

We evaluate performance with a fixed $N = 16$ (number of Threshold Nodes) and $t = 9$ (Threshold), varying attribute sizes $n = 4, 16, 64$, as shown in Table~\ref{tab:perf-comp-vary-n}. We set the middleground $N$ with comprehensive results for other $N$ in the appendix \ref{chap5:appendix-tactvspsutt-results}. The $n = 64$ case represents the worst-case scenario for large attribute sets. We then set $n$ (the number of attributes) to 16 and vary $N, t$ and show results in Table ~\ref{tab:perf-comp-vary-N}.

\subsubsection{Key Observations}

\begin{itemize}
    \item \textbf{Table \ref{tab:perf-comp-vary-n}: Fixed $N = 16, t = 9$, Varying $n$}
        \begin{itemize}
        \item Our scheme (PS-UTT) outperforms TACT in \textit{Token Request} ($6.0\times$) and \textit{Aggregate, Unblind} ($36.0\times$) at $n = 64$, leveraging \textit{multi-scalar multiplication} (MSM) in Schnorr proofs for sublinear scaling as explored in benchmarks \ref{fig:schnorr-benchmarks}. 
        
        \item In \textit{Prove} and \textit{Verify}, PS-UTT achieves speedups of $25.2\times$ and $44.1\times$ at $n = 64$, respectively, due to optimized Schnorr protocols avoiding TACT's costly pairings. TACT's \textit{Verify} time scales linearly with $n$ due to individual pairing checks per message in its threshold Shacham-Waters (tSW) signature verification.
        
        \item TACT excels in \textit{Issue} ($4.0\times$ faster at $n = 64$)
    \end{itemize}

    \item  \textbf{Table \ref{tab:perf-comp-vary-N}: Fixed $n = 16$, Varying $N,t$}
        \begin{itemize}
            \item \textit{Issue:} PS-UTT's time rises from 21.19 ms ($N = 4$) to 283.72 ms ($N = 64$) due to \textit{distributed key generation and threshold signing}, scaling linearly with $N$. 
            \item \textit{Token Request, Prove, Verify:} PS-UTT maintains consistent performance (e.g., Verify: 1.69-1.82 ms) with speedups of $6.1\times$ to $14.8\times$ at $N = 64$, as these operations are $N$-independent.
        \end{itemize}

    \item \textbf{Synthesis}
    PS-UTT scales efficiently with attributes $n$, achieving up to $44.1\times$ speedup in \textit{Verify} at $n = 64$, thanks to \textit{MSM-optimized Schnorr proofs}. However, it scales less favorably with nodes $N$, with \textit{Issue} performance dropping as $N$ grows, unlike TACT’s stable 13-14 ms. PS-UTT suits frequent credential use, while TACT fits large $N$, infrequent issuance scenarios.

\end{itemize}



\begin{table}[!htbp]
\centering
\caption[Threshold ABC Performance Comparison, fixed number of nodes, varying attribute length]{Performance Comparison for fixed $ N = 16, t = 9 $, varying $n$ (milliseconds)}
\begin{tabular}{lccccc}
\toprule
\textbf{Operation} & \textbf{Scheme} & \textbf{n=4} & \textbf{n=16} & \textbf{n=64} & \textbf{Speedup (n=64)} \\
\midrule
Token Request & PS-UTT & 1.65 & 6.16 & 22.71 & 6.0$\times$ \\
              & TACT   & 8.55 & 37.15 & 135.91 & \\
\midrule
Issue         & PS-UTT & 20.95 & 63.40 & 244.22 & -3.98$\times^\dagger$ \\
              & TACT   & 3.09 & 14.14 & 61.34 & \\
\midrule
(Aggregate, Unblind) & PS-UTT & 0.99 & 1.10 & 1.46 & 36.0$\times$ \\
                     & TACT   & 3.92 & 15.04 & 52.55 & \\
\midrule
Prove         & PS-UTT & 1.26 & 1.35 & 1.61 & 25.2$\times$ \\
              & TACT   & 7.90 & 15.78 & 40.56 & \\
\midrule
Verify        & PS-UTT & 1.71 & 1.82 & 1.68 & 44.1$\times$ \\
              & TACT   & 11.20 & 26.64 & 74.07 & \\
\bottomrule
\multicolumn{6}{l}{\small $^\dagger$ TACT is faster; speedup computed as PS-UTT time / TACT time.}
\end{tabular}
\label{tab:perf-comp-vary-n}
\end{table}


\begin{table}[htbp]
\centering
\caption[Threshold ABC Performance Comparison, fixed attribute length, varying number of nodes]{Performance Comparison for $n = 16$ (milliseconds)}
\begin{tabular}{lccccc}
\toprule
\textbf{Operation} & \textbf{Scheme} & \textbf{N=4, t=3} & \textbf{N=16, t=9} & \textbf{N=64, t=33} & \textbf{Speedup (N=64)} \\
\midrule
Token Request & PS-UTT & 5.97 & 6.16 & 5.88 & 6.1$\times$ \\
              & TACT   & 33.84 & 37.15 & 36.11 & \\
\midrule
Issue         & PS-UTT & 21.19 & 63.40 & 283.72 & -20.99$\times^\dagger$ \\
              & TACT   & 13.68 & 14.14 & 13.52 & \\
\midrule
(Aggregate, Unblind) & PS-UTT & 0.51 & 1.10 & 4.89 & 8.4$\times$ \\
                     & TACT   & 6.46 & 15.04 & 41.02 & \\
\midrule
Prove         & PS-UTT & 1.33 & 1.35 & 1.33 & 10.9$\times$\\
              & TACT   & 14.67 & 15.78 & 14.55 & \\
\midrule
Verify        & PS-UTT & 1.69 & 1.82 & 1.69 & 14.8$\times$ \\
              & TACT   & 23.51 & 26.64 & 25.03 & \\
\bottomrule
\multicolumn{6}{l}{\small $^\dagger$ TACT is faster; speedup computed as PS-UTT time / TACT time.}
\end{tabular}
\label{tab:perf-comp-vary-N}

\end{table}






\subsection{T-SIRIS Algorithm Benchmarks}










\section{Discussion}
\label{sec:threshold-discussion}

\subsection{Practical Deployment Considerations}
\begin{itemize}
    \item Standard threshold infrastructure compatible
    \item Efficient client-side operations for mobile deployment
    \item Flexible predicate system for diverse use cases
\end{itemize}

\subsection{Extensions and Future Work}
\begin{itemize}
    \item Post-quantum security considerations
    \item Dynamic threshold adjustments
    \item Integration with existing identity infrastructure
\end{itemize}

\section{Conclusion}
\label{sec:threshold-conclusion}

We presented the first threshold identity system that efficiently combines sybil resistance, expressive proofs, and revocation capabilities. By leveraging our efficient building blocks from previous chapters, we achieve 2-3× better performance than state-of-the-art systems while supporting strictly more functionality. Our system demonstrates that practical, privacy-preserving decentralized identity is achievable with proper cryptographic design.














\section{Threshold Credential Comparison}




\section{Identity System}

\begin{table}[h]
\centering
\caption{System Comparison Summary}
\begin{tabular}{lccc}
\toprule
\textbf{Feature/Operation} & \textbf{Our System} & \textbf{S3ID} & \textbf{Advantage} \\
\midrule
Threshold Credential & PS-UTT & TACT & 5-10× faster verify \\
Deduplication & Nullifier+ZKP & EDDX & ~5× faster \\
Expressive Proofs & Yes (Ch. 2) & Limited & Richer functionality \\
Token Request & 1.67-3.08ms & 8.33-16.58ms & 5× faster \\
Prove+Verify & <3ms & >20ms & >7× faster \\
\bottomrule
\end{tabular}
\end{table}
