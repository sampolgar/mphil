\mychapter{Threshold Sybil-Resistant Identity System}\label{chap6}

\section{Introduction}\label{sec:threshold-intro}
Self-sovereign identity (SSI) systems enable users to control their digital identities with strong privacy, Sybil resistance, and minimal issuer interaction. Distributing trust across multiple issuers is critical to avoid single points of failure. CanDID~\cite{maram2021candid} is a pioneering SSI system that uses multi-party computation (MPC) to deduplicate identities and issue credentials via a (threshold) committee of signing nodes. While effective, it has drawbacks: slow MPC-based deduplication, frequent issuer interactions, linkability risks, and little protection for credential non-transferability.

This chapter presents T-SIRIS, a threshold Sybil-resistant identity system built on our multi-issuer multi-credential anonymous credential system (MIMC-ABC) from Chapter~\ref{chap3} and Credential Relationship Binding Nullifier (CRBN) from Chapter~\ref{chap4}. T-SIRIS uses a $t$-out-of-$N$ threshold issuance model, secure against $t-1$ malicious issuers. We compare T-SIRIS with CanDID and S3ID~\cite{rabaninejad_attribute-based_2024}, which uses threshold anonymous counting tokens (tACT), showing improvements in efficiency and functionality.

\subsection*{Chapter Roadmap}
% The remainder of the chapter is structured as follows: In Section \ref{sec-vrf-introduction} we introduce nullifiers and their role in privacy-preserving protocols. In Section \ref{sec-vrf-preliminaries}, we introduce the preliminaries and building blocks, in Section \ref{subsec:deterministic-nullifier}, we present our Prime Order DY VRF construction, followed by privacy-preserving extensions in Section \ref{sec:privacy-preserving-vrf}. In Section \ref{sec:performance-vrf}, we evaluate our performance against the state-of-the-art schemes, and in Section \ref{sec-vrf-instantiation}, we outline instantiations of our construction for Anonymous Credentials. 

\subsection{Motivation and Challenges}

Traditional Attribute-Based Anonymous Credential systems (ABCs) are based on a centralized issuer, which has its own security flaws - a malicious issuer can issue credentials that can't be traced in an anonymous system, undermining the system's integrity. To address this, we distribute security among $N$ nodes, requiring a threshold of at least $t$ nodes to issue a valid credential. 

Existing systems struggle to balance privacy, efficiency, and functionality. 

CanDID~\cite{maram2021candid} pioneered Sybil-resistant identity with legacy credential oracles, but relies on costly multi-party computation (MPC) among committee nodes for deduplication and requires interactive issuance for context credentials, contradicting self-sovereign principles. Each transaction requires communication with committee members, introducing privacy vulnerabilities where a single malicious node can link different user transactions.

\subsubsection*{CanDID}
CanDID deduplicates a user attribute, e.g. social security number using MPC, storing a unique value in a table $T_{\text{Dedup}}$. Users create a master credential from legacy data via oracles, then request context-specific credentials. Its limitations include:

\begin{itemize}
    \item \textbf{Deduplication:} MPC deduplication is slow and reveals a pseudonym to issuers, enabling pseudonym linking. T-SIRIS uses CRBN, computing a nullifier $y = g^{1/(k + \text{ctx})} \in \mathbb{G}_1$ with user key $k \in \mathbb{Z}_p$ and context $\text{ctx}$. This is anonymous and $5\times$ faster than tACT~\cite{rabaninejad_attribute-based_2024} (see Section~\ref{sec:perf}).
    
    \item \textbf{Context Credential Issuance:} CanDID requires issuer interaction for each context credential, e.g., ``over 18.’’ T-SIRIS users receive credentials from different issuers and use ZKPs to prove predicates $\phi(\vec{m}) = m_1 \geq 18$ based on the attributes in their set of credentials, allowing flexibility and dynamic verification scenarios without interacting with an issuer each time. 
    
    \item \textbf{Sybil Resistance:} CanDID tracks public keys, risking linkability. T-SIRIS embeds $k$ in all credentials, using CRBN with ZKP $\Pi^{\mathcal{R}_{\text{null}}} = \text{ZKPoK}\{(k): y = g^{1/(k + \text{ctx})}\}$ for unlinkable Sybil resistance.
\end{itemize}

Both systems use a master-context credential hierarchy, but T-SIRIS allows different issuers for context credentials and supports flexible ZKP-based predicates.

\subsubsection*{S3ID/tACT} \cite{rabaninejad_attribute-based_2024} uses tACT, based on Shacham-Waters signatures, for Sybil resistance and threshold issuance. Both T-SIRIS and S3ID embed a user key $k$ in credentials. T-SIRIS improves in:
\begin{itemize}
    \item \textbf{Efficiency:} CRBN and Schnorr ZKPs avoid pairings, offering up to $44.1\times$ faster verification for $n=64$ attributes (see Section~\ref{sec:perf}).
    \item \textbf{Predicate Support:} S3ID’s Groth-Sahai proofs limit predicate expressiveness. T-SIRIS’s MIMC-ABC supports complex computation over group exponents e.g. Schnorr proofs and Range Proofs (see Chapter~\ref{chap:proofs}).
\end{itemize}

\subsubsection*{Oracle Integration}


\subsubsection*{Managing SSI Features with Privacy Preserving Cryptography}
SSI requires unlinkability, Sybil resistance, and efficiency. Approaches include tokens (tACT~\cite{rabaninejad_attribute-based_2024}), zkSNARKs~\cite{rosenberg_zk-creds_2022}, and anonymous credentials (ABC). T-SIRIS’s ABC-based design with CRBN and MIMC-ABC balances speed and flexibility, scaling well with attributes $n$ and issuers $N$.


\subsection{Contributions}
\label{sec:tsiris_contributions}

Our Threshold Sybil-Resistant Identity System (T-SIRIS) advances self-sovereign identity (SSI) by combining efficiency, expressiveness, and security in a multi-issuer setting. Built on the Multi-Issuer Multi-Credential Anonymous Credential system (MIMC-ABC) from Chapter~\ref{chap3} and the Credential Relationship Binding Nullifier (CRBN) from Chapter~\ref{chap4}, T-SIRIS outperforms existing systems like CanDID~\cite{maram2021candid} and S3ID~\cite{rabaninejad_attribute-based_2024}. Below, we outline our contributions, aligning them with S3ID’s claims to highlight T-SIRIS’s improvements.

\begin{enumerate}
    \item \textbf{Efficient Deduplication and Verification:} T-SIRIS achieves fast deduplication using CRBN, computing a nullifier $y = g^{1/(k + \text{ctx})} \in \mathbb{G}_1$ with user key $k \in \mathbb{Z}_p$ and context $\text{ctx}$. Unlike CanDID’s MPC-based deduplication, CRBN is pairing-free and $5\times$ faster than S3ID’s tACT~\cite{rabaninejad_attribute-based_2024}. Verification scales sublinearly with attributes $n$, achieving up to $44.1\times$ speedup over tACT for $n=64$ (see Section~\ref{sec:perf}).
    
    \item \textbf{Expressive Predicate Proofs:} T-SIRIS supports complex predicates (e.g., $\phi(\vec{m}) = m_1 \geq 18 \wedge m_2 \in S$) via MIMC-ABC and Schnorr-based zero-knowledge proofs (ZKPs). Unlike S3ID’s Groth-Sahai proofs, which limit expressiveness, T-SIRIS enables range proofs and set membership with sublinear complexity, enhancing flexibility for SSI applications (see Chapter~\ref{chap6}).
    
    \item \textbf{Provably Secure Multi-issuer SSI:} T-SIRIS provides formal security definitions and proofs for unforgeability, Sybil resistance, strong unlinkability, and identity binding, secure against $t-1$ malicious issuers in a $t$-out-of-$N$ threshold model. Our proofs, based on the $q$-DDHI assumption for CRBN and SDLP for MIMC-ABC, extend S3ID’s tACT-based security to multi-issuer settings with identity binding (see Section~\ref{sec:security}).
    
    \item \textbf{Non-transferability and Identity Binding:} T-SIRIS embeds a user key $k$ in all credentials, ensuring only the owner can use them, similar to S3ID. Additionally, MIMC-ABC binds credentials from multiple issuers to a single identifier $\text{id} \in \mathbb{Z}_p$, enabling proofs of shared identity without revealing it. This strengthens S3ID’s non-transferability by supporting multi-issuer scenarios (see Section~\ref{sec:construction}).
\end{enumerate}

\textbf{Comparison with S3ID/tACT:} S3ID~\cite{rabaninejad_attribute-based_2024} claims efficient deduplication, non-interactive credential generation, unlinkability, and non-transferability using tACT. T-SIRIS achieves these with superior efficiency (CRBN vs. tACT) and expressiveness (Schnorr vs. Groth-Sahai). While S3ID supports single-issuer deduplication, T-SIRIS’s MIMC-ABC enables multi-issuer identity binding, addressing a broader range of SSI use cases. Both systems ensure non-transferability via a private key, but T-SIRIS’s ZKP $\Pi^{\mathcal{R}_{\text{null}}} = \text{ZKPoK}\{(k): y = g^{1/(k + \text{ctx})}\}$ offers stronger unlinkability against colluding issuers.

\begin{table}[ht]
\centering
\caption{Comparison of T-SIRIS with prior SSI systems.}
\label{tab:comparison-chap5}
\begin{tabular}{l|cccccc}
\toprule
\textbf{System} & \textbf{Sybil Resist.} & \textbf{Multi-Issuer} & \textbf{Non-Interact.}$^{\dagger}$ & \textbf{Non-Transfer.}$^{\ddagger}$ & \textbf{Complex Pred.}$^{\S}$ & \textbf{M.I. Anon.}$^{\P}$ \\
\midrule
CanDID~\cite{maram2021candid} & \ding{51}$^{\text{a}}$ & \ding{51} & \ding{55} & \ding{55} & \ding{55} & \ding{55} \\
SyRA~\cite{crites_syra_2024} & \ding{51} & \ding{55} & \ding{51} & \ding{55} & \ding{55} & \ding{55} \\
S3ID~\cite{rabaninejad_attribute-based_2024} & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{55} & \ding{55} \\
T-SIRIS (Ours) & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} \\
\bottomrule
\end{tabular}
\begin{flushleft}
\footnotesize
$^{\dagger}$ Non-interactive application credential generation (Section~\ref{sec:construction}). \\
$^{\ddagger}$ Credentials bound to the true owner (Section~\ref{sec:construction}). \\
$^{\S}$ Support for complex predicates, e.g., range proofs (Section~\ref{sec:proofs}). \\
$^{\P}$ Anonymity against malicious issuers (Section~\ref{sec:security}). \\
$^{\text{a}}$ Pseudonymous, not fully anonymous. \\
\textit{Note:} We compare with CanDID for its SSI prominence, SyRA for its VRF-based Sybil resistance, and S3ID for its threshold similarity.
\end{flushleft}
\end{table}



















\section{Threshold Rerandomizable Signature for ABCs}
\label{sec:threshold-construction}

To distribute trust among multiple issuers, we adopt the threshold PS signature scheme from \cite{tomescu2022utt} using Shamir secret sharing with similarities to \cite{sonnino_coconut_2020}. The key pair $(\mathsf{sk}, \mathsf{vk})$ is $(t,n)$-secret-shared among the signers, where each signer $i$ holds a share secret key $\mathsf{sk}_i$ and a share verification key $\mathsf{vk}_i$. This enables subsets of at least $t+1$ signers to collaboratively produce a signature that verifies under the combined verification key $\mathsf{vk}$, while ensuring that no subset of $t$ or fewer signers can forge signatures.


\subsection{Overview}
We assume up to $t-1$ malicious issuers in an $n$-issuer system, where $t$ is the threshold, reflecting realistic collusion scenarios in decentralized settings. The adversary cannot break the hard problems our schemes are built upon, and network conditions support standard threshold protocols.


Importantly, this threshold construction distributed trust among multiple issuers while preserving the core properties of our underlying building block PS signature scheme - unforgeability and rerandomizability. Additionally, the end-signature algebraic structure is the same, and therefore, the verification algorithm and proof system compatibility are the same. 

\subsection{Definition}

\begin{definition}[PS Threshold Signatures over Pedersen Commitments]
A PS threshold signature scheme $\mathsf{RS}$ over Pedersen commitments consists of the following algorithms:
\begin{itemize}
    \item $\mathsf{DistKeyGen}(1^{\lambda}, t+1, n, \ell) \to (\mathsf{ck}, \mathsf{vk}, (\mathsf{sk}_i, \mathsf{vk}_i)_{i \in [n]}):$ Takes security parameter $\lambda$, corruption threshold $t$, number of parties $n$, and attribute count $\ell$. Outputs commitment key $\mathsf{ck}$, verification key $\mathsf{vk}$, and per-party keys $(\mathsf{sk}_i, \mathsf{vk}_i)$.
    
    \item $\mathsf{ShareSign}(\mathsf{ck}, \mathsf{sk}_i, (\mathsf{cm}_k, \pi_k^{\mathsf{zkpok}})_{k \in [\ell]}; h) \to [\sigma^*]_i:$ Takes party $i$'s secret key $\mathsf{sk}_i$, commitments $\mathsf{cm}_k$ with ZK proofs $\pi_k^{\mathsf{zkpok}}$, and randomizer $h$. Outputs signature share $[\sigma^*]_i$.
    
    \item $\mathsf{ShareVer}(\mathsf{ck}, \mathsf{vk}_i, (\mathsf{cm}_k, \pi_k^{\mathsf{zkpok}})_{k \in [\ell]}, [\sigma^*]_i; h) \to \{0,1\}:$ Takes party $i$'s verification key $\mathsf{vk}_i$, commitments with proofs, and signature share $[\sigma^*]_i$. Outputs accept ($1$) or reject ($0$).
    
    \item $\mathsf{Aggregate}(\mathsf{ck}, ([\sigma^*]_i)_{i \in S}, (r_k)_{k \in [\ell]}) \to \sigma:$ Takes signature shares from subset $S$ of parties and commitment randomness values. Outputs aggregated signature $\sigma$.

    \item $\mathsf{Rerand}(\mathsf{vk}, \sigma, \Delta_r, \Delta_u) \rightarrow \sigma'$: Creates a rerandomized signature $\sigma'$ from signature $\sigma$ using randomization values $\Delta_r, \Delta_u$.
    
    \item $\mathsf{Verify}(\mathsf{vk}, \mathsf{cm}, \sigma) \rightarrow \{0,1\}$: Verifies signature $\sigma$ on commitment $\mathsf{cm}$ using public key $\mathsf{vk}$.
    
\end{itemize}
\end{definition}

\subsection{SAM WRITE THE SECURITY DEFINITIONS - UNF, Threshold, }




\subsubsection{Construction}\label{threshold-ps-construction}


Our threshold PS construction works as follows:
A user with attributes $\attrs = [m_1, \ldots, m_\ell]$ generates a commitment $\cm = \CMCom([\attrs];r)$. The user interacts with signers using a pre-agreed random element $h \in \G_1$, alternatively, \cite{sonnino_coconut_2020} generates this with a hash-to-group of the commitment $h \gets \mathcal{H}(\cm)$. The user sends $\cm$ with $\Pi_{\cm}$ OR $\pi^{\mathsf{zkpok}}$ proving its opening to each signer. Signers verify the proof and return a signature share $[\sigma^*]_i = \mathsf{tPSutt.ShareSign}(\ck, \mathsf{sk}_i, (\mathsf{cm}_k, \pi^{\mathsf{zkpok}}); h)$. The user verifies each share and checks the consistency of the message and proof previously shared $\mathsf{tPSutt.ShareVer}(\ck, \mathsf{vk}_i, (\mathsf{cm}, \pi^{\mathsf{zkpok}}), [\sigma^*]_i; h)$. The user identifies a set $S$ of at least $t+1$ valid shares and aggregates them, outputting their signature $\sigma \leftarrow \mathsf{tPSutt.Aggregate}(\ck, ([\sigma^*]_i)_{i \in S}, r)$ which verifies under the combined  verification key $\mathsf{PSutt.Ver}(\mathsf{vk}, \mathsf{cm}, \sigma) = 1$.


\begin{itemize}
    \item $\mathsf{DistKeyGen}(1^{\lambda}, t+1, n, \ell) \to (\ck, \vk, (\mathsf{sk}_i, \mathsf{vk}_i)_{i \in [n]}):$ Takes input the security parameter, $t$ the corruption threshold, $n$ is number of nodes, $\ell$ is the credential message length. Outputs $\ck, \vk$ the commitment and verification keys generated with the secrets and $\sk_i, \vk_i$ the shared keys to distribute to $n$ nodes. let $\mathcal{X}$ and $\psi_k $ be $t$ degree polynomials:
    \begin{itemize}
        \item For the shared $x$ values: $\mathcal{X} \sample \Z_p[X], x \gets \mathcal{X}(0)$, $\{[x]_i \gets \mathcal{X}(i)\}_{i\in [n]}$
        \item For the $k$ shared $y$ values: $\{\psi_k \sample \Z_p[X], y_k \gets \psi_k(0)\}_{k \in [\ell]}$, $\{[y_k]_i \gets \psi_k(i)\}_{k \in [\ell], i \in [n]}$
        \item using the secret, non-shared values, trusted setup party computes $\vk \gets \tilde{g}^x, \ck \gets \CMSetup(1^{\lambda}, \ell, \vec{y})$ and parses $\ck$ as $(g, \vec{g}, \tilde{g}, \vec{\tilde{g}})$. Note that $g_k = g^{y_k}, \tilde{g}_k = \tilde{g}^{y_k}$
        \item computes shared secret values $\{\sk_i \gets ([x]_i, ([y_k]_i))_{k\in[\ell]}\}_{i \in [n]}, \{\vk \gets (\tilde{g}^{[x]_i}, (\tilde{g}^{[y_k]_i})_{k\in[\ell]})\}_{i \in [n]}$
        \item $\mathsf{Return } $ $ \ck, \vk, \{\sk_i, \vk_i\}_{i \in [n]}$
    \end{itemize}
        

    \item $\mathsf{ShareSign}(\ck, \mathsf{sk}_i, \{\cm_k, \pi_k^{\mathsf{zkpok}}\}_{k \in [\ell]}, h) \to [\sigma^*]_i:$ the user runs $\mathsf{ShareSign}$ with at least $t$ nodes. 
    \begin{itemize}
        \item User commits to each $m$ individually: $\cm_k = h^{m_k}g^{r_k}$ and generates proofs for each $\cm_k = \zkpok(\cm_k, m_k, r_k)$ and sends each signer the commitment and proof.
        \item Signer parses $g$ from $\ck$ and verifies the opening of the commitment w.r.t. the proof.
        \item Signer parses $\sk_i$ as $[x]_i, \{[y_k]_i\}_{k \in [\ell]}$
        \item Signer signs their share $[\sigma^*]_i \gets (h, h^{[x]_i} \prod_{k \in [\ell]} \cm_k^{[y_k]_i} )$ = $(h, h^{[x]_i + \sum_{k \in [\ell]} m_k[y_k]_i} \cdot g^{\sum_{k \in [\ell]} r_k [y_k]_i})$
    \end{itemize}


    \item $\mathsf{ShareVer}(\ck, \mathsf{vk}_i, \{\cm_k, \pi_k^{\mathsf{zkpok}}\}_{k \in [\ell]}, [\sigma^*]_i; h) \to \{0,1\}:$ Run by a user to verify the signed share returned from each node before aggregating together. 
    \begin{itemize}
        \item Parse $[\sigma^*]_i$ as $([\sigma^*]_{i,1}, [\sigma^*]_{i,2})$ and check $h = [\sigma^*]_{i,1}$. 
        \item Verify each message commitment $\cm_k$ and proof $\pi_k$
        \item Parses $\vk_i$ as $(\tilde{g}^{[x]_i}, \{\tilde{g}^{[y_k]_i}\}_{k \in [\ell]})$
        \item Asserts $e([\sigma^*]_{i,2}, \tilde{g}) = e(h, \tilde{g}^{[x]_i}) \cdot \prod_{k \in [\ell]} e(\cm_k, \tilde{g}^{[y_k]_i})$
    \end{itemize}

    \item $\mathsf{Aggregate}(\ck, ([\sigma^*]_i)_{i \in S}, \{r_k\}_{k \in [\ell]}) \to \sigma:$ User parses $\ck$ as $(\cdot, \vec{g}, \cdot, \cdot)$ and $\forall i \in S$, parse $[\sigma^*]_i$ as $(h, [\sigma^*]_{i,2})$. Runs Lagrange Interpolation on $|S|=t+1$ signature shares:
    \begin{itemize}
        \item  $\mathcal{L}_i \gets \prod_{j \in S, j\neq i}\frac{0-j}{i-j} \forall i \in S$
        \item $\sigma_2 \gets \prod_{j \in S}([\sigma^*]_{i,2})^{\mathcal{L}_i}$ = 
        $(h, h^{x + \sum_{k \in [\ell]} m_ky_k} \cdot g^{\sum_{k \in [\ell]} r_ky_k})$ where $g_k = g^{y_k}$
        \item $\sigma \gets (h, \sigma_2 / \prod_{k \in [\ell]}g_k^{r_k})$ = $(h, h^{x + \sum_{k \in [\ell]}m_ky_k})$
    \end{itemize}

    \item $\mathsf{RS.Rerand}(\sigma, \Delta_r, \Delta_u) \to \sigma':$
        Parse $\sigma$ as $(\sigma_1, \sigma_2)$
        Set $\sigma_1' \gets \sigma_1^{\Delta_u}$
        Set $\sigma_2' \gets (\sigma_2 \cdot \sigma_1^{\Delta_r})^{\Delta_u}$
        Return $\sigma' \gets (\sigma_1', \sigma_2')$
    
    \item $\mathsf{RS.Ver}(\vk, \cm, \sigma) \to \bit:$
        Parse $\sigma$ as $(\sigma_1, \sigma_2)$, The prover $\Prover$ runs a Proof of Knowledge protocol with the following relation 
    \[
        \mathcal{R} \gets \mathsf{PoK}\{(m_1,\ldots,m_\ell, r + \Delta_r): 
    \]
    \[
         e(\sigma_2', \tilde{g}) = e(\sigma_1', \vk)\cdot e(\sigma_1', \widetilde{\cm}') \quad \wedge \quad
        e(\cm', \tilde{g}) = e(g, \widetilde{\cm}') \quad \wedge \quad
        \cm' = g^{r + \Delta_r} \prod_{i=1}^\ell g_i^{m_i}
        \}
    \]

\end{itemize}

\subsection{Security Properties}

The threshold PS signature scheme preserves the security properties of the underlying PS signature scheme while distributing trust across multiple parties.

\begin{theorem}[Threshold Security]
The threshold PS signature scheme is secure against adversaries corrupting up to $t-1$ signers, assuming the hardness of the Discrete Logarithm (DL) problem and the unforgeability of the underlying PS signature scheme.
\end{theorem}

\begin{theorem}[Rerandomizability]
Signatures produced by the threshold PS scheme can be rerandomized to prevent linking, while preserving verifiability. The distribution of rerandomized signatures is computationally indistinguishable from freshly generated signatures on the same message.
\end{theorem}

We omit formal proofs of these properties as they follow directly from the security of Shamir's secret sharing and the properties of the PS signature scheme established in Chapter~\ref{chap2}. The threshold construction ensures that no coalition of fewer than $t$ parties can forge valid signatures, while any set of at least $t+1$ honest parties can collaboratively issue signatures.

\subsection{Application to Identity Systems}

This threshold PS signature scheme forms the cryptographic foundation of our T-SIRIS identity system described in the next section. By distributing the signing authority across multiple issuers, we achieve:

\begin{itemize}
    \item \textbf{Distributed Trust}: No single issuer has complete control over credential generation
    \item \textbf{Robustness}: The system remains operational even if some issuers become unavailable
    \item \textbf{Integrity}: Preventing compromised issuers from unilaterally issuing credentials
\end{itemize}

Importantly, the final aggregated signature is structurally identical to a standard PS signature, allowing us to leverage all the zero-knowledge proof techniques and optimizations developed in Chapter~\ref{chap2} without modification. This enables seamless integration with our MIMC-ABC and nullifier constructions to create a comprehensive privacy-preserving identity framework.










\section{T-SIRIS: Threshold Sybil-Resistant Identity System}
\label{sec:tsiris}

% Overview

Building on our threshold PS signature scheme, we now present T-SIRIS, a complete threshold sybil-resistant identity system. T-SIRIS integrates the threshold signature with credential relationship binding nullifiers (from Chapter~\ref{chap4}) and expressive zero-knowledge proofs (from Chapter~\ref{chap2}) to create a privacy-preserving identity framework that prevents sybil attacks while maintaining anonymity.

% Our Multi-Issuer Multi-Credential Anonymous Credential (MIMC-ABC) system extends the single-issuer Attribute-Based Anonymous Credential (ABC) framework from Chapter 2 to support credentials from multiple, mutually distrusting issuers, bound to a single identity. The ABC system (Section 2.4) uses a variant of rerandomizable Pointcheval-Sanders signatures~\cite{sako_short_2016} and position-binding Pedersen commitments~\cite{tomescu2022utt} to enable expressive predicate proofs over attributes. MIMC-ABC builds on this by introducing multi-issuer key generation and a cryptographic identity binding mechanism, ensuring all credentials verifiably belong to the same user without revealing their identity.

T-SIRIS integrates four key components:
\begin{itemize}
    \item \textbf{Threshold Key Generation}: Uses distributed key generation (DKG) with Shamir secret sharing for decentralized trust across $n$ issuers.
    \item \textbf{Threshold Issuance}: Extends MIMC-ABC (Chapter~\ref{chap3}) to issue credentials with $t$ of $n$ issuers, ensuring robustness.
    \item \textbf{Deduplication}: Employs nullifiers from Chapter~\ref{chap4} for efficient sybil resistance without costly operations.
    \item \textbf{Expressive Proofs}: Leverages Chapter~\ref{chap2}'s ABCs for privacy-preserving predicate verification (e.g., range proofs).
\end{itemize}


\subsubsection{Threat Model}
We assume up to $t-1$ malicious issuers in an $n$-issuer system, where $t$ is the threshold. These malicious issuers may:
\begin{itemize}
    \item Deviate from the protocol specification
    \item Collude to attempt to forge credentials
    \item Attempt to track or deanonymize users
    \item Refuse to participate in the issuance protocol
\end{itemize}

We also assume users may attempt sybil attacks by requesting multiple credentials for the same context. However, the adversary cannot break the underlying cryptographic assumptions (DL and $q$-DDHI).


% 

\subsection{Definition}

A T-SIRIS system consists of the following probabilistic polynomial-time (PPT) algorithms, parameterized by a security parameter $\lambda$ and attribute vector length $\ell$:

\begin{definition}[T-SIRIS]
    \begin{itemize}
    \item $\mathsf{Setup}(1^\lambda) \to \mathsf{pp}$: Outputs public parameters $\mathsf{pp}$, including a bilinear group $\BG = (\G_1, \G_2, \G_T, e, g, \tilde{g}, p)$ as in Section 2.1.

    \item $\mathsf{KeyGen}(\mathsf{pp}, \ell, t, n) \to (\ck, \vk, \{(\mathsf{sk}_i, \mathsf{vk}_i)\}_{i \in [n]})$: Generates public commitment and verification keys  $\mathsf{ck}, \mathsf{vk}$ and distributes secret/verification key shares to $n$ issuers using a $(t,n)$-threshold scheme.

    \item $\mathsf{Dedup}(\credm, \cmc, \nullifier, \pi_{\nullifier}, \mathcal{T}) \to (\bit, T'):$ Takes input the user master credential $(\credm = \sigmam, \cmm, \uskm)$ and context commitment $\cmc$, the nullifier $\nullifier$ and its proof of correctness $\pi_{\nullifier}$ and the redeemed credential list $\mathcal{T}$. Outputs 0 if the proof fails or outputs 1 and updates the credential list T with $\nullifier$

    \item $(\mathsf{ObtainMaster}(\attrs, \ck, \{\mathsf{vk}_i\}_{i \in S}), \mathsf{IssueMaster}(\{(\mathsf{sk}_i)\}_{i \in S}, \{\cm_k, \pi_k\}_{k \in [\ell]})) \to (\credm, \bot)$: an interactive protocol between a user running $\mathsf{ObtainMaster}$ from a subset $S$ of issuers where $|S| \geq t$ with each issuer running $\mathsf{IssueMaster}$. $\mathsf{ObtainMaster}$ takes in the user's attributes $\attrs$, commitment key $\ck$ and verification key shares for at least $S$ nodes $\{\vk_i\}_{i \in S}$. $\mathsf{IssueMaster}$ is run at least $|S|$ times, takes input the signers shared secret key $\sk_i$, commitment and proof pair for each message  $\{\cm_k, \pi_k\}_{k \in [\ell]}$. Outputs $\credm$ to the user and $\bot$ to itself.

    \item $(\mathsf{ObtainContext}(\credm, \attrs, \ck, \{\mathsf{vk}_i\}_{i \in S}), \mathsf{IssueContext}(\{(\mathsf{sk}_i)\}_{i \in S}, \{\cm_k, \pi_k\}_{k \in [\ell]}, \aux)) \to (\credc, \bot)$: an interactive protocol between a user running $\mathsf{ObtainContext}$ from a subset $S$ of issuers where $|S| \geq t$ with each issuer running $\mathsf{IssueContext}$.
    $\mathsf{ObtainContext}$ takes in the user's master credential $\credm$, new attributes $\attrs$, commitment key $\ck$ and verification key shares for at least $S$ nodes $\{\vk_i\}_{i \in S}$. $\mathsf{IssueContext}$ is run at least $|S|$ times, takes input the signers shared secret key $\sk_i$, commitment and proof pair for each message  $\{\cm_k, \pi_k\}_{k \in [\ell]}$ and auxiliary information $\aux$ e.g. outputs $\nullifier, \pi_{\nullifier},\mathcal{T}$ from $\mathsf{Dedup}$ and $\pi_{\mathsf{verify}}$ for $\credm$. Outputs $\credc$ to the user and $\bot$ to itself.

    \item $(\mathsf{Show}(\mathsf{cred}, \usk, \phi), \mathsf{Verify}(\mathsf{cred}', \pi)) \to \{0,1\}$: An interactive protocol between a user and verifier. The user inputs a credential $\cred = (\sigma, \cm, \usk)$ and predicate for verification $\phi$. $\mathsf{Verify}$ takes input the rerandomized credential $\cred'$ and proof $\pi$ it satisfies $\phi$. The verifier outputs 1 if valid, 0 otherwise.
\end{itemize}
\end{definition}


\subsection{Security Properties}

T-SIRIS inherits the core security properties from the ABC system—correctness, unforgeability, and anonymity (Section 2.5)—and adds identity binding for the multi-issuer setting:

\begin{itemize}
    \item \textbf{Correctness}: An honest user with valid credentials from multiple issuers can generate a proof for any predicate $\phi$ their attributes satisfy, including same-identity constraints, which verifies with probability $1 - \negl(\lambda)$.
    
    \item \textbf{Unforgeability}: No PPT adversary can produce a valid proof for a predicate $\phi$ they cannot legitimately satisfy, including forging credentials or mixing credentials from different identities, except with negligible probability.
    
    \item \textbf{Anonymity}: Proofs reveal only that $\phi$ is satisfied, not the user’s identity or credential details, even if all issuers and the verifier collude.

\end{itemize}








\subsubsection{System Overview}



\subsection{Construction}

\subsubsection{Overview}
T-SIRIS operates in two credential issuance phases: master credential issuance and context credential issuance. The master credential establishes the user's base identity with a secret key $\k$, while context credentials are bound to this master credential through nullifiers derived from $\k$ and a context $\mathsf{ctx}$. The nullifier mechanism prevents sybil attacks by ensuring users can obtain only one credential per context.

\subsubsection{Detailed Construction}
% Keep your existing figure and protocol descriptions
% They look good but could benefit from more explanatory text

\subsection{Security Analysis}

We analyze the security of T-SIRIS in terms of four key properties: unforgeability, sybil resistance, anonymity

% Keep your existing security theorems
























\label{sec:threshold-construction}

\begin{figure}
    \caption{T-ABC System with Master Credential and Nullifier}
    \begin{center}
    \begin{tabular}{l@{\hspace{5em}}c@{\hspace{5em}}l}
    \multicolumn{3}{l}{$\underline{\mathsf{OrgKeyGen}(1^{\lambda}, 1^\ell)}$ for attribute vector length $\ell$} \\[1em]
    \multicolumn{3}{l}{$\BG = (\G_1, \G_2, \G_T, e, g, \tilg, p) \sample \BGGen(\secparam), \; \mathsf{ck} \sample \mathsf{CM.Setup}(\BG, \secparam, \ell)$} \\[1em]
    \multicolumn{3}{l}{$\text{Assume threshold keys } (\sk_1, \dots, \sk_n), \vk \text{ are generated via DKG.}$} \\[1em]
    \multicolumn{3}{l}{$\text{Return } (\osk, \opk) = ((\sk_1, \dots, \sk_n), (\vk, \ck))$} \\[1em]

    \multicolumn{3}{l}{$\underline{\mathsf{(ObtainContext, IssueContext)}}$ for context credential:} \\[1em]
    \multicolumn{3}{l}{$\text{Assume user holds master credential } \cred_{\text{master}} = (\sigma_{\text{master}}, \cm_{\text{master}}, \usk_{\text{master}}, \opk)$} \\[1em]
    \multicolumn{3}{l}{$\pirverkey(\vk, \ck) = \zkpok\{(\vk, x) \mid \vk = \tilde{g}^x \}$} \\[1em]
    \multicolumn{3}{l}{$\pirnull(\cm_{\text{master}}, \mathsf{ctx}) = \zkpok\{(\k_{\text{master}}, \usk_{\text{master}}) \mid \cm_{\text{master}} = g_1^{\id} g_2^{\text{"master"}} g_3^{\exp} g_4^{\k_{\text{master}}} g^{\usk_{\text{master}}} \land y = g^{1/(\k_{\text{master}} + \mathsf{ctx})} \}$} \\[1em]

    $\underline{\mathsf{ObtainContext}(\credm, \cmc)}$ && $\underline{\mathsf{IssueContext}(\pirverkey, \pirnull, y, \cm_{\text{ctx}}, \osk)}$ \\[1em]
    & $\xleftarrow{\pirverkey(\vk, \ck)}$ & Each issuer $i$ sends $\pirverkey(\vk, \ck)$ \\[1em]
    If $\pirverkey(\vk, \ck)$ fails for any $i$, return $\bot$ && \\[1em]
    \multicolumn{3}{l}{User computes nullifier $y = g^{1/(\k_{\text{master}} + \mathsf{ctx})}$ for context $\mathsf{ctx}$} \\[1em]
    \multicolumn{3}{l}{User generates $\pirnull(\cmm, \cmc)$} \\[1em]
    & $\xrightarrow{\;\; y, \pirnull \;\;}$ & If $\pirnull$ fails or $y \in \text{DedupTable}$, return $\bot$ \\[1em]
    \multicolumn{3}{l}{$\k_{\text{ctx}} \sample \Z_p, \usk_{\text{ctx}} \sample \Z_p, \; \cm_{\text{ctx}} = \CMCom([\id, \mathsf{ctx}, \exp, \k_{\text{ctx}}]; \usk_{\text{ctx}})$} \\[1em]
    \multicolumn{3}{r}{Each issuer $i$ computes partial signature $\sigma_i \sample \mathsf{RS.ShareSign}(\cm_{\text{ctx}}, \sk_i)$} \\[1em]
    \multicolumn{3}{r}{User aggregates $\sigma = \mathsf{RS.Aggregate}(\{\sigma_i\}_{i \in S})$ for threshold set $S$} \\[1em]
    If $\RSVer(\sigma, \cm_{\text{ctx}}, \opk) = 0$, return $\bot$ & $\xleftarrow{\qquad \sigma, \cm_{\text{ctx}} \qquad}$ & \\[1em]
    \multicolumn{3}{l}{Else, return $\cred_{\text{ctx}} = (\sigma, \cm_{\text{ctx}}, \usk_{\text{ctx}}, \opk)$} \\[1em]

    \multicolumn{3}{l}{$\underline{\mathsf{(Show, Verify)}}$ for credential $\cred$ and predicate $\phi$:} \\[1em]
    \multicolumn{3}{l}{$\Pi_\phi = \zkpok\{(\vec{m}, \usk') \mid \cm' = \CMCom(\vec{m}; \usk') \wedge \RSVer(\sigma', \cm', \opk) = 1 \wedge \phi(\vec{m}) = 1 \}$} \\[1em]
    $\underline{\mathsf{Show}(\cred)}$ && $\underline{\mathsf{Verify}(\sigma', \cm', \pi_\phi, \opk)}$ \\[1em]
    \multicolumn{3}{r}{Send access policy $\phi$} \\[0.5em]
    \multicolumn{3}{l}{Parse $\cred = (\sigma, \cm, \usk, \opk)$} \\[0.5em]
    \multicolumn{3}{l}{\quad Sample $\Delta_\usk, \Delta_u \sample \Z_p$} \\[1em]
    \multicolumn{3}{l}{\quad $\sigma' = \RSRand(\sigma, \Delta_\usk, \Delta_u)$} \\[1em]
    \multicolumn{3}{l}{\quad $\cm' = \CMRand(\cm, \Delta_\usk), \; \usk' = \usk + \Delta_\usk$} \\[1em]
    \multicolumn{3}{l}{\quad Compute $\Pi_\phi$} \\[1em]
    & $\xrightarrow{\sigma', \cm', \pi_\phi}$ & If $\pi_\phi$ fails, return 0, else 1 \\[1em]
    \end{tabular}
    \end{center}
    \label{fig:threshold-cred-protocol}
\end{figure}





\subsection{Deduplication Protocol}

Efficient sybil resistance using nullifiers:
\begin{itemize}
    \item \textbf{Process}: During issuance, issuers check nullifier $y = g^{1/(k + \mathsf{ctx})}$ against a deduplication table, where $k$ is a user secret and $\mathsf{ctx}$ is context. Users prove correctness via
    \[
    \pi_{\mathsf{dedup}} = \mathsf{ZKPoK}\{(k, \mathsf{ctx}, r) : \mathsf{cm} = \mathsf{Commit}([\mathsf{id}, \mathsf{ctx}, \ldots]; r) \land y = g^{1/(k + \mathsf{ctx})}\}.
    \]
    \item \textbf{Advantage}: Unlike S3ID's EDDX-based deduplication (relying on tACT token comparison~\cite{rabaninejad_attribute-based_2024}), our pairing-free nullifiers avoid expensive operations, reducing time from $15$–$19$ ms to $2.49$ ms (see Section~\ref{sec:threshold-performance}).
\end{itemize}


\section{Security Analysis}
\label{sec:threshold-security}

\subsection{Security Properties}
\begin{itemize}
    \item \textbf{Unforgeability}: Reduction to threshold signature security and MIMC-ABC unforgeability
    \item \textbf{Sybil Resistance}: Reduction to nullifier uniqueness (Chapter~\ref{sec:nullifier})
    \item \textbf{Anonymity}: Preserved from MIMC-ABC with threshold enhancement
    \item \textbf{Strong Unlinkability}: Inherited from underlying components
\end{itemize}

\subsection{Security Theorems}
\begin{theorem}[Unforgeability]
If the threshold signature scheme is EUF-CMA secure and the MIMC-ABC system is unforgeable, then $\mathsf{T\text{-}SIRIS}$ is unforgeable against up to $t-1$ malicious issuers.
\end{theorem}

\begin{theorem}[Sybil Resistance]
If the nullifier scheme from Chapter~\ref{chap4} satisfies uniqueness, then $\mathsf{T\text{-}SIRIS}$ is sybil-resistant.
\end{theorem}

\newpage
\section{Performance Evaluation}

First we compare the threshold anonymous counting token TACT with our Threshold ABC system. 

Then we compare their S3ID system (based on TACT) with our Threshold Identity System based on our ABC system and MIMC-ABC. 


\label{sec:threshold-performance-tact}
We have 2 subsets of tests, our first is where we benchmark the threshold primitive TABC in Token Request, Issue, Aggregate, Unblind, Prove, Verify algorithms, and compare ours against the construction from \cite{rabaninejad_attribute-based_2024}.

The second is its instantiation in an identity system where we combine our benchmark times from our threshold primitive with our other times to estimate and compare against the Dedup, MicroCred, AppCred, VerifyCred algorithms in \cite{rabaninejad_attribute-based_2024}.

\subsection{T-ABC Algorithm Benchmarks}

We evaluate performance with a fixed $N = 16$ (number of Threshold Nodes) and $t = 9$ (Threshold), varying attribute sizes $n = 4, 16, 64$, as shown in Table~\ref{tab:perf-comp-vary-n}. We set the middleground $N$ with comprehensive results for other $N$ in the appendix \ref{chap5:appendix-tactvspsutt-results}. The $n = 64$ case represents the worst-case scenario for large attribute sets. We then set $n$ (the number of attributes) to 16 and vary $N, t$ and show results in Table ~\ref{tab:perf-comp-vary-N}.

\subsubsection{Key Observations}

\begin{itemize}
    \item \textbf{Table \ref{tab:perf-comp-vary-n}: Fixed $N = 16, t = 9$, Varying $n$}
        \begin{itemize}
        \item Our scheme (PS-UTT) outperforms TACT in \textit{Token Request} ($6.0\times$) and \textit{Aggregate, Unblind} ($36.0\times$) at $n = 64$, leveraging \textit{multi-scalar multiplication} (MSM) in Schnorr proofs for sublinear scaling as explored in benchmarks \ref{fig:schnorr-benchmarks}. 
        
        \item In \textit{Prove} and \textit{Verify}, PS-UTT achieves speedups of $25.2\times$ and $44.1\times$ at $n = 64$, respectively, due to optimized Schnorr protocols avoiding TACT's costly pairings. TACT's \textit{Verify} time scales linearly with $n$ due to individual pairing checks per message in its threshold Shacham-Waters (tSW) signature verification.
        
        \item TACT excels in \textit{Issue} ($4.0\times$ faster at $n = 64$)
    \end{itemize}

    \item  \textbf{Table \ref{tab:perf-comp-vary-N}: Fixed $n = 16$, Varying $N,t$}
        \begin{itemize}
            \item \textit{Issue:} PS-UTT's time rises from 21.19 ms ($N = 4$) to 283.72 ms ($N = 64$) due to \textit{distributed key generation and threshold signing}, scaling linearly with $N$. 
            \item \textit{Token Request, Prove, Verify:} PS-UTT maintains consistent performance (e.g., Verify: 1.69-1.82 ms) with speedups of $6.1\times$ to $14.8\times$ at $N = 64$, as these operations are $N$-independent.
        \end{itemize}

    \item \textbf{Synthesis}
    PS-UTT scales efficiently with attributes $n$, achieving up to $44.1\times$ speedup in \textit{Verify} at $n = 64$, thanks to \textit{MSM-optimized Schnorr proofs}. However, it scales less favorably with nodes $N$, with \textit{Issue} performance dropping as $N$ grows, unlike TACT’s stable 13-14 ms. PS-UTT suits frequent credential use, while TACT fits large $N$, infrequent issuance scenarios.

\end{itemize}



\begin{table}[!htbp]
\centering
\caption[Threshold ABC Performance Comparison, fixed number of nodes, varying attribute length]{Performance Comparison for fixed $ N = 16, t = 9 $, varying $n$ (milliseconds)}
\begin{tabular}{lccccc}
\toprule
\textbf{Operation} & \textbf{Scheme} & \textbf{n=4} & \textbf{n=16} & \textbf{n=64} & \textbf{Speedup (n=64)} \\
\midrule
Token Request & PS-UTT & 1.65 & 6.16 & 22.71 & 6.0$\times$ \\
              & TACT   & 8.55 & 37.15 & 135.91 & \\
\midrule
Issue         & PS-UTT & 20.95 & 63.40 & 244.22 & -3.98$\times^\dagger$ \\
              & TACT   & 3.09 & 14.14 & 61.34 & \\
\midrule
(Aggregate, Unblind) & PS-UTT & 0.99 & 1.10 & 1.46 & 36.0$\times$ \\
                     & TACT   & 3.92 & 15.04 & 52.55 & \\
\midrule
Prove         & PS-UTT & 1.26 & 1.35 & 1.61 & 25.2$\times$ \\
              & TACT   & 7.90 & 15.78 & 40.56 & \\
\midrule
Verify        & PS-UTT & 1.71 & 1.82 & 1.68 & 44.1$\times$ \\
              & TACT   & 11.20 & 26.64 & 74.07 & \\
\bottomrule
\multicolumn{6}{l}{\small $^\dagger$ TACT is faster; speedup computed as PS-UTT time / TACT time.}
\end{tabular}
\label{tab:perf-comp-vary-n}
\end{table}


\begin{table}[htbp]
\centering
\caption[Threshold ABC Performance Comparison, fixed attribute length, varying number of nodes]{Performance Comparison for $n = 16$ (milliseconds)}
\begin{tabular}{lccccc}
\toprule
\textbf{Operation} & \textbf{Scheme} & \textbf{N=4, t=3} & \textbf{N=16, t=9} & \textbf{N=64, t=33} & \textbf{Speedup (N=64)} \\
\midrule
Token Request & PS-UTT & 5.97 & 6.16 & 5.88 & 6.1$\times$ \\
              & TACT   & 33.84 & 37.15 & 36.11 & \\
\midrule
Issue         & PS-UTT & 21.19 & 63.40 & 283.72 & -20.99$\times^\dagger$ \\
              & TACT   & 13.68 & 14.14 & 13.52 & \\
\midrule
(Aggregate, Unblind) & PS-UTT & 0.51 & 1.10 & 4.89 & 8.4$\times$ \\
                     & TACT   & 6.46 & 15.04 & 41.02 & \\
\midrule
Prove         & PS-UTT & 1.33 & 1.35 & 1.33 & 10.9$\times$\\
              & TACT   & 14.67 & 15.78 & 14.55 & \\
\midrule
Verify        & PS-UTT & 1.69 & 1.82 & 1.69 & 14.8$\times$ \\
              & TACT   & 23.51 & 26.64 & 25.03 & \\
\bottomrule
\multicolumn{6}{l}{\small $^\dagger$ TACT is faster; speedup computed as PS-UTT time / TACT time.}
\end{tabular}
\label{tab:perf-comp-vary-N}

\end{table}




Sam
Do the minimum.

Obtain, Issue

Show, Verify









\section{Discussion}
\label{sec:threshold-discussion}

\subsection{Practical Deployment Considerations}
\begin{itemize}
    \item Standard threshold infrastructure compatible
    \item Efficient client-side operations for mobile deployment
    \item Flexible predicate system for diverse use cases
\end{itemize}

\subsection{Extensions and Future Work}
\begin{itemize}
    \item Post-quantum security considerations
    \item Dynamic threshold adjustments
    \item Integration with existing identity infrastructure
\end{itemize}

\section{Conclusion}
\label{sec:threshold-conclusion}

We presented the first threshold identity system that efficiently combines sybil resistance, expressive proofs, and revocation capabilities. By leveraging our efficient building blocks from previous chapters, we achieve 2-3× better performance than state-of-the-art systems while supporting strictly more functionality. Our system demonstrates that practical, privacy-preserving decentralized identity is achievable with proper cryptographic design.














\section{Threshold Credential Comparison}




\section{Identity System}

\begin{table}[h]
\centering
\caption{System Comparison Summary}
\begin{tabular}{lccc}
\toprule
\textbf{Feature/Operation} & \textbf{Our System} & \textbf{S3ID} & \textbf{Advantage} \\
\midrule
Threshold Credential & PS-UTT & TACT & 5-10× faster verify \\
Deduplication & Nullifier+ZKP & EDDX & ~5× faster \\
Expressive Proofs & Yes (Ch. 2) & Limited & Richer functionality \\
Token Request & 1.67-3.08ms & 8.33-16.58ms & 5× faster \\
Prove+Verify & <3ms & >20ms & >7× faster \\
\bottomrule
\end{tabular}
\end{table}
