\mychapter{Credential Relationship Binding Nullifier}

\section{Introduction}

In Chapters 2 and 3, we developed a robust foundation for anonymous credentials, evolving from single-issuer Attribute-Based Anonymous Credentials $(\ABC)$ to the Multi-Issuer Multi-Credential ABC $(\MIMCABC)$ system with identity binding security. $\MIMCABC$ enables users to privately prove that credentials from multiple, mutually distrusting issuers belong to the same identity, a significant advance for applications like federated identity proofs or content credentialing. However, real-world identity systems impose additional requirements that $\MIMCABC$ does not fully address: hierarchical structure and sybil resistance for context-specific credentials.

In practice, credentials often form a natural hierarchy, with foundational identities—such as government-issued IDs or passports—serving as Master Credentials, and dependent credentials—like driver’s licenses, professional certificates, or access rights—acting as Context Credentials. This structure enables efficient revocation: invalidating a Master Credential (e.g., upon employment termination) implicitly revokes all dependent Context Credentials, avoiding the need to track and revoke each individually. Furthermore, regulatory frameworks like KYC/AML demand accountability, requiring systems to prevent sybil attacks where users illegitimately obtain multiple credentials for the same context (e.g., multiple driver’s licenses). 

While MIMC-ABC ensures credentials share a single identity, it lacks mechanisms to enforce this hierarchical dependency or prevent sybil attacks in a privacy-preserving manner, as its identity binding operates agnostically across all credentials without distinguishing their roles or contexts. To meet these practical and regulatory needs, we must extend MIMC-ABC with a cryptographic framework that organizes credentials hierarchically and ensures context-specific uniqueness, all while preserving user anonymity and computational efficiency


\subsection{Problem Statement}

We want to improve MIMC-ABC for real-world use. Our goal is a private credential hierarchy with Sybil resistance. A user has a Master Credential with a secret key $\k$. They also have Context Credentials with unique IDs $\ctx$ (e.g., $\mathcal{H}(\text{"DriverLicense"})$). We need a mechanism that:
\begin{enumerate}
    \item Links each Context Credential to the Master Credential. It uses a unique nullifier $\nul$ from committed values $\k$ and $\ctx$ from different commitments.
    \item Prevents sybil attacks. It prevents multiple nullifiers for the same $(k, \ctx)$ pair.
    \item Verifies nullifier correctness in zero-knowledge. It hides $\k$ and $\ctx$.
\end{enumerate}


Our main challenge is:
\begin{center}
\emph{How do we efficiently generate a verifiable nullifier that proves the binding relationship between two separate credentials without leaking any additional information}
\end{center}


\subsection{Background Work}

Past works tackled hierarchy and sybil resistance in credential systems. None fully balances privacy, efficiency, and flexibility. 
\begin{enumerate}
    \item The UTT anonymous payment system ~\cite{tomescu2022utt} is the closest work, using a registration credential (like a Master Credential) and the coins are also credentials using serial numbers (like Context Credentials) where a coin can only be spent once. UTT uses pairings in their pseudorandom function which we benchmark against and show our speedup.

    \item CanDID~\cite{maram2021candid} defines Master and Context Credentials clearly, but has weakened privacy. It uses mappings between credential public keys in a table, breaking unlinkability. It also relies on an MPC-based PRF for sybil resistance. This adds complexity and overhead, unfit for lightweight use.

    \item Other pairing-based systems, like SyRA~\cite{crites_syra_2024} and S3ID~\cite{rabaninejad_attribute-based_2024}, offer private hierarchies. Yet, they suffer from pairing-related efficiency issues and slower zero-knowledge proofs where we use $\Sigma$-protocols, which are the most efficient zero-knowledge proofs.

    \item Standard Verifiable Random Functions  (VRFs)~\cite{hutchison_verifiable_2005} reveal the user’s public key during verification impacting anonymity and furthermore are constructed with bilinear pairings.

\end{enumerate}

Our MIMC-ABC system (Chapter 3) binds identities efficiently and anonymously but without hierarchy and context-specific sybil resistance. We need a solution that keeps MIMC-ABC’s strengths. It must add a light, private way to handle credential hierarchies and sybil resistance.




\subsection{Contributions}

We advance anonymous credential systems by developing a lightweight, pairing-free Verifiable Random Function (VRF) construction optimized for our use-case of hierarchical credential binding and sybil resistance. Our contributions are threefold:

\begin{enumerate}
        \item \textbf{Pairing-Free VRF in Prime-Order Groups:} We adapt the Dodis-Yampolskiy VRF structure for standard prime-order groups by replacing the proof mechnaism and prove our construction retains the security properties - \emph{pseudorandomness, uniqueness, verifiability} - under the $q$-DHI assumption. (We show the efficiency speedup of this change)

        \item \textbf{Novel $\Sigma$-protocol for Inverse Exponents} We develop a novel zero-knowledge proof protocol to prove knowledge of an inverse exponent We use this protocol to prove the correctness of the $q$-DDHI structure used in our Pairing-Free DY VRF VRF, the technique is a new general technique for $\Sigma$-protocols.
        
        \item \textbf{Credential Relationship Binding Nullifier } We combine our efficient Dodis-Yampolskiy VRF for standard prime-order groups with our Novel $\Sigma$-protocol for multiplicative inverse in addition to a $\Sigma$-proof of additive relation between discrete logarithms to compute our nullifier and show it's 33\% faster for evaluation and 60\% faster for verification than previous constructions while retaining security properties.

\end{enumerate}


\subsection{System Benefits}
Leveraging our technical contributions, the Credential Relationship Binding Nullifier (CRBN) extends the MIMC-ABC system into a complete identity framework with the following benefits:

\begin{enumerate}
    \item Cryptographically binds master credentials (containing key $\k$) to context credentials (with context identifiers $\ctx$) via a verifiable nullifier enabling accountability
    
    \item Enforces sybil resistance for context credentials while retaining privacy by using committed attributes and zero-knowledge proofs
    
    \item Integrates with the efficient $\Sigma$-protocols used throughout the credential system
\end{enumerate}

\subsection*{Chapter Organization}
The remainder of this chapter is organized as follows: Section 4.3 introduces our pairing-free VRF construction in prime-order groups. Section 4.4 presents our zero-knowledge proof protocol for multiplicative inverse relationships. Section 4.5 combines these components to construct the complete Credential Relationship Binding Nullifier (CRBN) system and demonstrates its integration with our identity framework. Finally, Section 4.6 provides a comprehensive performance evaluation comparing our approach to existing techniques.













\section{Preliminaries}
\subsection{Cryptographic Assumptions}

\begin{definition}[q-DDHI Assumption]
Let $\mathbb{G}$ be a cyclic group of prime order $p$ with generator $g$. The $q$-Decisional-Diffie-Hellman Inversion ($q$-DDHI) assumption\cite{mitsunari_new_2002} states that for any PPT adversary $\mathcal{A}$, there exists a negligible function $\negl$ such that:
\[
\Pr\left[ x \sample \Zp^*, \quad \mathcal{A}(g, g^x, g^{x^2}, \ldots, g^{x^q}) = g^{1/x} \right] \leq \negl(\lambda)
\]
where the probability is taken over the random choice of $x$ and the random coins of $\mathcal{A}$. Informally, no $\PPT$ adversary can distinguish between $g^{1/\alpha}$ from a random group element.
\end{definition}

\begin{remark}
The $q$-DDHI assumption is equivalent to the $(q+1)$-generalized Diffie-Hellman assumption (GDH) as shown by Boneh and Boyen \cite{kanade_efficient_2004}. This equivalence provides a solid theoretical foundation for the security of our VRF construction.
\end{remark}

\begin{definition}[$q$-DBDHI Assumption]
Let $\mathbb{G}$ and $\mathbb{G}_T$ be cyclic groups of prime order $p$ with a bilinear pairing $e: \mathbb{G} \times \mathbb{G} \times \G_2 \to \mathbb{G}_T$, and let $g$ be a generator of $\mathbb{G}$. The $q$-Decisional-Bilinear Diffie-Hellman Inversion ( $q$-DBDHI) assumption states that for any probabilistic polynomial-time (PPT) adversary $\mathcal{A}$, there exists a negligible function $\negl$ such that:
\[
\left| \Pr\left[ x \stackrel{\$}{\leftarrow} \mathbb{Z}_p^*, \, \mathcal{A}(g, g^x, g^{x^2}, \ldots, g^{x^q}, e(g, g)^{1/x}) = 1 \right] - \Pr\left[ x \stackrel{\$}{\leftarrow} \mathbb{Z}_p^*, \, r \stackrel{\$}{\leftarrow} \mathbb{G}_T, \, \mathcal{A}(g, g^x, g^{x^2}, \ldots, g^{x^q}, r) = 1 \right] \right| \leq \negl
\]
where the probabilities are taken over the random choices of $x \in \mathbb{Z}_p^*$, $r \in \mathbb{G}_T$, and the random coins of $\mathcal{A}$. In other words, no PPT adversary can distinguish between $e(g, g)^{1/x}$ and a random element $r$ in $\mathbb{G}_T$ given the tuple $(g, g^x, g^{x^2}, \ldots, g^{x^q})$.
\end{definition}



\subsection{Building Blocks}
We use the Pedersen Commitments from chapter 2, committing to a vector of messages $\cm = \CMCom([\id, \ctx, \exp, \k];\usk) = g_1^\id g_2^\ctx g_3^\exp g_4^\k g^\usk$. Pedersen Commitments are hiding, binding, and position-binding which enforces their position in the vector of messages such that the exponent at one position can't be swapped with another position. 






\begin{definition}[Verifiable Random Function]
We use the definition by \cite{bitansky_verifiable_2020} A Verifiable Random Function (VRF) is a tuple of probabilistic polynomial-time algorithms $(\VRFGen, \VRFEval, \VRFProve, \VRFVerify)$ with an associated message space $\mathcal{X}$, output space $\mathcal{Y}$ and proof space $\Pi$ defined as:
\begin{itemize}
    \item $\VRFGen(1^\lambda) \to (sk, pk)$: Takes a security parameter $\lambda$ and outputs a secret key $sk$ and a public key $pk$.
    
    \item $\VRFEval(sk,x) \to y$: On input $x \in \mathcal{X}$ and secret key $sk$, outputs a value $y \in \mathcal{Y}$.
    
    \item $\VRFProve(sk,x) \to \pi$: On input $x \in \mathcal{X}$ and secret key $sk$, produces a proof $\pi$ that $y$ is consistent with the public key $pk$.
    
    \item $\VRFVerify(pk,x, y, \pi) \to \{0,1\}$: Using the public key $pk$, verifies that $y$ is the correct output for input $x$ with proof $\pi$, returning 1 if valid, 0 otherwise.
\end{itemize}
    
\end{definition}

A $\mathrm{VRF}$ must satisfy three properties:
\begin{itemize}
    \item \textbf{Completeness:} For every security parameter $\lambda \in \mathbb{N}$ and input $x \in \{0,1\}^{n(\lambda)}$:
    \[
    \Pr\left[ \VRFVerify(pk,x, y, \pi) = 1 \ \middle| \ 
    \begin{array}{l}
        (sk, pk) \leftarrow \VRFGen(1^\lambda) \\
        y = \VRFEval(sk,x) \\
        \pi \leftarrow \VRFProve(sk,x)
    \end{array}
    \right] = 1
    \]
    
    \item \textbf{Uniqueness:} For every security parameter $\lambda \in \mathbb{N}$, input $x \in \{0,1\}^{n(\lambda)}$, and arbitrary public key $pk^* \in \{0,1\}^{k(\lambda)}$, there exists at most a single $y \in \{0,1\}^{m(\lambda)}$ for which there exists an accepting proof $\pi$. That is,
    \[
    \text{if} \quad \VRFVerify(pk^*, \pi_0, x, y_0) = \VRFVerify(pk^*, \pi_1, x, y_1) = 1 \quad \text{then} \quad y_0 = y_1
    \]
    
    \item \textbf{Adaptive Indistinguishability:} For any adversary $\mathcal{A}(1^\lambda)$, consider the following game $\mathcal{G}_{\mathcal{A}}^{\text{vrf}}$:
    \begin{enumerate}
        \item The VRF challenger samples $(sk, pk) \leftarrow \VRFGen(1^\lambda)$, and sends $pk$ to $\mathcal{A}$.
        \item $\mathcal{A}$ submits to a challenger evaluation queries $x_1, \ldots, x_Q$, and gets back from the challenger $(y_i, \pi_i), \ldots, (y_Q, \pi_Q)$, where $y_i = \VRFEval(sk, x_i)$, $\pi_i \leftarrow \VRFProve(x_i, sk)$.
        \item At any point, including between evaluation queries, $\mathcal{A}$ may submit a challenge input $x_* \in \{0,1\}^{n(\lambda)}$. The challenger then sets $y_0^* = \VRFEval(sk, x_*)$, $y_1^* \leftarrow \{0,1\}^{m(\lambda)}$, samples $b \leftarrow \{0,1\}$, and sends $y_b^*$ to $\mathcal{A}$. (The adversary $\mathcal{A}$ may then make additional evaluation queries.)
        \item At the end, $\mathcal{A}$ outputs a guess $b'$. The result of the game $\mathcal{G}_{\mathcal{A}}^{\text{vrf}}(\lambda)$ is 1 if $b' = b$, and 0 otherwise.
    \end{enumerate}
    
    We say that $\mathcal{A}$ is \textit{admissible} if in the above game it is always the case that $x_* \not\in \{x_i | i \in [Q]\}$. We require that any polynomial-size admissible adversary wins the game with negligible advantage:
    \[
    \text{Adv}_{\mathcal{A}}^{\text{vrf}} := \left|\Pr\left[\mathcal{G}_{\mathcal{A}}^{\text{vrf}}(\lambda) = 1\right] - \frac{1}{2}\right| \leq \text{negl}(\lambda)
    \]
    
    We say that the VRF satisfies \textit{Selective Indistinguishability} (rather than adaptive) if $\mathcal{A}$ submits the challenge query $x_*$ at the beginning of the game, before getting $pk$ and making any evaluation query.
\end{itemize}

\subsubsection{Zero-Knowledge Proofs}
A zero-knowledge proof (ZKP) enables a prover $\mathcal{P}$ to convince a verifier $\mathcal{V}$ that a statement $x \in L$ holds for a language $L$, without revealing any witness $w$. Formally, an interactive proof system $(\mathcal{P}, \mathcal{V})$ for $L$ satisfies:
\begin{itemize}
    \item \textbf{Completeness}: If $x \in L$, then $\Pr[(\mathcal{P}(w), \mathcal{V})(x) = 1] \geq 1 - \negl(\lambda)$.
    \item \textbf{Soundness}: If $x \notin L$, then for any $\mathcal{P}^*$, $\Pr[(\mathcal{P}^*, \mathcal{V})(x) = 1] \leq \negl(\lambda)$.
    \item \textbf{Zero-Knowledge}: There exists a simulator $\mathcal{S}$ such that for all $x \in L$, the view of any $\mathcal{V}^*$ is computationally indistinguishable from $\mathcal{S}(x)$.
\end{itemize}


\subsubsection{Sigma-Protocols}
A Sigma-protocol is a three-move ZKP where: (1) $\mathcal{P}$ sends a commitment $a$, (2) $\mathcal{V}$ sends a random challenge $e$, and (3) $\mathcal{P}$ responds with $z$. It satisfies:
\begin{itemize}
    \item \textbf{Completeness}: Honest execution accepts with probability 1.
    \item \textbf{Special Soundness}: From two accepting transcripts $(a, e, z)$ and $(a, e', z')$ with $e \neq e'$, a witness $w$ can be extracted.
    \item \textbf{Special Honest-Verifier Zero-Knowledge (SHVZK)}: A simulator can generate transcripts $(a, e, z)$ indistinguishable from real ones for any $e$.
\end{itemize}





\section{Technical Journey and Contributions}


\begin{table}
    \centering
    \begin{tabular}{cccccc}
       Scheme  & VRF?     & No Pairings  & 2 Exponents (x + sk)  & Private pk & Private (x) \\
       DY      & Yes     & Yes           & Yes                   & No         & No \\
       PRF      & Yes     & Yes           & Yes                   & No         & No \\
       VOPRF      & Yes     & Yes           & Yes                   & No         & No \\
       Sec 2   & No     & No            & Yes                   & No         & No \\
       Sec 3   & No     & Yes           & No                    & Yes        & No \\
       Sec 4   & Yes     & Yes           & Yes                   & Yes        & Yes\\
    \end{tabular}
    \caption{Caption}
    \label{tab:my_label}
\end{table}

\subsection{Motivation and Design Approach}
Verifiable Random Functions (VRFs) provide verifiable, deterministic, pseudorandom outputs. The Dodis-Yampolskiy (DY) VRF \cite{hutchison_verifiable_2005} is particularly well-suited for our credential binding application due to its output formation $y = e(g,\tilde{g})^{1/(sk+x)}$. As bilinear pairings add overhead to verification  6ms on modern hardware \cite{polgar_anonymous_2025}, we aim to remove pairings and retain security properties. 

\section{Dodis-Yampolskiy VRF: Core Structure and Security Properties}

The Dodis-Yampolskiy VRF~\cite{hutchison_verifiable_2005} operates in a bilinear group setting with prime-order groups $\mathbb{G}_1$, $\mathbb{G}_2$, and $\mathbb{G}_T$, with a Type-3 pairing $e: \mathbb{G}_1 \times \mathbb{G}_2 \rightarrow \mathbb{G}_T$. Let $g \in \mathbb{G}_1$ and $\tilde{g} \in \mathbb{G}_2$ be generators. The construction is as follows:

\begin{itemize}
    \item $\mathsf{VRF.Gen}(1^\lambda) \to (sk, pk)$: Sample $sk \sample \mathbb{Z}_p^*$, compute $pk = g^{sk} \in \mathbb{G}_1$. Output $(sk, pk)$.
    
    \item $\mathsf{VRF.Eval}(sk, x) \to y$: Compute $y = e(g, \tilde{g})^{1/(sk + x)} \in \mathbb{G}_T$.
    
    \item $\mathsf{VRF.Prove}(sk, x) \to \pi$: Compute proof $\pi = \tilde{g}^{1/(sk + x)} \in \mathbb{G}_2$.
    
    \item $\mathsf{VRF.Vfy}(pk, x, y, \pi) \to \{0, 1\}$: Verify two equations:
    \begin{align}
        e(g^{x} \cdot pk, \pi) &\stackrel{?}{=} e(g, \tilde{g}) \quad \text{(Equation 1)}\\
        y &\stackrel{?}{=} e(g, \pi) \quad \text{(Equation 2)}
    \end{align}
\end{itemize}

The security of this VRF rests upon the $q$-Decisional Bilinear Diffie-Hellman Inversion ($q$-DBDHI) assumption, which states that given $(g, g^{sk}, g^{(sk)^2}, \ldots, g^{(sk)^q})$ and $\tilde{g}$, the value $e(g, \tilde{g})^{1/(sk+x)}$ is computationally indistinguishable from a random element in $\mathbb{G}_T$.

\subsubsection{Analysis of Security Properties}

To understand the security of the Dodis-Yampolskiy VRF, we analyze how its construction achieves the three essential VRF properties:

\paragraph{Pseudorandomness}
The VRF output $y = e(g, \tilde{g})^{1/(sk + x)} \in \mathbb{G}_T$ appears random based on the $q$-DBDHI assumption.

\paragraph{Uniqueness}
Information-theoretic uniqueness is enforced by the algebraic properties of the pairing. 
Verification Equation 1 enforces that only one valid proof $\pi$ can exist for each input, which in turn determines a unique output $y$ through Equation 2. The first equation verifies the algebraic relationship $y^{sk+x} = e(g, \tilde{g})$ without revealing $sk$:
\begin{align}
    e(g^{x} \cdot pk, \pi) &= e(g^{x} \cdot g^{sk}, \tilde{g}^{1/(sk + x)}) \\
    &= e(g^{sk + x}, \tilde{g}^{1/(sk + x)}) \\
    &= e(g, \tilde{g})^{(sk + x) \cdot 1/(sk + x)} \\
    &= e(g, \tilde{g})
\end{align}

This uniqueness guarantee is crucial: for each $(sk,x)$ pair, only one value $\pi = \tilde{g}^{1/(sk+x)}$ can satisfy Equation 1. Consequently, only one output value $y = e(g, \pi) = e(g, \tilde{g})^{1/(sk+x)}$ can satisfy Equation 2.

\paragraph{Correctness}
The combination of both verification equations ensures that honestly generated outputs and proofs will always verify:

1. Equation 1 ensures proof correctness by verifying that $\pi = \tilde{g}^{1/(sk+x)}$.

2. Equation 2 ensures output consistency:
\begin{align}
    y &= e(g, \tilde{g})^{1/(sk + x)} \\
    &= e(g, \tilde{g}^{1/(sk + x)}) \\
    &= e(g, \pi)
\end{align}

Together, these equations guarantee that an honest evaluator with knowledge of $sk$ will always produce outputs and proofs that pass verification.

\subsubsection{Role of Pairings in the Construction}

The pairing operations in the Dodis-Yampolskiy VRF serve a critical verification role. Specifically:

\begin{itemize}
    \item The pairing allows verification of the inverse exponent relationship: given $g^{sk+x}$ and $\tilde{g}^{1/(sk+x)}$, the pairing enables efficient verification of their mathematical relationship without knowing $sk$
    
    \item Without pairings, verifying that an element equals $g^{1/(sk+x)}$ given only $g^{sk+x}$ would be computationally infeasible
    
    \item The bilinear property bridges the gap between regular exponentiation and inverse exponentiation, which is fundamental to the VRF's security
\end{itemize}

However, these pairings introduce significant computational overhead. A bilinear pairing operation typically requires 5-10$\times$ more computational resources than standard group operations. This leads to an important question: Can we achieve the same security properties without relying on expensive pairing operations?

\subsubsection{Essential Requirements for Transformation}

Based on our analysis, any transformation of the Dodis-Yampolskiy VRF must preserve:

\begin{enumerate}
    \item The output structure involving the inverse exponent $1/(sk+x)$ to maintain pseudorandomness under an appropriate hardness assumption
    
    \item A verification mechanism that confirms the relationship between $sk+x$ and $1/(sk+x)$ without revealing $sk$
    
    \item A means to verify consistency between the output and proof
\end{enumerate}

In the next section, we introduce our pairing-free VRF construction that maintains these essential properties while eliminating the need for bilinear pairings.

% The pairing operation is critical here - it allows verification of inverse exponent relationships that would otherwise be difficult to prove non-interactively without revealing the secret key.
% Changing the pseudorandomness assumption from q-DBDHI to q-DDHI
% Changing the nature of the uniqueness guarantee from information-theoretic to computational






\section{Step 1. Efficient, Verifiable Pseudorandomness. VRF in Prime-Order Group}
we're making two changes to the security model:
Changing the pseudorandomness assumption from q-DBDHI to q-DDHI
Changing the nature of the uniqueness guarantee from information-theoretic to computational

Our VRF operates in a prime-order group $\mathbb{G}$ of order $p$ with generator $g$. Define the message space $\setX = \mathbb{Z}_p$, output space $\setY = \mathbb{G}$, and proof space $\Pi = \mathbb{G} \times \mathbb{G} \times \mathbb{Z}_p$. 


Challenges

Speak about why the naive method creates a VUF and not a VRF. Explain why we need to add a sigma protocol



- mention the benefit of the pairing here - it effectively multiplies the two together which isn't possible with standard group elements - that's the challenge we had to get through.



\begin{itemize}
    \item $\mathsf{VRF.Gen}(1^\lambda) \to (sk, pk)$: Sample $sk \sample \mathbb{Z}_p^*$. compute $pk = g^{sk}$, and output $(sk, pk)$.
    
    \item $\mathsf{VRF.Eval}(sk, x) \to y$: Compute $g^{1/(sk + x)} \in \mathbb{G}$.
    
    \item $\mathsf{VRF.Prove}(sk, x) \to \pi$: Compute proof $\pi$ using the $\Sigma$-protocol described below.
    
    \item $\mathsf{VRF.Verify}(y, \pi) \to \{0, 1\}$: Verify $y$ is correctly formed $\ZKVerify(\pi, y, x, pk) = 1$ for success, 0 for failure.
    % Verify two equations:
    % \begin{align}
    %     e(g^{x} \cdot pk, \pi) &\stackrel{?}{=} e(g, \tilde{g}) \quad \text{(Equation 1)}\\
    %     y &\stackrel{?}{=} e(g, \pi) \quad \text{(Equation 2)}
    % \end{align}
\end{itemize}


\subsection{Proof Protocol}
To prove that $y = g^{1/(sk+x)}$ without revealing $sk$, we use a $\Sigma$-protocol that demonstrates knowledge of $sk$ such that $pk = g^{sk}$ and $y^{sk+x} = g$. The protocol operates as follows:


INSERT PROOF PROTOCOL FOR PRIME ORDER GROUP




\subsection{Security Analysis}

Our pairing-free VRF construction in prime-order groups preserves all three essential VRF properties—correctness, uniqueness, and pseudorandomness—while eliminating the computational overhead of bilinear pairings found in the original Dodis-Yampolskiy VRF.

\subsubsection{Comparison to Dodis-Yampolskiy VRF}
The Dodis-Yampolskiy VRF also evaluates $y = g^{1/(sk + x)}$, but relies on a bilinear group for verification, using a pairing check: $e(y, pk \cdot g^x) = e(g, g)$. Our construction operates entirely in a standard prime-order group, replacing the pairing verification with an efficient $\Sigma$-protocol that proves the algebraic relation $y^{sk+x} = g$. This substitution preserves all security guarantees while significantly reducing computational costs.

\subsubsection{Correctness}
An honest prover computing $y = g^{1/(sk+x)}$ can always convince the verifier by executing the $\Sigma$-protocol. Let $pk = g^{sk}$ be the public key. For commitment values $T_1 = g^r$ and $T_2 = y^r$, and response $z = r + c(sk+x)$, verification succeeds because:

\begin{align}
g^z &= g^{r + c(sk+x)} = g^r \cdot g^{c(sk+x)} = g^r \cdot (g^{sk} \cdot g^x)^c = g^r \cdot (pk \cdot g^x)^c = T_1 \cdot (pk \cdot g^x)^c \\
y^z &= y^{r + c(sk+x)} = y^r \cdot y^{c(sk+x)} = y^r \cdot (y^{sk+x})^c = y^r \cdot g^c = T_2 \cdot g^c
\end{align}

This demonstrates that honest execution of our protocol always results in successful verification, satisfying the VRF correctness property.



\subsubsection{Uniqueness}
The uniqueness property requires that for any input $x$ and public key $pk$, at most one output $y$ can be verified. Our construction satisfies computational uniqueness based on the hardness of the discrete logarithm problem in a prime-order group $\mathbb{G}$.

For any valid output $y$, the verification equations ensure that $y^{sk+x} = g$, which has exactly one solution: $y = g^{1/(sk+x)}$. Suppose an adversary produces a different valid output $y' \neq y$ with a valid proof $\pi'$. Then:

\begin{enumerate}
    \item $y'^{sk+x} = g$ (from verification of $y'$)
    \item $y^{sk+x} = g$ (from honest evaluation)
\end{enumerate}

This implies $(y')^{sk+x} = y^{sk+x}$, so $(y'/y)^{sk+x} = 1$. Since $\mathbb{G}$ is a prime-order group, if $y' \neq y$, then $y'/y = g^k$ for some $k \neq 0$. Thus, $y' = y \cdot g^k$. However, for $y'$ to be valid, it must satisfy $y'^{sk+x} = (y \cdot g^k)^{sk+x} = y^{sk+x} \cdot g^{k(sk+x)} = g$, which requires $g^{k(sk+x)} = 1$. Since $k \neq 0$ and $\mathbb{G}$ has prime order, this holds only if $sk + x = 0 \pmod{p}$, where $p$ is the group order—an event with negligible probability for random $sk$ and $x$. Alternatively, finding a different $sk'$ such that $pk = g^{sk'}$ and $y'^{sk'+x} = g$ contradicts the discrete logarithm assumption unless $sk' = sk$.

Thus, producing a distinct $y'$ with a valid proof is infeasible, ensuring uniqueness.

\subsubsection{Pseudorandomness}
The pseudorandomness property requires that VRF outputs appear random to any observer without knowledge of $sk$, even after seeing other input-output pairs. Our construction inherits this property from the algebraic structure of the output $y = g^{1/(sk+x)}$.

Under the $q$-DDHI (Decisional Diffie-Hellman Inversion) assumption, given $(g, g^{sk}, g^{(sk)^2}, ..., g^{(sk)^q})$ for any polynomial $q$, the value $g^{1/(sk+x)}$ is computationally indistinguishable from a random group element in $\mathbb{G}$ for any $x$ not previously queried. This assumption directly supports the pseudorandomness required by VRFs.

The $\Sigma$-protocol's zero-knowledge property ensures that proofs reveal no additional information about $sk$ beyond what is available from $pk = g^{sk}$, preserving the indistinguishability of $y$ from a random element. A formal reduction demonstrates that any adversary breaking pseudorandomness can be transformed into one that distinguishes $g^{1/(sk+x)}$ from a random group element, contradicting the $q$-DDHI assumption.

In the reduction, the challenger, given a $q$-DDHI instance, simulates VRF evaluations and proofs for up to $q$ distinct inputs using the provided powers of $sk$. For a challenge input $x^*$ (distinct from prior queries), the challenger provides either the real VRF output $g^{1/(sk+x^*)}$ or a random group element. If the adversary distinguishes these with non-negligible advantage, it solves the $q$-DDHI problem, which is assumed hard.





















\section{Step 2. Privacy}
Our VRF builds upon the $q$-DDHI assumption and this is where we start our zero knowledge proof protocol. Specifically, we want to prove (in zero knowledge) that we know $\alpha$ such that $g^{1/\alpha}$ 

Let $G$ be a cyclic group of prime order $q$, with generators $g_1, g \in G$. Assume the discrete logarithm problem (DLP) is hard in $G$, and the discrete log of $g_1$ with respect to $g$ is unknown.
The prover aims to prove in zero-knowledge that there exists $m \in \mathbb{Z}_q^*$ such that $\alpha \cdot \beta = 1 \mod q$, where $\beta = \frac{1}{\alpha}$, given commitments to $\alpha$ and $\beta$.

Challenges
Sigma protocols prove knowledge of exponents, proving knowledge of an inverse exponent. 

INSERT PROOF PROTOCOL FOR DDHI Challenge

\subsubsection*{Completeness}:
We show that if the prover follows the protocol honestly, all verification equations will be satisfied.

\begin{enumerate}
    \item The first two verification equations ($T_1 \cdot \cm_1^c \stackrel{?}{=} g_1^{z_\alpha} g^{z_{\usk_1}}$, $T_2 \cdot \cm_2^c \stackrel{?}{=} g_1^{z_\beta} g^{z_{\usk_2}}$) are simple Schnorr proofs of exponents which we will not expand 
        
    \item Third verification equation: $T_3 \cdot \cm_3^c \stackrel{?}{=} \cm_2^{z_\alpha} g^{z_{\usk_3}}$
    \begin{align*}
        T_3 \cdot \cm_3^c &= \cm_2^{a_\alpha} g^{a_{\usk_3}} \cdot (\cm_2^\alpha g^{\usk_3})^c \\
        &= \cm_2^{a_\alpha} g^{a_{\usk_3}} \cdot \cm_2^{\alpha \cdot c} g^{\usk_3 \cdot c} \\
        &= \cm_2^{a_\alpha + \alpha \cdot c} g^{a_{\usk_3} + \usk_3 \cdot c} \\
        &= \cm_2^{z_\alpha} g^{z_{\usk_3}}
    \end{align*}
    
    \item Fourth verification equation: $T_4 \cdot \cm_4^c \stackrel{?}{=} g^{z_{\usk_4}}$
    \begin{align*}
        T_4 \cdot \cm_4^c &= g^{a_{\usk_4}} \cdot (g^{\usk_4})^c \\
        &= g^{a_{\usk_4}} \cdot g^{\usk_4 \cdot c} \\
        &= g^{a_{\usk_4} + \usk_4 \cdot c} \\
        &= g^{z_{\usk_4}}
    \end{align*}
    
    \item Fifth verification equation: $\frac{\cm_3}{\cm_4} \stackrel{?}{=} g_1$
    
    Using the relations $\beta = \frac{1}{\alpha}$ and $\usk_4 = \usk_3 + \alpha \cdot \usk_2$:
    \begin{align*}
        \cm_3 &= \cm_2^\alpha g^{\usk_3} \\
        &= (g_1^\beta g^{\usk_2})^\alpha g^{\usk_3} \\
        &= g_1^{\beta \cdot \alpha} g^{\usk_2 \cdot \alpha} g^{\usk_3} \\
        &= g_1^{\frac{1}{\alpha} \cdot \alpha} g^{\usk_2 \cdot \alpha + \usk_3} \\
        &= g_1 g^{\usk_3 + \alpha \cdot \usk_2} \\
        &= g_1 g^{\usk_4} \\
        &= g_1 \cdot \cm_4
    \end{align*}
    
    Therefore:
    \begin{align*}
        \frac{\cm_3}{\cm_4} = \frac{g_1 \cdot \cm_4}{\cm_4} = g_1
    \end{align*}
\end{enumerate}

Since all verification equations are satisfied when the prover follows the protocol, we conclude that our sigma protocol satisfies the completeness property.


\subsubsection*{Soundness}
We prove the special soundness property by demonstrating that given two accepting transcripts with identical first messages but different challenges, we can extract a valid witness satisfying all relations required by the protocol.

Let $(T_1, T_2, T_3, T_4, c, z_\alpha, z_\beta, z_{\usk_1}, z_{\usk_2}, z_{\usk_3}, z_{\usk_4})$ and $(T_1, T_2, T_3, T_4, c', z'_\alpha, z'_\beta, z'_{\usk_1}, z'_{\usk_2}, z'_{\usk_3}, z'_{\usk_4})$ be two accepting transcripts with $c \neq c'$.

\begin{enumerate}
    \item \textbf{Witness extraction:}
    
    Following the standard extraction technique for sigma protocols, we compute each witness component:
    \begin{align}
    \alpha &= \frac{z_\alpha - z'_\alpha}{c - c'} & x &= \frac{z_\beta - z'_\beta}{c - c'} \\
    \usk_1 &= \frac{z_{\usk_1} - z'_{\usk_1}}{c - c'} & \usk_2 &= \frac{z_{\usk_2} - z'_{\usk_2}}{c - c'} \\
    \usk_3 &= \frac{z_{\usk_3} - z'_{\usk_3}}{c - c'} & \usk_4 &= \frac{z_{\usk_4} - z'_{\usk_4}}{c - c'}
    \end{align}
    
    These extracted values are guaranteed to be consistent with the protocol's verification equations precisely because both transcripts are accepting.
    
    \item \textbf{Verification of commitment relations:}
    
    We first show that the extracted witness satisfies $\cm_1 = g_1^m g^{\usk_1}$. From the acceptance of both transcripts, we have:
    \begin{align}
        T_1 \cdot \cm_1^c &= g_1^{z_\alpha} g^{z_{\usk_1}} \\
        T_1 \cdot \cm_1^{c'} &= g_1^{z'_\alpha} g^{z'_{\usk_1}}
    \end{align}
    
    Dividing these equations and substituting our extracted values:
    \begin{align}
        \cm_1^{c-c'} &= g_1^{z_\alpha-z'_\alpha} g^{z_{\usk_1}-z'_{\usk_1}} \\
        &= g_1^{\alpha(c-c')} g^{\usk_1(c-c')} \\
        \Rightarrow \cm_1 &= g_1^\alpha g^{\usk_1}
    \end{align}
    
    Using identical extraction and verification techniques with the corresponding verification equations, we establish that:
    \begin{align}
        \cm_2 &= g_1^\beta g^{\usk_2} \\
        \cm_3 &= \cm_2^\alpha g^{\usk_3} \\
        \cm_4 &= g^{\usk_4}
    \end{align}
    
    \item \textbf{Verification of the multiplicative inverse relation ($\beta = \frac{1}{\alpha}$):}
    
    The core cryptographic property enforced by our protocol is the multiplicative inverse relationship between $m$ and $x$. This is where the protocol's security guarantee is ultimately derived from. We verify this relationship using the final verification equation $\frac{\cm_3}{\cm_4} = g_1$.
    
    Substituting our extracted witness values:
    \begin{align}
        \frac{\cm_3}{\cm_4} &= g_1 \\
        \frac{\cm_2^\alpha g^{\usk_3}}{g^{\usk_4}} &= g_1 \\
        \cm_2^\alpha g^{\usk_3 - \usk_4} &= g_1
    \end{align}
    
    Further substituting $\cm_2 = g_1^x g^{\usk_2}$:
    \begin{align}
        (g_1^x g^{\usk_2})^\alpha g^{\usk_3 - \usk_4} &= g_1 \\
        g_1^{x \cdot \alpha} g^{\alpha \cdot \usk_2 + \usk_3 - \usk_4} &= g_1
    \end{align}
    
    In the generic group model, this equation can only hold if:
    \begin{align}
        \beta \cdot \alpha &= 1 \\
        \alpha \cdot \usk_2 + \usk_3 - \usk_4 &= 0
    \end{align}
    
    These equations immediately give us the two critical relations:
    \begin{align}
        \beta &= \frac{1}{\alpha} \\
        \usk_4 &= \usk_3 + \alpha \usk_2
    \end{align}
    
    The first relation confirms that our protocol successfully enforces the multiplicative inverse relationship between $\alpha$ and $\beta$. The second relation verifies the consistency of the randomizers across the commitments, ensuring that no malicious prover can construct valid-looking commitments without knowing values that satisfy all required relations.
\end{enumerate}

We have thus demonstrated that our extractor obtains a complete and valid witness $(\alpha, \beta, \usk_1, \usk_2, \usk_3, \usk_4)$ satisfying all relations in the statement, establishing the special soundness property of our sigma protocol. This ensures that no prover can successfully convince a verifier without knowledge of values satisfying the multiplicative inverse relationship $\beta = \frac{1}{\alpha}$ and the associated consistency requirements.

\subsubsection*{Zero-Knowledge}
We prove the honest-verifier zero-knowledge property by presenting a simulator that produces transcripts indistinguishable from real protocol executions without knowing any witness.

\begin{enumerate}
    \item \textbf{Simulator Construction:}
    
    Given public input $(g_1, g, \cm_1, \cm_2, \cm_3, \cm_4)$ and any challenge $c \in \mathbb{Z}_q$, our simulator:
    
    \begin{itemize}
        \item Samples $z_\alpha, z_\beta, z_{\usk_1}, z_{\usk_2}, z_{\usk_3}, z_{\usk_4} \sample \mathbb{Z}_q$ uniformly at random
        
        \item Computes the first message by working backwards from the verification equations:
        \begin{align}
            T_1 &\gets g_1^{z_\alpha} g^{z_{\usk_1}} \cdot \cm_1^{-c} \\
            T_2 &\gets g_1^{z_\beta} g^{z_{\usk_2}} \cdot \cm_2^{-c} \\
            T_3 &\gets \cm_2^{z_\alpha} g^{z_{\usk_3}} \cdot \cm_3^{-c} \\
            T_4 &\gets g^{z_{\usk_4}} \cdot \cm_4^{-c}
        \end{align}
        
        \item Outputs the transcript $(T_1, T_2, T_3, T_4, c, z_\alpha, z_\beta, z_{\usk_1}, z_{\usk_2}, z_{\usk_3}, z_{\usk_4})$
    \end{itemize}
    
    \item \textbf{Perfect Indistinguishability:}
    
    In a real protocol execution with an honest prover, the responses have the form $z_\alpha = a_\alpha + c \cdot \alpha$ where $a_\alpha$ are uniformly random values. Since $a_\alpha \sample \mathbb{Z}_q$ and addition with $c \cdot \alpha$ is a permutation over $\mathbb{Z}_q$, the distribution of real responses is uniform over $\mathbb{Z}_q$.
    
    The simulator directly samples responses uniformly from $\mathbb{Z}_q$, matching this distribution exactly. Given these responses and the challenge $c$, the first message components $T_i$ are uniquely determined by the verification equations in both real and simulated cases.
    
    Consequently, the joint distribution of $(T_1, T_2, T_3, T_4, c, z_\alpha, z_\beta, z_{\usk_1}, z_{\usk_2}, z_{\usk_3}, z_{\usk_4})$ is identical for both the simulator and the honest protocol.
\end{enumerate}

This construction demonstrates that our protocol satisfies perfect honest-verifier zero-knowledge. Notably, the simulator succeeds without requiring knowledge of the critical multiplicative inverse relationship $\beta = \frac{1}{\alpha}$ or any other witness values, confirming that the protocol reveals no information about these secret values beyond what is already implied by the statement being proven.














\section{Pairing-Free VRF in Prime-Order Groups}

\subsection{From Pairings to Sigma Protocols: A Transformation}

The Dodis-Yampolskiy VRF \cite{hutchison_verifiable_2005} evaluates $y = g^{1/(sk+x)}$ and verifies correctness through a bilinear pairing check:
\begin{equation}
e(y, pk \cdot g^x) = e(g, g)
\end{equation}

This equation verifies that $y^{sk+x} = g$ without revealing $sk$, as we can expand:
\begin{align}
e(g^{1/(sk+x)}, g^{sk} \cdot g^x) &= e(g, g)\\
e(g^{1/(sk+x)}, g^{sk+x}) &= e(g, g)\\
e(g, g)^{1/(sk+x) \cdot (sk+x)} &= e(g, g)\\
e(g, g)^1 &= e(g, g)
\end{align}

Our key insight is that we can directly prove the relationship $y^{sk+x} = g$ using a $\Sigma$-protocol without relying on pairings. This provides the same security guarantees while significantly reducing computational costs, as pairing operations are typically 5-10× more expensive than standard group operations.

\subsection{Construction}
[Include your VRF construction as before]

\subsection{Proof Protocol}
Our $\Sigma$-protocol proves exactly the same relation that the pairing check verifies in Dodis-Yampolskiy: namely, that the prover knows $sk$ such that $pk = g^{sk}$ and $y^{sk+x} = g$.

[Include your protocol steps as before]

\subsection{Security Analysis}

\subsubsection{Equivalence to Dodis-Yampolskiy Verification}
We first establish that our verification mechanism is equivalent to the pairing-based check in Dodis-Yampolskiy. Both approaches verify that $y = g^{1/(sk+x)}$:

\begin{itemize}
    \item \textbf{Dodis-Yampolskiy}: Verifies through $e(y, pk \cdot g^x) = e(g, g)$, which holds if and only if $y = g^{1/(sk+x)}$.
    
    \item \textbf{Our approach}: The $\Sigma$-protocol verification equations $g^z = T_1 \cdot C^c$ and $y^z = T_2 \cdot g^c$ together ensure that $y^{sk+x} = g$, which holds if and only if $y = g^{1/(sk+x)}$.
\end{itemize}

This equivalence ensures that our construction preserves all security properties of the original VRF while eliminating pairing operations.

\subsubsection{$\Sigma$-Protocol Security}
Our protocol satisfies the three required properties of a secure $\Sigma$-protocol:

\textbf{Completeness:} An honest prover with knowledge of $sk$ always succeeds. For $z = r + c(sk+x)$:
\begin{align}
g^z &= g^{r + c(sk+x)} = g^r \cdot (g^{sk} \cdot g^x)^c = T_1 \cdot C^c\\
y^z &= y^{r + c(sk+x)} = y^r \cdot (y^{sk+x}) = y^r \cdot g = T_2 \cdot g^c
\end{align}

\textbf{Special Soundness:} Given two accepting transcripts $(T_1, T_2, c, z)$ and $(T_1, T_2, c', z')$ where $c \neq c'$, we can extract $sk$ as follows:
\begin{align}
g^z &= T_1 \cdot C^c \quad \text{and} \quad g^{z'} = T_1 \cdot C^{c'}\\
\Rightarrow g^{z-z'} &= C^{c-c'} = (pk \cdot g^x)^{c-c'}\\
\Rightarrow g^{z-z'} &= g^{(sk+x)(c-c')}\\
\Rightarrow z-z' &= (sk+x)(c-c')\\
\Rightarrow sk &= \frac{z-z'}{c-c'} - x
\end{align}

Thus, we can extract the secret key $sk$, confirming that the prover must know $sk$ to convince the verifier.

\textbf{Zero-Knowledge:} We can simulate accepting transcripts without knowing $sk$:
\begin{enumerate}
    \item Sample $z \sample \mathbb{Z}_p$ and $c \sample \mathbb{Z}_p$ uniformly
    \item Compute $T_1 = g^z \cdot (pk \cdot g^x)^{-c}$ and $T_2 = y^z \cdot g^{-c}$
    \item Output $(T_1, T_2, c, z)$
\end{enumerate}
This simulation is perfectly indistinguishable from real protocol transcripts.

\subsubsection{VRF Security Properties}
Building on this $\Sigma$-protocol foundation, our VRF preserves all three essential properties:

\textbf{Correctness:} [As before]

\textbf{Uniqueness:} [As before]

\textbf{Pseudorandomness:} The security reduction to the $q$-DHI assumption follows exactly as in Dodis-Yampolskiy. An adversary distinguishing VRF outputs from random would solve the $q$-DHI problem. Our verification mechanism reveals exactly the same information as the pairing check, maintaining the same pseudorandomness guarantee.

















\clearpage
OLD WORK AND NOTES


\subsection{Construction}
During verification, the user proves in zero-knowledge that they possess a valid master credential with VRF key $\k$, a context credential with a specific $\ctx$ value and the nullifier $\nul$ is correctly formed by using a secret $\k$ in $\credm$ and $\ctx$ in $\credc$. 

\begin{equation}
\nul = g^{1/(\k + \ctx)} \in \G
\end{equation}

\subsection{Integration with Identity System}


\begin{figure}
        \begin{pchstack}[boxed, center, space=4em]
            \begin{pcvstack}
                \procedure[space=auto]{Passport}{%
                \id: 12345, \\
                \ctx: "master", \\
                \exp: "10/11/2026" \\
                \k: 54321
                }
            \end{pcvstack}
            \pcvspace
            \begin{pcvstack}
                \procedure[space=auto]{Driver License}{%
                 \id: 12345, \\
                 \ctx: "DMV", \\
                 \exp: "10/11/2028"
                }
            \end{pcvstack}
            \begin{pcvstack}
                \procedure[space=auto]{Nullifier}{%
                 \textsf{n} = 1/(\k + "DMV") \\
                 \nul = g^{\textsf{n}}
                }
            \end{pcvstack}
        \end{pchstack}
    \caption{Example Credential and Nullifier for context DMV}
    \label{fig:two-creds}
\end{figure}


\[
    \mathcal{R}_{\mathsf{vrf}} = \zkpok \left\{ 
    \begin{array}{l} 
    (\cmm, \cmc, \mathsf{N}), (\id, \ctx, , \exp, \k, r_1, r_2) \\
    \end{array} 
    \middle|
    \begin{array}{l}
        \cmm = g_1^{\id}g_2^{\ctx}g_3^{\exp}g_4^{\k}g^{r_1}  \wedge \ctx="master" \\
        \cmc = g_1^{\id}g_2^{\ctx}g_3^{\exp}g^{r_2} \wedge \ctx="DMV" \\
        \nul = g^{1/(k + \ctx)}
    \end{array} 
    \right\}
\]
    



\subsection{Performance Analysis}
Benchmarks were performed on MacBook Air M2 16GB RAM using our Rust implementation with the arkworks library \cite{arkworks_contributors_arkworks_2022}. Compared to the state-of-the-art nullifier scheme from \cite{tomescu2022utt}, our scheme removes a pairing with a speedup of 33\% for VRF evaluation and 60\% for Verify.

\begin{table}[h!]
\centering
\label{tab:cred-rel-binding-nullifier-table}
\begin{tabular}{l@{\hspace{1.5em}}r@{\hspace{1.5em}}r@{\hspace{1.5em}}r}
\toprule
Operation & Pairing (ms) & Us (ms) & Our Speedup (\%)) \\
\midrule
Evaluate & 5.83 & 3.89 & 33.26 \\
Verify & 6.37 & 2.52 & 60.42 \\
\bottomrule
\end{tabular}
\caption{Credential Relationship Binding Nullifier Scheme Comparison}
\end{table}
\vspace{-1cm}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.75\linewidth]{figures/vrf-benchmark.png}
    \caption{VRF Benchmark}
    \label{fig:vrf-benchmark}
\end{figure}


Include benchmark of my construction on a different curve e.g. secpk251
Try to benchmark it against a VRF from the standardisation





% \begin{table}
% \begin{center}
% \caption{Comparison of our construction over previous work.}
% \label{tab:comparison-chap4}
% \begin{tabular}{l|ccccc}
% Features    									& 
% Sybil Resist.  & 
% Hierarchy & 
% Private & 
% Pairing-Free & 
% Predicate Proofs \\
% \hline
% CanDID \cite{maram2021candid}     				&
% \ding{51}     & 
% \ding{51} 	& 
% \ding{55}  &  
% -     & 
% \ding{55}		\\
% SyRA \cite{crites_syra_2024}     				& 
% \ding{51}    	& 
% \ding{51}     & 
% \ding{51}  &  
% \ding{51}     & 
% \ding{55}		\\
% S3ID \cite{rabaninejad_attribute-based_2024}  & 
% \ding{51}     & 
% \ding{51}    	& 
% \ding{55}  &  
% \ding{55}     & 
% \ding{55}		\\
% UTT               & 
% \ding{51}     & 
% \ding{51}    	& 
% \ding{51}  &  
% \ding{55}     & 
% \ding{51}		\\
% Chap3             & 
% \ding{55}     & 
% \ding{55}    	& 
% \ding{51}  &  
% \ding{55}     & 
% \ding{51}		\\
% Ours  										& 
% \ding{51}     & 
% \ding{51}    	& 
% \ding{51}  &  
% \ding{51}     & 
% \ding{51}		\\
% \end{tabular}
% \end{center}
% \vspace{1em}
% \footnotetext[1]{Predicate Proofs allow users to prove statements about their credentials privately}
% \footnotetext[2]{Efficient Token refers to optimization of token verification}
% \end{table}


\subsection*{Notation}
Inline with our Anonymous Credential scheme built and prior chapters, the secret key is $\k$, the VRF input is $\ctx$, the VRF output is $\nul$ and the proof $\pi$ proves the correctness of $\nul$ such that $(\nul, \pi) \gets \mathsf{VRF.Eval}(\k, \ctx)$. $\cm = \CMCom([\id,\ldots];\usk)$ is a commitment shorthand for commitment $g_1^\id \ldots g^\usk$. We use Type-3 Bilinear Pairings. Let $\G_1$, $\G_2$, and $\G_T$ be groups of prime order $p$, with generators $g \in \G_1$, $\tilde{g} \in \G_2$, and a bilinear map $e: \G_1 \times \G_2 \to \G_T$.


\section{On the possibility of Sigma protocols for VRF Construction}
Why $\Sigma$-Protocols Suit Our VRF Construction

In our Verifiable Random Function (VRF) construction, we employ a $\Sigma$-protocol to generate the proof $\pi$ for the output $y = f_{sk}(x)$, where $sk$ is the secret key and $x$ is the input. A potential concern is whether the zero-knowledge property of $\Sigma$-protocols, which allows proof simulation, compromises the \textbf{verifiable uniqueness} property of the VRF—i.e., the guarantee that only one $y$ can be verified for a given $x$. Here, we explain why this concern is unfounded and how $\Sigma$-protocols align with VRF security requirements.

A VRF must satisfy three core properties: \textbf{correctness}, \textbf{uniqueness}, and \textbf{pseudorandomness}. \textbf{Correctness} ensures that an honestly computed output $y = f_{sk}(x)$ and its proof $\pi$ will always pass verification. \textbf{Uniqueness} guarantees that for each $x$, only one $y$ can be successfully verified with a proof $\pi$. \textbf{Pseudorandomness} ensures that without $sk$, $y$ is indistinguishable from random, even after seeing other $(x, y, \pi)$ triples. The $\Sigma$-protocol, an interactive proof system, offers three key properties: \textbf{completeness} (an honest prover with $sk$ convinces the verifier), \textbf{soundness} (a dishonest prover cannot prove a false statement), and \textbf{zero-knowledge} (the proof reveals nothing about $sk$, and a simulator can mimic it for true statements). These align perfectly with the VRF's needs: completeness supports correctness, soundness enforces uniqueness, and zero-knowledge preserves pseudorandomness by hiding $sk$.

The zero-knowledge property ensures $sk$ remains secret, but the simulator can only generate valid proofs for \textbf{true statements}, e.g., $y = f_{sk}(x)$. It cannot produce a proof for a false statement, like $y' \neq f_{sk}(x)$, that passes verification, due to the \textbf{soundness} property. Soundness ensures that only proofs for the correct $y$ are accepted, preventing an adversary from forging a proof for an incorrect output. Thus, the uniqueness of $y$ is preserved, as false proofs are rejected with overwhelming probability.

\textbf{Concrete Example:} Consider a VRF where $y = g^{1/(sk + x)}$ in a group of prime order $p$, and the $\Sigma$-protocol proves $y^{sk + x} = g$. Here, $y$ is uniquely determined by $sk$ and $x$ (since exponentiation is injective for $sk + x \neq 0 \mod p$). The $\Sigma$-protocol ensures that only the correct $y$ satisfies the equation, and a proof for an incorrect $y'$ (where $y'^{sk + x} \neq g$) fails verification. Despite zero-knowledge allowing simulation for the true $y$, soundness prevents valid proofs for false $y'$, reinforcing uniqueness.

A potential concern with using zero-knowledge proofs for VRFs is that proof simulatability might conflict with output uniqueness. In general NIZKs, the simulation property could potentially allow valid proofs for multiple outputs of the same input, e.g. $y_1, y_2$ for the same input $x$, violating the VRF uniqueness requirement. Our construction resolves this tension by leveraging a $\Sigma$-protocol to prove the statement $y^{sk + x} = g$ where $y = g^{1/(sk + x)}$. This equation has exactly one solution for $y$ given fixed values of $sk$ and $x$ (when $sk + x \neq 0 \mod p$). While the protocol's zero-knowledge property conceals $sk$, its soundness guarantees that only proofs for the correct $y$ will verify, thereby enforcing rather than compromising uniqueness.


In conclusion, the zero-knowledge property of $\Sigma$-protocols does not weaken the VRF's verifiable uniqueness, as simulation is limited to true statements. Meanwhile, soundness upholds the integrity of the proof, ensuring only the correct $y$ verifies.

\paragraph{Information-Theoretic vs. Computational Uniqueness} 
For Pseudorandomness: We move from q-DBDHI in bilinear groups to q-DDHI in prime-order groups. This change is related to eliminating the pairing operation while maintaining the pseudorandomness property.
For Uniqueness: We move from information-theoretic uniqueness (enforced by the algebraic properties of pairings) to computational uniqueness (enforced by the soundness of the Sigma protocol). The latter relies on the discrete logarithm assumption, which is a separate assumption from q-DDHI.


Our pairing-free VRF construction makes a fundamental tradeoff between efficiency and the nature of its uniqueness guarantee. The original Dodis-Yampolskiy VRF achieves \emph{information-theoretic uniqueness} through its bilinear pairing verification equation $e(g^x \cdot pk, \pi) = e(g, \tilde{g})$, which creates an algebraic constraint that cannot be violated even with unlimited computational power. In contrast, our $\Sigma$-protocol approach provides \emph{computational uniqueness}, where the guarantee depends on the soundness property of the proof system and the underlying hardness of the discrete logarithm problem. While theoretically a weaker property, computational uniqueness still provides robust security against all polynomial-time adversaries, making it a reasonable tradeoff for eliminating expensive pairing operations.


\subsection{On the Impossibility of Dodis-Yampolskiy VRF in Prime Order Groups without Pairings}

After careful analysis of the Dodis-Yampolskiy VRF construction and the formal requirements established by Micali and Vadhan, we have identified fundamental obstacles to implementing this VRF in a standard prime order group without bilinear pairings.

The original Dodis-Yampolskiy construction relies on bilinear pairings for a crucial reason: to enable verification of the inverse relationship between $g^{sk+x}$ and $\tilde{g}^{1/(sk+x)}$ without revealing the secret key $sk$. As shown in the screenshot, their construction provides:

\begin{itemize}
    \item A binding public key $PK = g^s$ that commits the owner to the function
    \item A VRF output with embedded proof $\textsf{SIGN}_{SK}(x) = g^{1/(s+SK)}$
    \item A verification equation $e(g^x \cdot PK, y) = e(g, g)$ that enforces uniqueness
\end{itemize}

Our investigation revealed three insurmountable challenges when attempting to adapt this construction to standard prime order groups:

\paragraph{Challenge 1: Verification of Inverse Relationships} Without pairings, a verifier cannot efficiently confirm that $y = g^{1/(sk+x)}$ given only $pk = g^{sk}$ and input $x$. This is because verifying the equation $y^{sk+x} = g$ requires either knowledge of $sk$ (which the verifier does not have) or a bilinear pairing.

\paragraph{Challenge 2: Information-Theoretic vs. Computational Uniqueness} The Dodis-Yampolskiy construction provides information-theoretic uniqueness through its pairing-based verification. Any attempt to replace this with a $\Sigma$-protocol would downgrade this to computational uniqueness based on the soundness of the proof system.

\paragraph{Challenge 3: Binding Commitment with Public Verification} Micali and Vadhan emphasize that "For any public key PK, even an improperly chosen one, a unique value $v$ is provable as the value of $f_s(x)$." This property is difficult to achieve without pairings when dealing with inverse relationships.

While we could construct a protocol where:
\begin{itemize}
    \item The public key remains $pk = g^{sk}$
    \item The output is $y = g^{1/(sk+x)}$
    \item A $\Sigma$-protocol proves knowledge of $sk$ where $pk = g^{sk}$ and $y^{sk+x} = g$
\end{itemize}

Such a construction would deviate from the strict VRF definition in important ways:

\begin{enumerate}
    \item The uniqueness property would rely on computational assumptions rather than being information-theoretic
    \item The verification process would fundamentally change from checking algebraic relationships to verifying zero-knowledge proofs
    \item The non-interactive requirement would necessitate applying the Fiat-Shamir heuristic, introducing additional security assumptions
\end{enumerate}

These findings highlight that the bilinear pairing in Dodis-Yampolskiy's construction is not merely an implementation choice but a fundamental component that enables the mathematical properties required for a true VRF according to Micali and Vadhan's definition.

This impossibility result motivates our alternative approach in subsequent sections, where we develop a different technique for our credential binding application that preserves the desired security properties without requiring pairings, albeit under a slightly different security model.





\section{Background}


Verifiable Random Function
\begin{itemize}
    \item $Gen(1^\secparam):$ Choses $sk \sample \Z_p^*$, $pk \gets g^{sk}$
    \item $Eval(sk, x):$ output $y = e(g, \tilde{g})^{1/(x + sk)}$
    \item $Prove(sk, x):$ output $\pi = \tilde{g}^{1/(x + sk)}$
    \item $Verify(pk, x, y, \pi)$: 
        \begin{itemize}
            \item $e(g^x \cdot pk, \tilde{y}) = e(g, \tilde{g})$ 
            \item $y = e(g, \pi)$
        \end{itemize}
\end{itemize}

VRF achieves pseudorandomness because:
\begin{itemize}
    \item Output $ y = e(g, \tilde{g})^{1/(x + sk)} $ in $ \mathbb{G}_T $ looks random.
    \item Proof $ \pi = \tilde{g}^{1/(x + sk)} $ in $ \mathbb{G}_2 $ looks random and independent.
    \item No detectable relation between $ y $ and $ \pi $ across inputs, due to distinct groups and bilinear pairing.
\end{itemize}
This ensures $ y $ appears fully random, unlike VUF's unpredictable but relatable outputs.



\section{Verifiable Random Functions vs Verifiable Unpredictable Functions}

\subsection{Definitions and Security Goals}

\begin{itemize}
    \item \textbf{Verifiable Random Function (VRF)}: A function $F_{sk}(x)$ where the owner publishes a public key $pk$ as a commitment to $F$. VRFs produce outputs that are computationally indistinguishable from random.
    
    \item \textbf{Verifiable Unpredictable Function (VUF)}: Similar to VRF but with weaker security guarantees. Outputs are unpredictable but not necessarily pseudorandom.
    
    \item \textbf{Security Distinction}: Pseudorandomness (VRF) means outputs are indistinguishable from random. Unpredictability (VUF) means outputs are computationally infeasible to predict without the secret key.
    
    \item \textbf{Comparison to Signatures}: A signature scheme $\text{Sig}(x)$ is unpredictable but not pseudorandom. There may be many valid signatures for a given input $x$.
\end{itemize}

\subsection{Constructions}

\subsubsection{Verifiable Unpredictable Function}
\begin{itemize}
    \item $\text{Gen}(1^\lambda):$ Choose $sk \stackrel{\$}{\leftarrow} \mathbb{Z}_p^*$, set $pk \leftarrow g^{sk}$
    \item $\text{Eval}(sk, x):$ Output $y = g^{1/(x + sk)}$
    \item $\text{Verify}(pk, x, y):$ Output 1 if $e(g^x \cdot pk, y) = e(g, \tilde{g})$
\end{itemize}

\subsubsection{Verifiable Random Function}
\begin{itemize}
    \item $\text{Gen}(1^\lambda):$ Choose $sk \stackrel{\$}{\leftarrow} \mathbb{Z}_p^*$, set $pk \leftarrow g^{sk}$
    \item $\text{Eval}(sk, x):$ Output $y = e(g, \tilde{g})^{1/(x + sk)}$
    \item $\text{Prove}(sk, x):$ Output $\pi = \tilde{g}^{1/(x + sk)}$
    \item $\text{Verify}(pk, x, y, \pi):$ Verify:
    \begin{itemize}
        \item $e(g^x \cdot pk, \pi) = e(g, \tilde{g})$ 
        \item $y = e(g, \pi)$
    \end{itemize}
\end{itemize}

\subsection{Input-Output Structures and Security Implications}

\subsubsection{VUF Structure}
\begin{itemize}
    \item Operates entirely within one group: $y = g^{1/(x + sk)} \in \mathbb{G}_1$
    \item For different inputs $x_1, x_2$, the outputs $y_1, y_2$ reside in the same group
    \item Relationships between outputs can be computed: $y_1/y_2 = g^{1/(x_1 + sk) - 1/(x_2 + sk)}$
    \item These relationships may reveal patterns, making outputs unpredictable but not pseudorandom
\end{itemize}

\subsubsection{VRF Structure}
\begin{itemize}
    \item Splits its output across different groups:
    \begin{itemize}
        \item Output $y = e(g, \tilde{g})^{1/(x + sk)} \in \mathbb{G}_T$
        \item Proof $\pi = \tilde{g}^{1/(x + sk)} \in \mathbb{G}_2$
    \end{itemize}
    \item For different inputs $x_1, x_2$:
    \begin{itemize}
        \item Outputs $y_1, y_2 \in \mathbb{G}_T$ and proofs $\pi_1, \pi_2 \in \mathbb{G}_2$
        \item No direct operations possible between groups to correlate outputs
        \item The bilinear pairing $e(g, \pi) = y$ ties each output to its proof
    \end{itemize}
    \item Group separation enforces independence across outputs
\end{itemize}

\subsection{Why VRFs Achieve Pseudorandomness}
\begin{itemize}
    \item \textbf{Group Separation}: Outputs $y \in \mathbb{G}_T$ and proofs $\pi \in \mathbb{G}_2$ exist in different groups
    \item \textbf{Pairing Constraint}: The relation $e(g, \pi) = y$ connects individual outputs to proofs but doesn't reveal relationships between different input-output pairs
    \item \textbf{No Detectable Patterns}: Unlike VUFs, outputs appear independent and random across different inputs
    \item \textbf{Bilinear Mapping}: The use of a bilinear pairing $e: \mathbb{G}_1 \times \mathbb{G}_2 \rightarrow \mathbb{G}_T$ creates outputs in a target group with stronger randomness properties
\end{itemize}

\subsection{Summary}
VRFs provide stronger security guarantees than VUFs due to their sophisticated input-output structure that leverages multiple groups and bilinear pairings. This structure ensures outputs are not just unpredictable (as in VUFs) but truly pseudorandom, making VRFs suitable for applications requiring stronger notions of randomness and independence.


















\newpage
\section{Step 1. Efficiency DY > PF-DY (Prime Order VRF)}
\[
\mathcal{R} = \{(pk, x, y), (sk) \mid pk = g^{sk} \quad \wedge \quad y^{sk+x} = g\}
\]


\subsection{Proof Protocol}
To prove that $y = g^{1/(sk+x)}$ without revealing $sk$, we use a $\Sigma$-protocol that demonstrates knowledge of $sk$ such that $pk = g^{sk}$ and $y^{sk+x} = g$. The protocol operates as follows:

\begin{protocol}{$\pi$ for VRF Prime Order Group}{}\label{pok-vrf-prime-order-group}
\textbf{Common Input:} Generator $g \in \G$, public elements $pk, y \in \G$ and VRF input $x \in \Z_q$\\
\textbf{Prover Input:} Witness $(sk)$ such that: $y = g^{1/(sk + x)}$
\begin{enumerate}
    \item \textbf{Commitment:} Prover samples $r \sample \Z_q$, computes 
    \[
    T_1 = g^r \qquad T_2 = y^r
    \]
    Sends $(T_1, T_2)$ to verifier.
    
    \item \textbf{Challenge:} Verifier samples $c \sample \mathbb{Z}_q$ and sends to prover.
    
    \item \textbf{Response:} Prover computes:
    \[
    z = r + c \cdot (sk + x)
    \]
    Sends $z$ to verifier
    
    \item \textbf{Verification:} Verifier checks:
    \[
    T_1 \cdot (pk \cdot g^x)^c \stackrel{?}{=} g^z \qquad T_2 \cdot g^c \stackrel{?}{=} y^z
    \]
 
\end{enumerate}
\end{protocol}









\newpage
\section{Step 2. Privacy}
Our goal is to prove this relation in zero knowledge $y^{sk+x} = g$. We start small and work our way up. 

We start by prove knowledge of a DDHI challenge


\section{Step 2.1 Proving Committed Exponent and DDHI Challenge}

\subsection*{Proving Knowledge of Inverse Exponent}
This protocol allows a prover to demonstrate, in zero-knowledge, that they know a secret $x$ and randomness $r$ such that a commitment $\cm = g_1^x g^r$ and a Decisional Diffie-Hellman Inversion (DDHI) challenge $y = g^{1/x}$ are consistently formed. It proves the prover knows the $x$ linking both $\cm$ and $y$ without revealing $x$. This is vital in cryptographic systems relying on the DDHI assumption—where distinguishing $g^{1/x}$ from random given $g, g^x$ is hard—ensuring secure, privacy-preserving proofs of secret knowledge tied to intractable problems.

The relation being proven is:
\[
\mathcal{R} = \left\{ (\cm, y), (x, r) \ \middle|\ \cm = g_1^x g^r \ \land\ y = g^{1/x} \right\}
\]


\begin{protocol}{Proving Knowledge of Inverse Exponent}{committed-inverse-exponent}\label{pok-committed-inverse-exponent}
\textbf{Common Input:} Group generators $g_1, g \in \mathbb{G}$, commitment $\cm \in \mathbb{G}$, and element $y \in \mathbb{G}$\\
\textbf{Prover Input:} Witness $(x, r)$ such that:
    \begin{align*}
        \cm &= g_1^x g^r     &    y &= g^{1/x}
    \end{align*}
\begin{enumerate}
    \item \textbf{Commitment:} Prover samples $a_x, a_r \in \Z_q$ and computes \\
    \begin{align*}
        T_1 &\gets g_1^{a_x} g^{a_r}  &   T_y &\gets y^{a_x}
    \end{align*}
    Sends $(T_1, T_y)$ to verifier.
    
    \item \textbf{Challenge:} Verifier samples $c \sample \mathbb{Z}_q$ and sends to prover.
    
    \item \textbf{Response:} Prover computes:
    \[
        z_x = a_x + c \cdot x \qquad z_r = a_r + c \cdot r
    \]
    Sends $(z_x, z_r)$ to verifier.
    
    \item \textbf{Verification:} Verifier checks:
    \begin{align*}
        T_1 \cdot \cm^c &\stackrel{?}{=} g_1^{z_x} g^{z_r}  &
        T_y \cdot g^c &\stackrel{?}{=} y^{z_x}
    \end{align*}
\end{enumerate}
\end{protocol}


\newpage
\section{Step 2.2}

\begin{protocol}{Proving Committed Inverse Linear Relation}{committed-inverse-linear-relation}\label{pok-committed-inverse-linear-relation}
\textbf{Relation: }
\[
\mathcal{R} = \{(\cm_1, y), (sk, x, r) \mid \cm_1 = g_1^{sk} g_2^{x} g^{r} \wedge y = g^{1/(sk + x)}\}
\]
\textbf{Common Input:} Group generators $g_1, g_2, g \in \mathbb{G}$, commitment $\cm_1 \in \mathbb{G}$, and output $y \in \mathbb{G}$\\
\textbf{Prover Input:} Witness $(sk, x, r)$ such that:
    \begin{align*}
        \cm_1 &= g_1^{sk} g_2^{x} g^{r} & y &= g^{1/(sk + x)}
    \end{align*}
\begin{enumerate}
    \item \textbf{Commitment:} Prover samples random blinding factors from $\mathbb{Z}_q$:
       \[
        a_x \quad \text{for} \quad x \in \{ sk, x, r \} \in \mathbb{Z}_q
       \]
    \textbf{Computes}:
    \begin{align*}
        T_1 &\gets g_1^{a_{sk}} g_2^{a_x} g^{a_r} & T_y &\gets y^{a_{sk} + a_x}
    \end{align*}
    Sends $(T_1, T_y)$ to verifier.
    
    \item \textbf{Challenge:} Verifier samples $c \sample \mathbb{Z}_q$ and sends to prover.
    
    \item \textbf{Response:} Prover computes:
    \[
    z_x = a_x + c \cdot x \quad \text{for} \quad x \in \{ sk, x, r \}
    \]
    \[
    z_m = (a_{sk} + a_x) + c \cdot (sk + x)
    \]
    Sends $(z_{sk}, z_x, z_r, z_m)$ to verifier.
    
    \item \textbf{Verification:} Verifier checks:
    \begin{align*}
        T_1 \cdot \cm_1^c &\stackrel{?}{=} g_1^{z_{sk}} g_2^{z_x} g^{z_r} &
        T_y \cdot g^c &\stackrel{?}{=} y^{z_m} &
        z_m &\stackrel{?}{=} z_{sk} + z_x
    \end{align*}
\end{enumerate}
\end{protocol}









\newpage
\section{Integration to Identity System}

\begin{protocol}{Proving Committed Inverse Linear Relation from Two Commitments}{committed-inverse-linear-relation-two-commitments}\label{pok-committed-inverse-linear-relation-two-commitments}
\textbf{Relation: }
\[
\mathcal{R} = \{(\cm_1, \cm_2, y), (sk, x, r_1, r_2) \mid \cm_1 = g_1^{sk} g^{r_1} \wedge \cm_2 = g_2^{x} g^{r_2} \wedge y = g^{1/(sk + x)}\}
\]
\textbf{Common Input:} Group generators $g_1, g_2, g \in \mathbb{G}$, commitments $\cm_1, \cm_2 \in \mathbb{G}$, and output $y \in \mathbb{G}$\\
\textbf{Prover Input:} Witness $(sk, x, r_1, r_2)$ such that:
    \begin{align*}
        \cm_1 &= g_1^{sk} g^{r_1} & \cm_2 &= g_2^{x} g^{r_2} & y &= g^{1/(sk + x)}
    \end{align*}
\begin{enumerate}
    \item \textbf{Commitment:} Prover samples random blinding factors from $\mathbb{Z}_q$:
       \[
        a_x \quad \text{for} \quad x \in \{ sk, x, r_1, r_2 \} \in \mathbb{Z}_q
       \]
    \textbf{Computes}:
    \begin{align*}
        T_1 &\gets g_1^{a_{sk}} g^{a_{r_1}} & T_2 &\gets g_2^{a_x} g^{a_{r_2}} & T_y &\gets y^{a_{sk} + a_x}
    \end{align*}
    Sends $(T_1, T_2, T_y)$ to verifier.
    
    \item \textbf{Challenge:} Verifier samples $c \sample \mathbb{Z}_q$ and sends to prover.
    
    \item \textbf{Response:} Prover computes:
    \[
    z_x = a_x + c \cdot x \quad \text{for} \quad x \in \{ sk, x, r_1, r_2 \}
    \]
    \[
    z_m = (a_{sk} + a_x) + c \cdot (sk + x)
    \]
    Sends $(z_{sk}, z_x, z_{r_1}, z_{r_2}, z_m)$ to verifier.
    
    \item \textbf{Verification:} Verifier checks:
    \begin{align*}
        T_1 \cdot \cm_1^c &\stackrel{?}{=} g_1^{z_{sk}} g^{z_{r_1}} &
        T_2 \cdot \cm_2^c &\stackrel{?}{=} g_2^{z_x} g^{z_{r_2}} &
        T_y \cdot g^c &\stackrel{?}{=} y^{z_m} &
        z_m &\stackrel{?}{=} z_{sk} + z_x
    \end{align*}
\end{enumerate}
\end{protocol}






\newpage
\section{Committed $y$ extensions - probably in the appendix}

\section{Proving Committed Exponent and Committed Inverse Exponent}

\subsection*{Protocol 2: Proving Inverse Attributes in Commitments}
This protocol enables a prover to prove, in zero-knowledge, that the attribute $\beta$ in one commitment $\cm_2 = g_1^\beta g^{\usk_2}$ is the multiplicative inverse of the attribute $m$ in another commitment $\cm_1 = g_1^m g^{\usk_1}$, i.e., $\beta = \frac{1}{m}$, using an additional commitment $\cm_3 = \cm_2^m g^{\usk_3}$ to encode this relationship. Unlike the DDHI challenge in Protocol 1, here the inverse is committed with randomness $\usk_2$, not directly exposed. This would be applied in applications where a prover has multiple commitments e.g. credentials and needs to prove such relation exists.

The relation being proven is:
\[
\mathcal{R} = \left\{ (\cm_1, \cm_2, \cm_3), (m, \beta, \usk_1, \usk_2, \usk_3) \ \middle|\ \cm_1 = g_1^m g^{\usk_1} \ \land\ \cm_2 = g_1^\beta g^{\usk_2} \ \land\ \cm_3 = \cm_2^m g^{\usk_3} \ \land\ \beta = \frac{1}{m} \right\}
\]

\begin{protocol}{Proving Inverse Exponent}{committed-multiplicative-inverse}\label{pok-committed-multiplicative-inverse}
\textbf{Common Input:} Group generators $g_1, g \in \mathbb{G}$, and commitments $\cm_1, \cm_2, \cm_3 \in \mathbb{G}$\\
\textbf{Prover Input:} Witness $(m, \beta, \usk_1, \usk_2, \usk_3)$ such that:
    \begin{align*}
        \cm_1 &= g_1^m g^{\usk_1}     &    \cm_2 &= g_1^\beta g^{\usk_2}  &   \cm_3 &= \cm_2^m g^{\usk_3} \\
        \beta &= \frac{1}{m}     &   \cm_3 &= g_1 g^{\usk_2 m + \usk_3}
    \end{align*}
\begin{enumerate}
    \item \textbf{Commitment:} Prover samples random blinding factors from $\mathbb{Z}_q$:
       \[
        a_x \quad \text{for} \quad x \in \{ m, \beta, \usk_1, \usk_2, \usk_3 \} \in \mathbb{Z}_q
       \]
    \textbf{Computes}:
    \begin{align*}
        T_1 &\gets g_1^{a_m} g^{a_{\usk_1}}  &   T_2 &\gets g_1^{a_\beta} g^{a_{\usk_2}}     &   T_3 &\gets \cm_2^{a_m} g^{a_{\usk_3}}
    \end{align*}
    Sends $(T_1, T_2, T_3)$ to verifier.
    
    \item \textbf{Challenge:} Verifier samples $c \sample \mathbb{Z}_q$ and sends to prover.
    
    \item \textbf{Response:} Prover computes:
    \[
    z_x = a_x + c \cdot x \quad \text{for} \quad x \in \{ m, \beta, \usk_1, \usk_2, \usk_3 \}
    \]
    \[
    z_r = a_{\usk_3} + c \cdot (\usk_2 m + \usk_3)
    \]
    Sends $(z_m, z_\beta, z_{\usk_1}, z_{\usk_2}, z_{\usk_3}, z_r)$ to verifier.
    
    \item \textbf{Verification:} Verifier checks:
    \begin{align*}
        T_1 \cdot \cm_1^c &\stackrel{?}{=} g_1^{z_m} g^{z_{\usk_1}}  &
        T_2 \cdot \cm_2^c &\stackrel{?}{=} g_1^{z_\beta} g^{z_{\usk_2}} \\
        T_3 \cdot \cm_3^c &\stackrel{?}{=} \cm_2^{z_m} g^{z_{\usk_3}} &
        \cm_3^c &\stackrel{?}{=} g_1^c g^{z_r}
    \end{align*}
\end{enumerate}
\end{protocol}




\newpage
\section{Committed}

\begin{protocol}{Proving Committed Exponent and Committed Inverse Exponent}{committed-exponent-inverse}\label{pok-committed-exponent-inverse}
\textbf{Relation: }
\[
\mathcal{R} = \left\{ (\cm_1, \cm_2), (sk, x, r_1, r_2) \ \middle|\ \cm_1 = g_1^{sk} g_2^{x} g^{r_1} \ \land\ \cm_2 = g_3^{1/(sk + x)} g^{r_2} \right\}
\]
\textbf{Common Input:} Group generators $g_1, g_2, g_3, g \in \mathbb{G}$, commitments $\cm_1, \cm_2 \in \mathbb{G}$, and auxiliary commitments $\cm_m, \cm_3 \in \mathbb{G}$\\
\textbf{Prover Input:} Witness $(sk, x, r_1, r_2, m, r_m, r_3)$ such that:
    \begin{align*}
        \cm_1 &= g_1^{sk} g_2^{x} g^{r_1} & \cm_2 &= g_3^{1/(sk + x)} g^{r_2} \\
        m &= sk + x & \cm_m &= g_4^{m} g^{r_m} & \cm_3 &= \cm_2^{m} g^{r_3} = g_3 g^{r_2 m + r_3}
    \end{align*}
\begin{enumerate}
    \item \textbf{Commitment:} Prover samples random blinding factors from $\mathbb{Z}_q$:
       \[
        a_x \quad \text{for} \quad x \in \{ sk, x, r_1, m, r_m, \beta, r_2, r_3 \} \in \mathbb{Z}_q \quad \text{where} \quad \beta = \frac{1}{sk + x}
       \]
    \textbf{Computes}:
    \begin{align*}
        T_1 &\gets g_1^{a_{sk}} g_2^{a_x} g^{a_{r_1}} & T_m &\gets g_4^{a_m} g^{a_{r_m}} \\
        T_2 &\gets g_3^{a_\beta} g^{a_{r_2}} & T_3 &\gets \cm_2^{a_m} g^{a_{r_3}}
    \end{align*}
    Sends $(T_1, T_m, T_2, T_3)$ to verifier.
    
    \item \textbf{Challenge:} Verifier samples $c \sample \mathbb{Z}_q$ and sends to prover.
    
    \item \textbf{Response:} Prover computes:
    \[
    z_x = a_x + c \cdot x \quad \text{for} \quad x \in \{ sk, x, r_1, m, r_m, \beta, r_2, r_3 \}
    \]
    Sends $(z_{sk}, z_x, z_{r_1}, z_m, z_{r_m}, z_\beta, z_{r_2}, z_{r_3})$ to verifier.
    
    \item \textbf{Verification:} Verifier checks:
    \begin{align*}
        T_1 \cdot \cm_1^c &\stackrel{?}{=} g_1^{z_{sk}} g_2^{z_x} g^{z_{r_1}} &
        T_m \cdot \cm_m^c &\stackrel{?}{=} g_4^{z_m} g^{z_{r_m}} \\
        T_2 \cdot \cm_2^c &\stackrel{?}{=} g_3^{z_\beta} g^{z_{r_2}} &
        T_3 \cdot \cm_3^c &\stackrel{?}{=} \cm_2^{z_m} g^{z_{r_3}} \\
        z_m &\stackrel{?}{=} z_{sk} + z_x &
        \cm_3 &\stackrel{?}{=} g_3 g^{s} \quad \text{for some } s \in \mathbb{Z}_q
    \end{align*}
\end{enumerate}
\end{protocol}