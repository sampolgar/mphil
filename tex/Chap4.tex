\mychapter{Credential Relationship Binding Nullifier}
Anonymous credential systems enable users to prove statements about their identity while maintaining privacy. In Chapters 2 and 3, we advanced from single-issuer Attribute-Based Anonymous Credentials ($\ABC$) to a Multi-Issuer Multi-Credential system ($\MIMCABC$) that securely binds credentials from different issuers to the same identity. However, practical identity frameworks require two additional capabilities: sybil resistance, revocation, and credential hierarchy.

In this chapter, we address the challenge of designing efficient, privacy-preserving Verifiable Random Functions (VRFs) for the Multi-Issuer Multi-Credential (MIMC) system, focusing on hierarchical credential binding and nullifier generation. Existing VRF constructions, such as those relying on pairings or RSA, often suffer from computational overhead or limited privacy guarantees, making them impractical for large-scale anonymous credential systems requiring sybil resistance and revocation.

\subsection*{Chapter Roadmap}
The remainder of the chapter is as follows
\begin{enumerate}
    \item Introduction
    \item Preliminaries
    \item Prime-Order VRF From the $q$-DDHI (DY-PF)
    \item Anonymous Prime-Order VRFs from the $q$-DDHI
    \item Performance Evaluation
    \item Instantiation: Anonymous Nullifiers for Sybil Resistance and Revocation
    \item Conclusion
\end{enumerate}

\section{Introduction}
Real-world credentials naturally form a hierarchy, this is notable when applying for bank loans or new credentials from the government that require multiple credentials shown together. A simple task without privacy, a user hands over multiple credentials, and their details should match a "higher-security" document, like a passport. However, it is a challenging request with privacy-preserving credential systems. Consider a user in a privacy-preserving identity system with both a passport and a driver's license, as shown in Figure~\ref{fig:credential-nullifier}, the passport functions as a foundational Master Credential containing a secret key $\k$, while the driver's license is a Context Credential tied to a specific domain $\ctx$. For privacy and security, we need to cryptographically bind these credentials together and prevent users from obtaining multiple credentials for the same context (e.g., multiple driver's licenses) without compromising anonymity.

A nullifier is a public piece of data that represents a user's account or specific credential information in secrecy. Our nullifier schemes take in the key $\k$ from the master credential and $\ctx$ from the context credential and produce a unique and pseudorandom output. The deterministic version can be used in an anonymous user list for sybil resistance, and the probabilistic version can be used in membership proofs and revocation lists. 


\begin{figure}
    \centering
    \begin{tikzpicture}[
        box/.style={draw, rounded corners=2pt, minimum width=6cm, minimum height=8cm},
        smallbox/.style={draw, rounded corners=2pt, fill=gray!10, minimum width=5cm, minimum height=3cm},
        listbox/.style={draw, rounded corners=2pt, minimum width=5cm, minimum height=3cm},
        thick
    ]
    
    % Digital Credential Wallet
    \node[box] (wallet) at (0,0) {};
    \node[anchor=north, font=\bfseries] at ($(wallet.north) + (0,-0.3)$) {Digital Credential Wallet};
    
    % Master Credential
    \node[smallbox] (master) at (0,1.7) {};
    \node[anchor=north, font=\small\bfseries] at ($(master.north) + (0,-0.3)$) {Master Credential};
    
    \node[anchor=north west, font=\small, align=left] at ($(master.north west) + (0.5,-0.7)$) {
        id : 12345, \\
        ctx : "passport", \\
        exp : "10/11/2026", \\
        k : 54321
    };
    
    % Context Credential
    \node[smallbox] (context) at (0,-1.7) {};
    \node[anchor=north, font=\small\bfseries] at ($(context.north) + (0,-0.3)$) {Context Credential};
    
    \node[anchor=north west, font=\small, align=left] at ($(context.north west) + (0.5,-0.7)$) {
        id : 12345, \\
        ctx : "DMV", \\
        exp : "10/11/2028"
    };
    
    % Add a dividing line between credentials in wallet
    \draw[dashed] ($(wallet.west) + (0.2,0)$) -- ($(wallet.east) + (-0.2,0)$);
    
    % Anonymous User List
    \node[listbox] (userlist) at (8,2.5) {};
    \node[anchor=north, font=\bfseries] at ($(userlist.north) + (0,-0.3)$) {Anon. User List};
    
    % Draw horizontal lines in the user list
    \draw ($(userlist.north west) + (0,-0.8)$) -- ($(userlist.north east) + (0,-0.8)$);
    
    % Formula in the second row of user list
    \node[font=\small, align=center] at ($(userlist.north) + (0,-1.3)$) {Sec: \ref{sec:privacy-preserving-vrf} $ y = g^{1/(k + \text{"DMV"})}$};
    
    \draw ($(userlist.north west) + (0,-1.8)$) -- ($(userlist.north east) + (0,-1.8)$);
    \draw ($(userlist.north west) + (0,-2.2)$) -- ($(userlist.north east) + (0,-2.2)$);
    \draw ($(userlist.north west) + (0,-2.6)$) -- ($(userlist.north east) + (0,-2.6)$);
    
    % Revocation List
    \node[listbox] (revlist) at (8,-2.5) {};
    \node[anchor=north, font=\bfseries] at ($(revlist.north) + (0,-0.3)$) {Revocation List};
    
    % Draw horizontal lines in the revocation list
    \draw ($(revlist.north west) + (0,-0.8)$) -- ($(revlist.north east) + (0,-0.8)$);
    
    % Formula in the second row of revocation list
    \node[font=\small, align=center] at ($(revlist.north) + (0,-1.3)$) {Sec: \ref{pok-committed-nullifier-vrf} $\cm_y = g_1^{1/(k + \text{"DMV"})}g^{\usk_3}$};

    
    
    \draw ($(revlist.north west) + (0,-1.8)$) -- ($(revlist.north east) + (0,-1.8)$);
    \draw ($(revlist.north west) + (0,-2.2)$) -- ($(revlist.north east) + (0,-2.2)$);
    \draw ($(revlist.north west) + (0,-2.6)$) -- ($(revlist.north east) + (0,-2.6)$);
    
    % Arrows - from wallet to lists, touching the boxes
    \draw[->, thick] (wallet.east) -- (userlist.west);
    \draw[->, thick] (wallet.east) -- (revlist.west);
    
    \end{tikzpicture}
    \caption{A credential hierarchy with nullifiers that bind context credentials to a master credential. The nullifiers create verifiable bindings that prevent sybil attacks while maintaining privacy, with separate paths for anonymous user authentication and revocation management.}
    \label{fig:credential-nullifier-revised}
\end{figure}


\subsection{Goals}


\begin{enumerate}
    \item \textbf{Efficiency}: The nullifier must be generated and verifiable with minimal overhead, avoiding bilinear pairings and MPC while maintaining provable uniqueness and verifiable pseudorandomness.
    
    \item \textbf{Anonymity}: Nullifier generation and verification must not reveal the user inputs $\k, \ctx$ and optionally enable unlinkable outputs. 
    
    \item \textbf{Integration with Anonymous Credentials}: The nullifier mechanism must seamlessly extend our existing anonymous credential framework without compromising its security properties.
\end{enumerate}

\subsection{Core Challenges}


Creating an efficient, privacy-preserving nullifier for credential binding raises three specific challenges:

\begin{enumerate}
    \item \textbf{Prime Order (Pairing-Free) DY VRF}: The DY VRF provides a secure structure but uses expensive bilinear pairings. Our first challenge is to create a Pairing-Free DY VRF using a $\Sigma$-protocol to maintain security under the $q$-DDHI assumption.
    
    \item \textbf{Anonymous Input for Prime-Order VRF}: To transform our Prime-Order DY VRF for Anonymous Credentials, we must use a commitment to the VRF inputs. Our second core challenge is to create a $\Sigma$-protocol to prove knowledge of $x$ such that $y = g^{1/x}$ (the $q$-DDHI challenge). Our third core challenge extends this by incorporating the proof of linear relations, the final protocol proves knowledge of $(x, sk)$ such that $y = g^{1/(sk + x)}$ where $y$ is a deterministic nullifier.
    
    \item \textbf{Unlinkable Output for Prime-Order VRF}: The deterministic nullifier can be used for sybil resistance during credential generation but can't be used ongoing as each output links the user's actions. Our fourth and last core challenge is to extend our protocol to generate provable, probabilistic nullifiers. We need to output a commitment to the nullifier so it can be used without linking the user. The final protocol proves knowledge of $(x, sk,r)$ such that $\cm_y = g_1^{1/(sk + x)}g^r$. 
\end{enumerate}



\subsection{Related Work}

\begin{table}
\begin{center}
\caption{Comparison of Nullifier/VRF Schemes for Credential Binding}
\label{tab:nullifier-comparison}
\begin{tabular}{l|cccccc}
\toprule
\textbf{Scheme} & 
\textbf{Deterministic} & 
\textbf{Unlinkable}  & 
\textbf{Private} & 
\textbf{Pairing-} & 
\textbf{Proof} & 
\textbf{Relative} \\
 & 
 \textbf{Output}$^1$ & 
 \textbf{Output}$^2$ & 
 \textbf{Input}$^3$ & 
 \textbf{Free} & 
 \textbf{Type} & 
 \textbf{Ver. Time}$^4$ \\
\midrule
NSEC5 \cite{goldberg_nsec5_2015} & 
\ding{51} & 
\ding{55} & 
\ding{55} & 
\ding{51} & 
Sigma Only & 3x faster
\\
DY VRF \cite{hutchison_verifiable_2005} & 
\ding{51} & 
\ding{55} & 
\ding{55} & 
\ding{55} & 
Pairing & 3x slower 
\\
CanDID \cite{maram2021candid} & 
\ding{51} & 
\ding{55} & 
\ding{51} & 
- & 
MPC & Very slow $^5$
\\
TACT/S3ID \cite{rabaninejad_attribute-based_2024} & 
\ding{51} & 
\ding{55} & 
\ding{51} & 
\ding{55} & 
Groth Sahai + Pairing & ~4x slower 
\\
SyRA \cite{crites_syra_2024} & 
\ding{51} & 
\ding{55} & 
\ding{55}  &
\ding{55} & 
 Sigma+Pairing & ~4x slower 
\\
UTT Nullifier \cite{tomescu2022utt} & 
\ding{51} & 
\ding{51} & 
\ding{51}  & 
\ding{55} & 
Sigma+Pairing & 4x slower 
\\
\text{Sec:} \ref{sec:privacy-preserving-vrf}: & 
\ding{51} & 
\ding{55} & 
\ding{51} & 
\ding{51} & 
Sigma only & 2x faster
\\
\text{Sec:} \ref{pok-committed-nullifier-vrf}: & 
\ding{51} & 
\ding{51} & 
\ding{51}  & 
\ding{51} & 
Sigma only & 1x (baseline) 
\\
\bottomrule
\end{tabular}
\end{center}
\vspace{1em}
\footnotesize{$^1$Ensures a unique underlying nullifier value per user-context pair for sybil resistance.} \\
\footnotesize{$^2$Nullifier can be presented as a commitment for unlinkability.} \\
\footnotesize{$^3$Operates on inputs (e.g., secret keys, attributes) hidden in commitments.} \\
\footnotesize{$^4$Approximate verification time relative to CRBN, based on benchmarks in Section \ref{sec:performance-vrf}} \\
\footnotesize{$^5$CanDIDs nullifier uses MPF{-}PRF with uncomparable efficiency}
\footnotesize{$^6$}
\end{table}

Previous systems have addressed aspects of hierarchical credential binding and sybil resistance, but all have significant limitations:

\begin{itemize}
    
    \item \textbf{Standard VRFs}~\cite{hutchison_verifiable_2005, goldberg_nsec5_2015} could generate unique nullifiers but use pairings and reveal the user's public key during verification, compromising anonymity.
        
    \item \textbf{Pairing-based systems} like SyRA~\cite{crites_syra_2024} and S3ID~\cite{rabaninejad_attribute-based_2024} implement hierarchical credentials but suffer from efficiency issues due to their reliance on pairings and S3ID uses Groth Sahai proofs which are less efficient than $\Sigma$-protocols.
    
    \item \textbf{UTT}~\cite{tomescu2022utt} uses a similar approach to ours for anonymous payments, creating serial numbers (nullifiers) from a registration credential. However, UTT relies on bilinear pairings, introducing substantial computational overhead.
    
    \item \textbf{CanDID}~\cite{maram2021candid} clearly defines the master/context credential relationship but compromises privacy by maintaining mappings between credential public keys, enabling linkability across interactions.

\end{itemize}


\subsection{Contributions}\label{sec:vrf-contributions}
We start with the $q$-DDHI assumption and work in two different directions. Firstly, we aim for efficiency and reconstruct the Dodis Yampolskiy VRF in a prime-order group and show XXX efficiency improvement while retaining security properties. Secondly, we aim for privacy,  starting with a novel zkpok protocol to prove the DDHI challenge $(g^{1/x})$ which we generalise to a sigma protocol for \emph{proof of inverse exponent}. We then extend this with a new private VRF to generate deterministic nullifiers from private inputs, combining our prime-order DY VRF and the ZKPoK of a DDHI challenge, where inputs are exponents in commitments for use in sybil-resistant mechanisms. We then extend this further for probabilistic outputs, committed but provable nullifiers to be used in revocation schemes. 


\begin{figure}[ht]
\centering
\begin{tikzpicture}[
    node distance=1cm,
    box/.style={rectangle, rounded corners, draw, fill=white, text width=2.5cm, minimum height=1cm, align=center, font=\small},
    arrow/.style={thick,->,>=stealth},
    improvement/.style={text width=3cm, align=center, font=\footnotesize\itshape}
]
% Root node
\node[box, fill=gray!10] (ddhi) {\textbf{DDHI Assumption}};

% Branch 1 - Top horizontal branch
\node[box, right=1.25cm of ddhi, yshift=1cm] (pfdy) {\textbf{Prime Order DY}};

% Branch 2 - Bottom horizontal branch with sequence
\node[box, right=1.25cm of ddhi, yshift=-1cm] (zkpok) {\textbf{ZKPoK of DDHI challenge}};
\node[box, right=1.25cm of zkpok] (anon) {\textbf{Anonymous VRF}};
\node[box, right=1.25cm of anon] (unlink) {\textbf{Unlinkable VRF}};

% Arrows between nodes with smooth curves
\draw[arrow] (ddhi.east) -- ++(0,0) -- (pfdy.west);
\draw[arrow] (ddhi.east) -- ++(0,0) -- (zkpok.west);
\draw[arrow] (zkpok.east) -- (anon.west);
\draw[arrow] (anon.east) -- (unlink.west);

% Improvement labels - positioned below the boxes
% \node[improvement, below=0.2cm of pfdy] {Remove Pairings};

% \node[improvement, below=0.2cm of zkpok] {Prove};
% \node[improvement, below=0.2cm of anon] {Adds privacy protection};
% \node[improvement, below=0.2cm of unlink] {Maintains verifiability while adding unlinkability};
\end{tikzpicture}
\caption{Sigma Protocols and VRF Constructions from the $q$-DDHI assumption}
\label{fig:vrf-construction-overview}
\end{figure}



\section{Preliminaries}

\subsection{Cryptographic Assumptions}

\begin{definition}[q-DDHI Assumption]
Let $\mathbb{G}$ be a cyclic group of prime order $p$ with generator $g$. The $q$-Decisional-Diffie-Hellman Inversion ($q$-DDHI) \cite{mitsunari_new_2002} assumption states that for any PPT adversary $\mathcal{A}$, there exists a negligible function $\negl$ such that:
\[
\left|\Pr\left[ x \sample \Zp^*, b \sample \{0,1\}, z_0 = g^{1/x}, z_1 \sample \G : \mathcal{A}(g, g^x, g^{x^2}, \ldots, g^{x^q}, z_b) = b \right] - \frac{1}{2}\right| \leq \negl(\lambda)
\]
Informally, given $(g, g^x, g^{x^2}, \ldots, g^{x^q})$, no PPT adversary can distinguish $g^{1/x}$ from a random group element with non-negligible advantage.
\end{definition}

% \begin{remark}
% The $q$-DDHI assumption is a variant of the $(q+1)$-generalized Diffie-Hellman assumption as shown by Boneh and Boyen \cite{kanade_efficient_2004}. This assumption directly underpins the security of our pairing-free VRF construction.
% \end{remark}

\begin{definition}[$q$-DBDHI Assumption]
Let $\mathbb{G}_1, \mathbb{G}_2, \mathbb{G}_T$ be cyclic groups of prime order $p$ with a bilinear pairing $e: \mathbb{G}_1 \times \mathbb{G}_2 \to \mathbb{G}_T$, and generators $g \in \mathbb{G}_1$, $\tilde{g} \in \mathbb{G}_2$. The $q$-Decisional-Bilinear Diffie-Hellman Inversion ($q$-DBDHI) assumption states that for any PPT adversary $\mathcal{A}$, there exists a negligible function $\negl$ such that:
\[
\left| \Pr\left[ x \sample \Z_p^*, b \sample \{0,1\}, z_0 = e(g, \tilde{g})^{1/x}, z_1 \sample \G_T : \mathcal{A}(g, g^x, g^{x^2}, \ldots, g^{x^q}, \tilde{g}, z_b) = b \right] - \frac{1}{2}\right| \leq \negl(\lambda)
\]
Informally, no PPT adversary can distinguish $e(g, \tilde{g})^{1/x}$ from a random element in $\mathbb{G}_T$ given $(g, g^x, \ldots, g^{x^q}, \tilde{g})$ with non-negligible advantage.
\end{definition}


\subsection{Building Blocks}

\subsubsection{Pedersen Vector Commitments}
We use position-binding Pedersen Commitments from Chapter 2, which allow committing to a vector of messages while hiding the values. For a message vector $[\id, \ctx, \exp, \k]$ and randomness $\usk$, the commitment is:
\[
\cm = \CMCom([m_1, \ldots, m_n];\usk) = g_1^{m_1} \cdots g_n^{m_n} g^\usk
\]

Pedersen Commitments provide three key properties:
\begin{itemize}
    \item \textbf{Hiding}: The commitment reveals no information about the committed values.
    \item \textbf{Binding}: It's computationally infeasible to open a commitment to different values.
    \item \textbf{Position-Binding}: Each position in the vector is cryptographically bound to its specific base element, preventing attribute swapping.
\end{itemize}


\subsubsection{Verifiable Random Functions}
A Verifiable Random Function (VRF) \cite{micali_verifiable_1999, hutchison_verifiable_2005} is a pseudorandom function that provides proofs of correct evaluation. Following \cite{bitansky_verifiable_2020}, a VRF consists of these algorithms:

\begin{definition}[Verifiable Random Function]
A VRF is a tuple of PPT algorithms \\
$(\VRFGen, \VRFEval, \VRFProve, \VRFVerify)$ with message space $\mathcal{X}$, output space $\mathcal{Y}$ and proof space $\Pi$ where:
\begin{itemize}
    \item $\VRFGen(1^\lambda) \to (sk, pk)$: Generates a secret key $sk$ and public key $pk$.
    \item $\VRFEval(sk,x) \to y$: Computes the VRF output $y \in \mathcal{Y}$ for input $x \in \mathcal{X}$ using secret key $sk$.
    \item $\VRFProve(sk,x) \to \pi$: Produces a proof $\pi \in \Pi$ that $y = \VRFEval(sk,x)$ is computed correctly.
    \item $\VRFVerify(pk,x,y,\pi) \to \{0,1\}$: Verifies that $y$ is the correct VRF output for input $x$ using proof $\pi$.
\end{itemize}
\end{definition}

A secure VRF must satisfy the following properties:

\begin{itemize}
    \item \textbf{Completeness:} Honest evaluation and proof generation always passes verification:
    \[
    \Pr\left[ \VRFVerify(pk,x,y,\pi) = 1 \ \middle| \ 
    \begin{array}{l}
        (sk, pk) \leftarrow \VRFGen(1^\lambda) \\
        y = \VRFEval(sk,x) \\
        \pi \leftarrow \VRFProve(sk,x)
    \end{array}
    \right] = 1
    \]
    
    \item \textbf{Uniqueness:} For each input $x$ and public key $pk$, only one output $y$ can be verified:
    \[
    \text{if} \quad \VRFVerify(pk, x, y_0, \pi_0) = \VRFVerify(pk, x, y_1, \pi_1) = 1 \quad \text{then} \quad y_0 = y_1
    \]
    
    \item \textbf{Pseudorandomness:} The VRF output is indistinguishable from random for any input not previously queried, defined by the following game $\mathcal{G}_{\mathcal{A}}^{\text{vrf}}$:
    \begin{enumerate}
        \item The VRF challenger samples $(sk, pk) \leftarrow \VRFGen(1^\lambda)$, and sends $pk$ to $\mathcal{A}$.
        \item $\mathcal{A}$ submits evaluation queries $x_1, \ldots, x_Q \in \mathcal{X}$, and receives $(y_i, \pi_i)$ for each query, where $y_i = \VRFEval(sk, x_i)$ and $\pi_i \leftarrow \VRFProve(sk, x_i)$.
        \item At any point, $\mathcal{A}$ submits a challenge input $x_* \in \mathcal{X}$ such that $x_* \not\in \{x_1, \ldots, x_Q\}$.
        \item The challenger computes $y_0^* = \VRFEval(sk, x_*)$, samples $y_1^* \sample \mathcal{Y}$ uniformly at random, then samples $b \sample \{0,1\}$ and sends $y_b^*$ to $\mathcal{A}$.
        \item $\mathcal{A}$ may continue to make evaluation queries for inputs other than $x_*$.
        \item At the end, $\mathcal{A}$ outputs a guess $b'$. The game outputs 1 if $b' = b$, and 0 otherwise.
    \end{enumerate}
    
    We say that the VRF satisfies pseudorandomness if for all PPT adversaries $\mathcal{A}$:
    \[
    \text{Adv}_{\mathcal{A}}^{\text{vrf}} := \left|\Pr\left[\mathcal{G}_{\mathcal{A}}^{\text{vrf}}(\lambda) = 1\right] - \frac{1}{2}\right| \leq \text{negl}(\lambda)
    \]
\end{itemize}


    
In our work, we focus on adapting the Dodis-Yampolskiy VRF \cite{hutchison_verifiable_2005}, which computes $y = e(g, \tilde{g})^{1/(sk+x)}$ in bilinear groups, to work efficiently in standard prime-order groups without pairings.

\begin{definition}[Dodis Yampolskiy VRF]
    The Dodis-Yampolskiy (DY) VRF~\cite{hutchison_verifiable_2005} operates in a bilinear group setting with groups $\mathbb{G}_1$, $\mathbb{G}_2$, and $\mathbb{G}_T$ of prime order $p$, and a Type-3 pairing $e: \mathbb{G}_1 \times \mathbb{G}_2 \to \mathbb{G}_T$. Let $g \in \mathbb{G}_1$ and $\tilde{g} \in \mathbb{G}_2$ be generators. The VRF is defined as:

\begin{itemize}
    \item $\mathsf{VRF.Gen}(1^\lambda)$: Sample $sk \sample \mathbb{Z}_p^*$, set $pk = g^{sk}$.
    \item $\mathsf{VRF.Eval}(sk, x)$: Compute $y = e(g, \tilde{g})^{1/(sk + x)}$.
    \item $\mathsf{VRF.Prove}(sk, x)$: Compute $\pi = \tilde{g}^{1/(sk + x)}$.
    \item $\mathsf{VRF.Vfy}(pk, x, y, \pi)$: Check $e(g^{x} \cdot pk, \pi) \stackrel{?}{=} e(g, \tilde{g})$ and $y \stackrel{?}{=} e(g, \pi)$.
\end{itemize}

Security relies on the $q$-DBDHI assumption, ensuring $y$ is pseudorandom.

\end{definition}



\subsubsection{Zero-Knowledge Proofs and Sigma-Protocols}
Our credential binding mechanism relies on zero-knowledge proofs, particularly Sigma-protocols, to verify relations between committed values without revealing them.

A Sigma-protocol is a three-move interactive proof system where:
\begin{enumerate}
    \item The prover $\mathcal{P}$ sends a commitment message $a$.
    \item The verifier $\mathcal{V}$ sends a random challenge $e$.
    \item The prover responds with $z$, and $\mathcal{V}$ accepts if the verification equation holds.
\end{enumerate}
These protocols satisfy:
\begin{itemize}
    \item \textbf{Completeness}: For all $(x,w) \in \mathcal{R}$, an honest prover always convinces the verifier.
    \item \textbf{Special Soundness}: There exists an efficient extractor $\mathcal{E}$ such that, given any statement $x$ and two accepting transcripts $(a,e,z)$ and $(a,e',z')$ with $e \neq e'$, $\mathcal{E}$ can extract a witness $w$ such that $(x,w) \in \mathcal{R}$.
    \item \textbf{Special Honest-Verifier Zero-Knowledge}: There exists an efficient simulator $\mathcal{S}$ that, given a statement $x$ and a challenge $e$, produces a transcript $(a,e,z)$ that is computationally indistinguishable from a real transcript between an honest prover and verifier, without using a witness.
\end{itemize}












\section{Prime-Order VRF from the q-DDHI Assumption}\label{sec:pairing-free-vrf}

The Dodis-Yampolskiy \cite{hutchison_verifiable_2005} VRF provides an elegant solution for generating unique, pseudorandom nullifiers $y$ and their proofs of correctness $\pi$. We start with the question of removing pairings to improve efficiency. DY consists of $(y, \pi)$:
\[
y = e(g, \tilde{g})^{1/(sk+x)} \qquad \pi = \tilde{g}^{1/(sk+x)}
\]

Verification depends on the bilinearity property $e(g^a, \tilde{g}^b)^c = e(g, \tilde{g})^{abc}$, which enables "exponent multiplication" across groups, allowing the transformations:

\begin{align*}
    \begin{array}{rcl}
    e(g^x \cdot pk, \pi) & \stackrel{?}{=} & e(g^{sk+x}, \tilde{g}^{1/(sk+x)}) \\
     & \stackrel{?}{=} & e(g, \tilde{g})^{(sk+x)/(sk+x)} \\
     & = & e(g, \tilde{g})
    \end{array}
    &&
    \begin{array}{rcl}
    y & \stackrel{?}{=} & e(g, \pi) \\
     & \stackrel{?}{=} & e(g,\tilde{g}^{1/(sk+x)}) \\
     & = & e(g, \tilde{g})^{1/(sk+x)}
    \end{array}
\end{align*}

Security relies on the $q$-DBDHI problem which states that given $(g, g^x, g^{x^2}, \ldots, g^{x^q}, \tilde{g})$, no $\PPT$ adversary can distinguish between $e(g,\tilde{g})^{1/x}$ and a uniform element in $\G_T$ with non-negligible advantage , ensuring the VRF outputs maintain pseudorandomness after the adversary has observed $(x',y',\pi')$ pairs.

\subsubsection{The Prime-Order Group Challenge}

Prime-order groups and standard group operations (without such bilinearity property) cannot be used to directly verify the $1/(sk+x)$ relationship with standard cryptographic operations. For example, given $pk  \cdot g^x = g^{sk+x}$, verification attempts to equate or cancel out fail:

\begin{enumerate}
    \item $g^{sk+x} \cdot g^{1/(sk+x)} = g^{sk + x + \frac{1}{sk+x}}$
    \item $\frac{g^{sk+x}}{g^{1/(sk+x)}} = g^{(sk+x)^2-\frac{1}{sk+x}}$
\end{enumerate}

Our insight is to reverse the verification approach. Instead of trying to derive $g^{1/(sk+x)}$ from $g^{sk+x}$ or cancel with a reciprocal, we use a zero knowledge proof $\Sigma$-protocol to verify that $y$ raised to the power $(sk+x)$ equals $g$. In doing so, our pairing-free construction shifts from the $q$-DBDHI assumption to the $q$-DDHI assumption. This gives us the relation:

\[
\mathcal{R}_{\mathsf{DY-PF}} = \left\{ 
\begin{array}{l} 
(\pk, x, y),\\
(sk) 
\end{array}
\ \middle|
\ \begin{array}{l}
pk = g^{sk} \\
y^{sk + x} = g  \\
\end{array} \right\}
\]

\subsection{Construction}\label{sec-dy-pf}

Our VRF operates in a prime-order group $\mathbb{G}$ of order $p$ with generator $g$. The message space is $\mathcal{X} = \mathbb{Z}_p$, the output space is $\mathcal{Y} = \mathbb{G}$, and the proof space is $\Pi = \mathbb{G} \times \mathbb{G} \times \mathbb{Z}_p$. The algorithms are defined as follows:

\begin{itemize}
    \item $\mathsf{VRF.Gen}(1^\lambda) \to (sk, pk)$: Sample $sk \sample \mathbb{Z}_p^*$, compute $pk = g^{sk}$, and output $(sk, pk)$.
    \item $\mathsf{VRF.Eval}(sk, x) \to y$: Compute $y = g^{1/(sk + x)} \in \mathbb{G}$.
    \item $\mathsf{VRF.Prove}(sk, x) \to \pi$: Generate proof $\pi$ using the $\Sigma$-protocol described below.
    \item $\mathsf{VRF.Verify}(pk, x, y, \pi) \to \{0, 1\}$: Output 1 if $\pi$ verifies $y$ correctly per the $\Sigma$-protocol, else 0.
\end{itemize}

\begin{remark}
    Verifying $\VRFVerify(pk, x, \VRFEval(sk, x) \to y) \to 1$ is a naive verification approach without a proof which yeilds a Verifiable Unpredictable Function (VUF), not a VRF because it lacks the mechanism to prove pseudorandomness to a verifier. DY uses pairings to bridge the gap, we replace pairings with a $\Sigma$-protocol. 
\end{remark}

\subsection{Proof Protocol}
\begin{protocol}{DY Prime Order Proof Protocol}{}\label{protocol-pdy-protocol1}
\textbf{Common Input:} $g, pk, y \in \mathbb{G}$, $x \in \mathbb{Z}_p$ \\
\textbf{Prover Input:} $sk \in \mathbb{Z}_p^*$ with $pk = g^{sk}$, $y = g^{1/(sk + x)}$ \\
\textbf{Relation: }
\[
\mathcal{R} = \left\{ (\pk, x, y), (sk) \ \middle| pk = g^{sk} \land y^{sk + x} = g \right\}
\]
\begin{enumerate}
    \item \textbf{Commitment:} Prover samples $r \sample  \mathbb{Z}_p$, computes $T_1 = g^r$, $T_2 = y^r$, sends $(T_1, T_2)$.
    \item \textbf{Challenge:} Verifier samples $c \sample  \mathbb{Z}_p$, sends $c$.
    \item \textbf{Response:} Prover computes $z = r + c \cdot (sk + x)$, sends $z$.
    \item \textbf{Verification:} Verifier checks: $g^z \stackrel{?}{=} T_1 \cdot (pk \cdot g^x)^c$ and $y^z \stackrel{?}{=} T_2 \cdot g^c$
\end{enumerate}
\end{protocol}

\subsection{Security Analysis}

Our construction replaces the stronger information-theoretic uniqueness of DY VRF with (weaker) computational uniqueness via the $\Sigma$-protocol and discrete logarithm assumption.


\subsubsection{Correctness}

Correctness requires that an honest prover’s output $y$ and proof $\pi$ always pass verification. For $pk = g^{sk}$, $y = g^{1/(sk + x)}$, $T_1 = g^r$, $T_2 = y^r$, and $z = r + c(sk + x)$, the verification equations hold:
\begin{align*}
g^z &= g^{r + c(sk + x)} = g^r \cdot g^{c(sk + x)} = g^r \cdot (g^{sk} \cdot g^x)^c = T_1 \cdot (pk \cdot g^x)^c \\
y^z &= y^{r + c(sk + x)} = y^r \cdot y^{c(sk + x)} = y^r \cdot (y^{sk + x})^c = y^r \cdot g^c = T_2 \cdot g^c
\end{align*}

Since $y^{sk + x} = g^{1/(sk + x) \cdot (sk + x)} = g$, both checks pass, confirming correctness.

\subsubsection{Uniqueness}

Uniqueness ensures that, for a fixed $pk$ and $x$, only one $y$ can be successfully verified. In DY, pairings enforce this information theoretically. In P-DY, uniqueness is computational, relying on the discrete logarithm problem.

For a valid $y$, $y^{sk + x} = g$, so $y = g^{1/(sk + x)}$ is unique in $\mathbb{G}$. Suppose an adversary produces $y' \neq y$ with a valid proof $\pi'$. Then $y'^{sk + x} = g$ and $y^{sk + x} = g$, implying $(y'/y)^{sk + x} = 1$. In a prime-order group, $y'/y = g^k$ for some $k \neq 0$, so $y' = y \cdot g^k$. But $y'^{sk + x} = (y \cdot g^k)^{sk + x} = g \cdot g^{k(sk + x)} = g$ requires $g^{k(sk + x)} = 1$, which holds only if $k(sk + x) = 0 \pmod{p}$. For random $sk$ and $x$, $sk + x = 0$ is negligible. Alternatively, if $y'$ corresponds to a different $sk'$ where $pk = g^{sk'}$, finding $sk' \neq sk$ breaks the discrete logarithm assumption.

Thus, producing a distinct verifiable $y'$ is computationally infeasible, ensuring uniqueness.

\subsubsection{Pseudorandomness}

Pseudorandomness requires that $y = g^{1/(sk + x)}$ appears random in $\mathbb{G}$ without knowledge of $sk$, even given other input-output pairs. We rely on the $q$-DDHI assumption, which states that $g^{1/(sk + x)}$ is indistinguishable from random given $(g, g^{sk}, \ldots, g^{(sk)^q})$ for polynomial $q$. 
The $\Sigma$-protocol is zero-knowledge, leaking no information about $sk$ beyond $pk$.

\begin{proof}[Sketch]
    Assume an adversary can distinguish $y$ from random, solving $q$-DDHI. The challenger simulates proofs for $q$ inputs using $g^{sk^i}$ for challenge $x^*$, provides $y^* = g^{a/(sk + x^*)}$ or a random element. A successful distinguished implies a $q$-DDHI solver which is assumed to be a hard problem.
\end{proof}










\section{Anonymous Prime-Order VRFs from the $q$-DDHI}\label{sec:privacy-preserving-vrf}

While our pairing-free VRF construction, presented in Section 3, eliminates the computational overhead of bilinear pairings, it still exposes the public key $pk = g^{sk}$ and input $x$ during verification. This is a limitation for anonymous credential systems, where both the master credential key $sk$ and the context identifier $x$ must remain private to ensure user anonymity. In this section, we address this challenge by developing zero-knowledge proof techniques that enable verification of VRF outputs computed from committed attributes, without revealing sensitive information.

Our approach builds progressively across three key stages:

\begin{enumerate}
    \item \textbf{Proving Knowledge of a Committed Inverse Exponent}: We start with a foundational protocol to prove that a value $y = g^{1/x}$ corresponds to a committed exponent $x$, leveraging the $q$-DDHI assumption. This establishes the base for our next protocols.

    \item \textbf{Proving Knowledge of a Committed Inverse Linear Relation}: We extend this technique to handle linear combinations of committed values, enabling verification of a VRF output $y = g^{1/(sk + x)}$ where $sk$ and $x$ are committed in separate credentials. This deterministic nullifier supports privacy-preserving credential binding and sybil resistance.

    \item \textbf{Proving Knowledge of a Committed Nullifier}: Finally, we introduce a protocol to commit to the VRF output itself (i.e., $\cm_y = g_3^{1/(sk + x)} g^{r_3}$), allowing unlinkable presentations. This probabilistic nullifier ensures that repeated uses of the same credential relationship remain unlinkable while still verifiable.
\end{enumerate}

These protocols collectively transform our prime-order VRF into a privacy-preserving tool suitable for hierarchical anonymous credential systems. In the subsections that follow, we detail each stage, presenting the cryptographic constructions and their security properties. \ref{sec-instantiation} will later demonstrate how these building blocks are instantiated for sybil resistance and revocation in the Multi-Issuer Multi-Credential (MIMC) system.














\subsection{Proving Knowledge of a Committed Inverse Exponent}

The central challenge in constructing a pairing-free VRF lies in verifying the correctness of an inverse relationship, specifically that $y = g^{1/x}$ for committed values, without relying on bilinear pairings. In standard prime-order group cryptography, while computing $g^x$ is straightforward, directly verifying $g^{1/x}$ is not, as pairings typically enable this through $e(g^x, g^{1/x}) = e(g,g)$. Our key insight is to reformulate this verification by proving an equivalent relationship: $y^x = g$. This equivalence holds because if $y = g^{1/x}$, then $y^x = (g^{1/x})^x = g^{(1/x) \cdot x} = g$, and conversely, if $y^x = g$, then $y = g^{1/x}$ (assuming $x \neq 0 \mod q$). This transformation eliminates the need for pairings by enabling verification via standard exponentiation, which can be efficiently proven using zero-knowledge techniques.

The protocol we present leverages this equivalence through a zero-knowledge proof where the prover demonstrates knowledge of the opening of a commitment $\cm = g_1^x g^r$ while simultaneously proving that $y^x = g$. This dual verification ensures that $y$ correctly encodes the inverse of $x$ without revealing $x$, forming a foundation for our pairing-free VRF that balances efficiency and privacy.


\subsubsection{Construction}

We begin with a simplified relation: given a commitment $\cm = g_1^x g^r$ and an element $y = g^{1/x}$, the prover demonstrates knowledge of $x$ and $r$ satisfying both equations, without revealing them. This is linked to the Decisional Diffie-Hellman Inversion (DDHI) assumption—where distinguishing $g^{1/x}$ from a random element given $g, g^x$ is computationally hard—making it a secure and essential starting point for our privacy-preserving construction.


\begin{protocol}{Proving Knowledge of Inverse Exponent}{committed-inverse-exponent}\label{pok-committed-inverse-exponent}
\textbf{Common Input:} Group generators $g_1, g \in \mathbb{G}$, commitment $\cm \in \mathbb{G}$, and element $y \in \mathbb{G}$ \\
\textbf{Prover Input:} Witness $(x, r)$ such that $\cm = g_1^x g^r$ and $y = g^{1/x}$ \\
\textbf{Relation:} 
\[
\mathcal{R} = \left\{ (\cm, y), (x, r) \ \middle|\ \cm = g_1^x g^r \ \land\ y = g^{1/x} \right\}
\]
\begin{enumerate}
    \item \textbf{Commitment:} Prover samples $a_x, a_r \sample \mathbb{Z}_q$ and computes:
    \[
    T_1 = g_1^{a_x} g^{a_r}, \quad T_y = y^{a_x}
    \]
    Sends $(T_1, T_y)$ to the verifier.

    \item \textbf{Challenge:} Verifier samples $c  \sample  \mathbb{Z}_q$ and sends $c$ to the prover.

    \item \textbf{Response:} Prover computes:
    \[
    z_x = a_x + c \cdot x, \quad z_r = a_r + c \cdot r
    \]
    Sends $(z_x, z_r)$ to the verifier.

    \item \textbf{Verification:} Verifier checks:
    \[
    T_1 \cdot \cm^c \stackrel{?}{=} g_1^{z_x} g^{z_r}, \quad T_y \cdot g^c \stackrel{?}{=} y^{z_x}
    \]
\end{enumerate}
\end{protocol}



This protocol achieves two objectives simultaneously:
\begin{enumerate}
    \item The first verification equation ($T_1 \cdot \cm^c \stackrel{?}{=} g_1^{z_x} g^{z_r}$) proves the prover knows a valid opening $(x, r)$ of the commitment $\cm$. This is a standard Schnorr-type proof for Pedersen commitments.
    
    \item The second equation ($T_y \cdot g^c \stackrel{?}{=} y^{z_x}$) verifies that $y^x = g$, which means $y = g^{1/x}$. This is the critical link proving that $y$ is correctly computed as the inverse exponent.
\end{enumerate}


\subsubsection{Security Analysis}

The protocol satisfies the standard security properties of Sigma protocols: completeness, special soundness, and honest-verifier zero-knowledge.

\paragraph{Completeness.} For an honest prover with witness $(x, r)$ satisfying $\cm = g_1^x g^r$ and $y = g^{1/x}$, the verification equations hold as demonstrated in the protocol~\ref{pok-committed-inverse-exponent}.

\paragraph{Special Soundness.} Given two accepting transcripts with different challenges, an extractor $\mathcal{E}$ can compute $x = \frac{z_x - z_x'}{c - c'}$ and $r = \frac{z_r - z_r'}{c - c'}$. The extracted values satisfy both $\cm = g_1^x g^r$ and $y^x = g$, confirming $y = g^{1/x}$.

\paragraph{Honest-Verifier Zero-Knowledge.} There exists a simulator $\mathcal{S}$ that, given only the statement $(\cm, y)$ and a challenge $c$, produces transcripts indistinguishable from real protocol executions by sampling $z_x, z_r \sample \mathbb{Z}_p$ and computing commitment values that satisfy the verification equations.

Detailed proofs of these properties are provided in Appendix~\ref{app:vrf-committed-inverse-exponent}.


\paragraph{Relation to $q$-DDHI Assumption.}  The $q$-DDHI assumption ensures that $g^{1/x}$ is computationally indistinguishable from random elements when $x$ is hidden. However, pseudorandomness requires outputs remain indistinguishable even after seeing multiple input-output pairs from the same secret key, and therefore $y = g^{1/x}$ is not pseudorandom.





























\subsection{Proving Knowledge of a Committed Inverse Linear Relation}

We then extend this to prove a linear relation of inverse exponents $y = g^{1/(sk+x)}$ where $sk$ and $x$ come from different commitments, enforcing a relation $\mathcal{R}_{\mathsf{nullifier}}$ holds. We show the full protocol here \ref{pok-committed-inverse-linear-relation}. 

\[
\mathcal{R}_{\mathsf{nullifier}} = \left\{ 
\begin{array}{l} (\cm_1, \cm_2, y),\\
(sk, x, r_1, r_2) 
\end{array}
\ \middle|
\ \begin{array}{l}
\cm_1 = g_1^{sk} g^{r_1} \\
\cm_2 = g_2^{x} g^{r_2} \\
y = g^{1/(sk + x)} \\
\end{array} \right\}
\]






\subsubsection{Construction}

We now extend our approach to handle linear combinations of committed values. Given commitments $\cm_1 = g_1^{sk} g^{r_1}$ and $\cm_2 = g_2^{x} g^{r_2}$ to values $sk$ and $x$, we want to prove that $y = g^{1/(sk + x)}$ without revealing $sk$, $x$, or the randomness values.

This extension is essential for the credential binding scenario, where $sk$ is a secret key in a master credential and $x$ is a context identifier in a separate credential. The protocol must verify the correct computation of $y$ from these disparate committed values.

\begin{protocol}{Proving Committed Inverse Linear Relation}{}\label{pok-committed-inverse-linear-relation}
\textbf{Common Input:} Group generators $g_1, g_2, g \in \mathbb{G}$, $\cm_1, \cm_2, y \in \mathbb{G}$ \\
\textbf{Prover Input:} Witness $(sk, x, \usk_1, \usk_2)$ such that $\cm_1 = g_1^{sk} g^{\usk_1}$, $\cm_2 = g_2^{x}g^{\usk_2}$ and $ y = g^{1/(sk + x)}$ \\
\textbf{Relation: }
\[
\mathcal{R} = \{(\cm_1,\cm_2, y), (sk, x, \usk_1, \usk_2) \mid \cm_1 = g_1^{sk} g^{\usk} \wedge \cm_2 = g_2^{x}g^{\usk_2} \wedge y = g^{1/(sk + x)}\}
\]
\begin{enumerate}
    \item \textbf{Commitment:} Prover computes:
    \begin{align*}
        a_{sk}, a_x, a_{r_1}, a_{r_2} &\sample \Z_q & T_1 &\gets g_1^{a_{sk}} g^{a_{r_1}} & T_2 &\gets g_2^{a_x} g^{a_{r_2}} & T_y &\gets y^{a_{sk} + a_x}
    \end{align*}
    Sends $(T_1, T_2, T_y)$ to verifier.
    
    \item \textbf{Challenge:} Verifier samples $c \sample \mathbb{Z}_q$ and sends to prover.
    
    \item \textbf{Response:} Prover computes:
     \begin{align*}
        z_{sk} &= a_{sk} + c \cdot sk & z_x &= a_x + c \cdot x &  z_m &= (a_{sk} + a_x) + c \cdot (sk + x)\\   
        z_{r_1} &= a_{r_1} + c \cdot r_1 & z_{r_2} &= a_{r_2} + c \cdot r_2
    \end{align*}
    Sends $(z_{sk}, z_x, z_{r_1} z_{r_2}, z_m)$ to verifier.
    
    \item \textbf{Verification:} Verifier checks:
    \begin{align*}
        T_1 \cdot \cm_1^c &\stackrel{?}{=} g_1^{z_{sk}}g^{z_{r_1}} 
        &
        T_2 \cdot \cm_2^c &\stackrel{?}{=}  g_2^{z_x} g^{z_{r_2}} 
        &
        T_y \cdot g^c &\stackrel{?}{=} y^{z_m} &
        z_m &\stackrel{?}{=} z_{sk} + z_x
    \end{align*}
\end{enumerate}
\end{protocol}


This protocol extends our basic approach in two key ways:
\begin{enumerate}
    \item It simultaneously proves knowledge of openings for two separate commitments ($\cm_1$ and $\cm_2$).
    \item It verifies that $y^{sk+x} = g$, proving $y = g^{1/(sk+x)}$, where the exponent $sk+x$ is a linear combination of values from different commitments.
\end{enumerate}

The additional check $z_m \stackrel{?}{=} z_{sk} + z_x$ ensures consistency between the individual responses and their sum, preventing a malicious prover from using different values in different parts of the proof.

\subsubsection{Security Analysis}

The security analysis follows similar principles to the basic protocol, with the additional complexity of handling two commitments and their linear combination.

\paragraph{Completeness:} For an honest prover, all verification equations hold by similar derivations to the basic case, with the additional consistency check $z_m = z_{sk} + z_x$ holding by construction.

\paragraph{Special Soundness:} Given two accepting transcripts with different challenges, we can extract $sk$, $x$, $r_1$, and $r_2$ satisfying the commitment openings and, crucially, verify through the third equation that $y^{sk+x} = g$, proving $y = g^{1/(sk+x)}$.

\paragraph{Honest-Verifier Zero-Knowledge:} A simulator can generate indistinguishable transcripts by sampling responses randomly and computing commitments that satisfy the verification equations, ensuring no information about the witness is revealed.

This protocol forms the foundation for our credential binding nullifier, allowing us to prove relationships between attributes from different credentials without compromising privacy.





































\subsection{Proving Knowledge of a Committed Nullifier}

A deterministic nullifier $y = g^{1/(sk+x)}$ is necessary for Sybil resistance ensuring a unique, verifiable value for each $(sk,x)$ pair. However, deterministic algorithms create privacy problems with linkability. There are many use-cases for the verifiable connection of $(sk, x)$, such as revocation accumulators, which a user would need to interact with frequently, requiring a probabilistic output that can verify the $(sk+x)$ connection. 

Our solution is to commit to the nullifier rather than revealing it directly:
\[
\cm_{\mathsf{null}} = g_3^{1/(sk+x)} g^{r_3}
\]

We must now prove that the committed value represents the nullifiers $(sk+x)$, we do so with the following relation:


\[
\mathcal{R}_{\mathsf{CommittedNull}} = \left\{ 
\begin{array}{l} 
(\cm_1, \cm_2, \cm_3, \cm_4), \\
(sk, x, r_1, r_2, r_3, r_4) 
\end{array}
\ \middle| \
\begin{array}{l}
\cm_1 = g_1^{sk} g^{r_1} \\
\cm_2 = g_2^{x} g^{r_2} \\
\cm_3 = g_3^{1/(sk + x)} g^{r_3}  \quad \text{\small{The Committed Nullifier}}\\
\cm_4 = \cm_3^{sk + x} g^{r_4} = g_3 g^{r_3 (sk + x) + r_4}
\end{array} \right\}
\]

The auxiliary commitment $\cm_4$ enables verification analogous to our approach in Challenge 1: instead of verifying $y^{sk+x} = g$ directly, we prove that $\cm_3^{sk+x} = g_3$ (modulo some randomness $g^{r_4}$). This algebraic relationship can only hold if $\cm_3$ commits to $g_3^{1/(sk+x)}$, thus verifying the correctness of the committed nullifier without revealing it.

This construction extends our technique from Challenge 2 by applying the exponentiation-inversion verification paradigm entirely within the commitment space. The verification operates on the same mathematical principle ($x \cdot \frac{1}{x} = 1$), but now uses homomorphic properties of Pedersen commitments to prove the relationship between committed values, enabling both unlinkable presentations and verifiable credential binding.



\subsubsection{Construction}\label{sec:committed-nullifier}


In the Multi-Issuer Multi-Credential Attribute-Based Anonymous Credential (MIMC-ABC) system, nullifiers ensure sybil resistance by enforcing uniqueness of context-specific credentials bound to a master credential. However, exposing nullifiers as public values, as in our pairing-free Verifiable Random Function (VRF) construction (Section~\ref{sec-dy-pf}), risks linkability across presentations, compromising user privacy. To address this, we propose a novel zero-knowledge protocol that commits the nullifier within a Pedersen commitment, proving its correctness relative to committed attributes from master and context credentials without revealing sensitive information.

Our goal is to design a Sigma-protocol that proves a commitment $\cm_3 = g_3^{1/(sk + x)} g^{r_3}$ contains the inverse exponent $1/(sk + x)$, where $sk$ and $x$ are attributes committed in $\cm_1 = g_1^{sk} g^{r_1}$ (master credential) and $\cm_2 = g_2^{x} g^{r_2}$ (context credential), respectively. This enables privacy-preserving sybil resistance, allowing nullifiers to be used in applications like set membership proofs without linking user actions. The protocol operates in prime-order groups, avoiding the computational overhead of bilinear pairings, and integrates seamlessly with MIMC-ABC's efficient Sigma-protocol framework.

The novelty of our approach lies in its pairing-free, zero-knowledge proof of a committed inverse linear relation, a significant advancement over prior VRF-based nullifiers that rely on pairings or expose inputs \cite{hutchison_verifiable_2005,tomescu2022utt}. By committing the nullifier, we achieve unlinkability, a critical requirement for anonymous credential systems in regulatory contexts like KYC/AML. Furthermore, our protocol is 33\% faster in evaluation and 60\% faster in verification compared to pairing-based schemes (Section~\ref{sec:performance}), offering practical scalability for real-world deployments.

This contribution is crucial for enabling hierarchical, sybil-resistant anonymous credentials that balance privacy, accountability, and efficiency. It addresses practical challenges in federated identity systems, where users must prove credential relationships without compromising anonymity, and lays the foundation for advanced functionalities like private revocation and accumulator-based proofs.

\begin{protocol}{Proving Committed Nullifier for VRF}{committed-nullifier-vrf}\label{pok-committed-nullifier-vrf}
\textbf{Common Input:} Group generators $g_1, g_2, g_3, g \in \mathbb{G}$, commitments $\cm_1, \cm_2, \cm_3, \cm_4 \in \mathbb{G}$ \\
\textbf{Prover Input:} Witness $(sk, x, r_1, r_2, r_3, r_4)$ such that:
    \[
    \cm_1 = g_1^{sk} g^{r_1}, \quad \cm_2 = g_2^{x} g^{r_2}, \quad \cm_3 = g_3^{1/(sk + x)} g^{r_3}, \quad \cm_4 = \cm_3^{sk + x} g^{r_4} = g_3 g^{r_3 (sk + x) + r_4}
    \]
\textbf{Relation:}
\[
\mathcal{R} = \left\{ 
\begin{array}{l} 
(\cm_1, \cm_2, \cm_3, \cm_4), \\
(sk, x, r_1, r_2, r_3, r_4) 
\end{array}
\ \middle| \
\begin{array}{l}
\cm_1 = g_1^{sk} g^{r_1} \\
\cm_2 = g_2^{x} g^{r_2} \\
\cm_3 = g_3^{1/(sk + x)} g^{r_3} \\
\cm_4 = \cm_3^{sk + x} g^{r_4} = g_3 g^{r_3 (sk + x) + r_4}
\end{array} \right\}
\]
\begin{enumerate}
    \item \textbf{Commitment:} Prover samples $a_{sk}, a_x, a_{r_1}, a_{r_2}, a_{r_3}, a_{r_4} \sample \mathbb{Z}_q$ and computes:
       \[
       T_1 = g_1^{a_{sk}} g^{a_{r_1}}, \quad T_2 = g_2^{a_x} g^{a_{r_2}}, \quad T_3 = g_3^{a_{\beta}} g^{a_{r_3}}, \quad T_4 = \cm_3^{a_{sk} + a_x} g^{a_{r_4}}
       \]
       where $a_{\beta} = 1/(a_{sk} + a_x)$. Sends $(T_1, T_2, T_3, T_4)$ to verifier.
    
    \item \textbf{Challenge:} Verifier samples $c \sample \mathbb{Z}_q$ and sends to prover.
    
    \item \textbf{Response:} Prover computes:
       \[
       z_{sk} = a_{sk} + c \cdot sk, \quad z_x = a_x + c \cdot x, \quad z_{r_1} = a_{r_1} + c \cdot r_1, \quad z_{r_2} = a_{r_2} + c \cdot r_2
       \]
       \[
       z_{r_3} = a_{r_3} + c \cdot r_3, \quad z_{r_4} = a_{r_4} + c \cdot r_4
       \]
       Sends $(z_{sk}, z_x, z_{r_1}, z_{r_2}, z_{r_3}, z_{r_4})$ to verifier.
    
    \item \textbf{Verification:} Verifier checks:
       \[
       T_1 \cdot \cm_1^c \stackrel{?}{=} g_1^{z_{sk}} g^{z_{r_1}}, \quad T_2 \cdot \cm_2^c \stackrel{?}{=} g_2^{z_x} g^{z_{r_2}}, \quad T_3 \cdot \cm_3^c \stackrel{?}{=} g_3^{z_{\beta}} g^{z_{r_3}}
       \]
       \[
       T_4 \cdot \cm_4^c \stackrel{?}{=} \cm_3^{z_{sk} + z_x} g^{z_{r_4}}
       % \cm_4 \stackrel{?}{=} g_3 g^{s} \text{ for some } s \in \mathbb{Z}_q
       \]
\end{enumerate}
\end{protocol}


\subsubsection{Security Analysis}












\section{Performance Evaluation}\label{sec:performance-vrf}

We implemented our constructions \cite{polgar_anonymous_2025} using the arkworks cryptography library \cite{arkworks_contributors_arkworks_2022} in Rust and evaluated performance on a MacBook Air M2 with 16GB RAM. Table~\ref{tab:performance-vrf} compares our constructions on BLS12-381 curve against baseline approaches, focusing on the critical operations of evaluation, proof generation, and verification. Table \ref{tab:performance-vrf-curves} shows our constructions built on different, non-pairing curves.

\begin{table}[ht]
\begin{center}
\caption{VRF Comparison with curve BLS12-381}
\label{tab:performance-vrf}
\begin{tabular}{l@{\hspace{1em}}c@{\hspace{1em}}r@{\hspace{2em}}r@{\hspace{5em}}r@{\hspace{2em}}r}
\toprule
\textbf{Scheme} & \textbf{Pairing} & \multicolumn{2}{c}{\textbf{Eval + Prove (ms)}} & \multicolumn{2}{c}{\textbf{Verify (ms)}} \\
\cmidrule(lr){3-4} \cmidrule(lr){5-6}
& & \textbf{ms} & \textbf{Speedup} & \textbf{ms} & \textbf{Speedup} \\
\midrule
DY$^1$ \cite{hutchison_verifiable_2005}                     & yes & 1.27 &  -      & 2.2   &  -     \\
Our DY-PF \ref{sec-dy-pf}                                   & no  & 0.41 & 3.1x   & 0.70  & 3.1x  \\
\midrule
DY Private \cite{tomescu2022utt}                            & yes & 5.91 &   -     & 6.47  &   -    \\
Our DY-PF-Private \ref{pok-committed-inverse-linear-relation} & no  & 1.08 & 5.5x   & 1.41  & 4.6x  \\
Our DY-PF-Private-ComOut \ref{pok-committed-nullifier-vrf}  & no  & 2.01 & 2.9x   & 1.65  & 3.9x  \\
\bottomrule
\end{tabular}
\par\medskip
\raggedright
\footnotesize{$^1$We use optimized pairing for verification by computing all pairings in Miller Loop format before a single Final Exponentiation, reducing verify time from 2.85(ms) to 2.27(ms), a 1.26x speedup.}
\end{center}
\end{table}

\begin{table}[ht]
\begin{center}
\caption{Performance of our VRF Constructions Across Elliptic Curves (time in ms)}
\label{tab:performance-vrf-curves}
\begin{tabular}{ll@{\hspace{1em}}r@{\hspace{1em}}r@{\hspace{3em}}r@{\hspace{1em}}r}
\toprule
\textbf{Curve} & \textbf{Scheme} & \multicolumn{2}{c}{\textbf{Eval + Prove}} & \multicolumn{2}{c}{\textbf{Verify}} \\
\cmidrule(lr){3-4} \cmidrule(lr){5-6}
& & \textbf{ms} & \textbf{Speedup} & \textbf{ms} & \textbf{Speedup} \\
\midrule
\multirow{3}{*}{BLS12-381} 
& DY-PF  \S\ref{sec-dy-pf} & 0.41 & - & 0.71 & - \\
& DY-PF-Private \S\ref{pok-committed-inverse-linear-relation} & 1.15 & - & 1.08 & - \\
& DY-PF-Private-ComOut \S\ref{pok-committed-nullifier-vrf} & 2.01 & - & 1.65 & - \\
\midrule
\multirow{3}{*}{Ed25519} 
& DY-PF \S\ref{sec-dy-pf} & 0.21 & 2.0$\times$ & 0.37 & 1.9$\times$ \\
& DY-PF-Private \S\ref{pok-committed-inverse-linear-relation} & 0.56 & 2.0$\times$ & 0.56 & 1.9$\times$ \\
& DY-PF-Private-ComOut \S\ref{pok-committed-nullifier-vrf} & 1.04 & 1.9$\times$ & 0.84 & 2.0$\times$ \\
\midrule
\multirow{3}{*}{secp256k1} 
& DY-PF \S\ref{sec-dy-pf} & 0.25 & 1.6$\times$ & 0.42 & 1.7$\times$ \\
& DY-PF-Private \S\ref{pok-committed-inverse-linear-relation} & 0.66 & 1.8$\times$ & 0.66 & 1.6$\times$ \\
& DY-PF-Private-ComOut \S\ref{pok-committed-nullifier-vrf} & 1.29 & 1.6$\times$ & 1.05 & 1.6$\times$ \\
\bottomrule
\end{tabular}
\par\medskip
\raggedright
\footnotesize{Measurements conducted on a MacBook Air M2 with 16GB RAM using the arkworks library \cite{arkworks_contributors_arkworks_2022} in Rust. Speedup is calculated relative to BLS12-381 for each scheme and operation. Times are rounded to two decimal places for clarity.}
\end{center}
\end{table}




Our evaluation reveals several key findings:

\begin{enumerate}
    \item \textbf{Pairing Elimination:} Our DY-PF construction achieves a 3.1× speedup over the original DY VRF by eliminating pairing operations, demonstrating the efficiency benefits of our approach.
    
    \item \textbf{Privacy Preservation Overhead:} Adding privacy preservation through commitments inevitably increases computational costs, but our DY-PF-Private design achieves a 5.5× speedup over comparable pairing-based private VRF schemes.
    
    \item \textbf{Unlinkability Trade-off:} The committed nullifier variant (DY-PF-Private-ComOut) involves additional operations for commitment handling, yet still maintains a 2.9× evaluation speedup and 3.9× verification speedup over pairing-based alternatives.

    \item \textbf{Inefficiency of Pairing Curve Operations} The non-pairing curve operations are from 1.6x - 2x more efficient
\end{enumerate}

These performance improvements have significant practical implications. The verification time of 1.65ms for our committed nullifier means that credential binding can be performed at interactive speeds on standard hardware. This enables real-time verification in applications like authentication systems, doorkey access, and mobile identity solutions.

Even with the additional privacy and unlinkability properties, our CRBN construction remains efficient enough for practical deployment in resource-constrained environments like mobile devices, where the elimination of pairing operations provides particular benefits in terms of battery usage and computational demand.




\section{Instantiation: Anonymous Nullifiers for Sybil Resistance and Revocation}\label{sec-instantiation}

\subsection{Applications}

The CRBN enables several important applications for privacy-preserving identity systems:

\begin{enumerate}
    \item \textbf{Hierarchical Credential Systems:} Users can prove relationships between credentials from different issuers without revealing their identity or enabling tracking.
    
    \item \textbf{Private Revocation:} The nullifier can be used to implement privacy-preserving revocation mechanisms where credentials can be invalidated without compromising user anonymity.
    
    \item \textbf{One-Time Credentials:} Services can issue credentials meant for single use, with nullifiers ensuring they cannot be reused while maintaining privacy.
    
    \item \textbf{Secure Attribute Aggregation:} Organizations can verify attribute relationships across credentials (e.g., "this person's income exceeds their claimed threshold") without learning the underlying values.
\end{enumerate}

These applications demonstrate how CRBN addresses a critical gap in privacy-preserving digital identity: enabling hierarchical credential structures with binding enforceable through zero-knowledge proofs.


\subsubsection{Sybil Resistance}

The CRBN provides sybil resistance through the uniqueness property: for any fixed master credential key $sk$ and context $x$, there exists only one valid nullifier value $g^{1/(sk+x)}$ that will verify correctly. Even with the committed variant, the underlying deterministic value ensures a user cannot create multiple valid credential relationships for the same context.

This uniqueness is rooted in the algebraic structure of the inverse relationship. If a user could produce two different nullifiers $y$ and $y'$ for the same $(sk,x)$ pair, both would satisfy $y^{sk+x} = g$ and $y'^{sk+x} = g$, which implies $(y/y')^{sk+x} = 1$. In a prime-order group, this is only possible if $y = y'$ or $sk+x \equiv 0 \pmod{p}$, the latter occurring with negligible probability.

\subsubsection{Revocation}

Both the deterministic and committed variants protect the privacy of credential attributes. The zero-knowledge property of our protocols ensures that nothing is revealed about $sk$ or $x$ beyond the fact that they satisfy the nullifier relationship.

In the deterministic variant, the nullifier $y = g^{1/(sk+x)}$ is pseudorandom under the $q$-DDHI assumption, appearing as a random group element to any party not knowing $sk$ and $x$. The committed variant provides even stronger privacy by hiding the nullifier value itself.

\subsubsection{Unlinkability}

The committed CRBN variant enables unlinkable presentations through randomized commitments. Each time a user presents their credential relationship, they generate fresh randomness $r_3, r_4$ for commitments $\cm_3$ and $\cm_4$. These commitments appear as new, unrelated values in each presentation, preventing linking across verifications.

The hiding property of Pedersen commitments ensures that $\cm_3$ and $\cm_4$ reveal no information about the underlying deterministic nullifier. Even a verifier who sees multiple presentations of the same credential relationship cannot determine whether they originated from the same user.


\section{Conclusion}

% Could compare my construction with others
% https://eprint.iacr.org/2022/1255 e.g.
% https://xn--2-umb.com/22/nullifiers/#zerocoin-nullifiers







\section{Appendix}



\subsection{Security Analysis - Committed Inverse Exponent}\label{app:vrf-committed-inverse-exponent}

\subsubsection*{Special Soundness.} Given two accepting transcripts $(T_1, T_y, c, z_x, z_r)$ and $(T_1, T_y, c', z_x', z_r')$ with $c \neq c'$, we extract:
\begin{align}
x &= \frac{z_x - z_x'}{c - c'} \\
r &= \frac{z_r - z_r'}{c - c'}
\end{align}

We verify that the extracted values satisfy both required properties. From the first verification equation, we have:
\begin{align}
T_1 \cdot \cm^c &= g_1^{z_x} g^{z_r} \\
T_1 \cdot \cm^{c'} &= g_1^{z_x'} g^{z_r'}
\end{align}

Dividing these equations and using the definition of $\cm$:
\begin{align}
\cm^{c-c'} &= g_1^{z_x - z_x'} g^{z_r - z_r'} \\
(g_1^{x} g^{r})^{c-c'} &= g_1^{z_x - z_x'} g^{z_r - z_r'} \\
g_1^{x(c-c')} g^{r(c-c')} &= g_1^{z_x - z_x'} g^{z_r - z_r'} 
\end{align}

This implies:
\begin{align}
x(c-c') &= z_x - z_x' \\
r(c-c') &= z_r - z_r'
\end{align}

Thus $x$ and $r$ are the unique values that satisfy $\cm = g_1^x g^r$.

For the second verification equation:
\begin{align}
T_y \cdot g^c &= y^{z_x} \\
T_y \cdot g^{c'} &= y^{z_x'}
\end{align}

Dividing these equations:
\begin{align}
g^{c-c'} &= y^{z_x - z_x'} \\
g^{c-c'} &= y^{x(c-c')} \\
g &= y^x
\end{align}

This confirms that $y = g^{1/x}$, proving that any prover producing valid protocol transcripts must know the witness $(x,r)$ satisfying both required relations.

\subsubsection*{Honest-Verifier Zero-Knowledge.} To establish HVZK, we construct a simulator $\mathcal{S}$ that, given the statement $(\cm, y)$ and a challenge $c$, produces a transcript indistinguishable from a real protocol execution without knowing the witness.

The simulator operates as follows:
\begin{enumerate}
    \item Sample $z_x, z_r \sample \mathbb{Z}_p$ uniformly at random
    \item Compute $T_1 = g_1^{z_x} g^{z_r} \cdot \cm^{-c}$
    \item Compute $T_y = y^{z_x} \cdot g^{-c}$
    \item Output the transcript $(T_1, T_y, c, z_x, z_r)$
\end{enumerate}

We verify that this transcript passes verification:
\begin{align}
T_1 \cdot \cm^c &= g_1^{z_x} g^{z_r} \cdot \cm^{-c} \cdot \cm^c = g_1^{z_x} g^{z_r} \\
T_y \cdot g^c &= y^{z_x} \cdot g^{-c} \cdot g^c = y^{z_x}
\end{align}

Since $z_x$ and $z_r$ are uniformly distributed in $\mathbb{Z}_p$ in both real protocols and simulation, the simulated transcript is perfectly indistinguishable from a real transcript, establishing perfect HVZK.