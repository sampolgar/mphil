






Identity System




\begin{figure}
    \begin{center}
    \begin{tabular}{l@{\hspace{5em}}c@{\hspace{5em}}l}
    \multicolumn{3}{l}{$\underline{\mathsf{OrgKeyGen}(1^{\lambda}, 1^\ell)}$} \\[0.5em]
    \multicolumn{3}{l}{$\BG = (\G_1, \G_2, \G_T, e, g, \tilg,p) \sample \BGGen(\secparam), \; \mathsf{ck_m} \sample \mathsf{CM.Setup}(\BG, \secparam, \ell)$}\\[1em]
    \multicolumn{3}{l}{$(\skm, \vkm) \sample \mathsf{RS.KeyGen}(\mathsf{ck_m}), \; \text{ Return } (\oskm, \opkm) = ((\skm),(\vkm, \ckm))$}\\[1em]
    \multicolumn{3}{l}{$\underline{\mathsf{UserKeyGen}(1^{\lambda})}: \usk \sample \Z_p, \text{ Return } \usk$} \\[1em]
    \multicolumn{3}{l}{$\underline{\mathsf{(Obtain, Issue)}}$:}\\[1em]
    \multicolumn{3}{l}{$\pirzero(\cm_1) = \zkpok\{(\cm_1, \usk)| \cm_1 = g_1^0g_2^0g^{\usk}\}$}\\[1em]
    \multicolumn{3}{l}{$\pirverkey(\sk, \vk, \ck) = \zkpok\{(\sk, x, \{y_i\}_{i=1}^\ell) | \sk = g^x \wedge \vk = \tilde{g}^x \bigwedge_{i=1}^\ell (g_i = g^{y_i} \wedge \tilde{g}_i = \tilde{g}^{y_i})\}$}\\[1em]
    $\underline{\mathsf{Obtain}(\uskm, \opkm)}$ && $\underline{\mathsf{Issue(\cmm, \vec{m}, \oskm)}}$ \\[1em]
    If  $\pirverkey(\sk, \vk, \ck)$ fails, return $\bot$ & $\xleftarrow{\pirverkey(\sk, \vk, \ck)}$ & \\[1em]
    $\cm_1 = \CMCom([0,0];\usk)$ & $\xrightarrow{\pirzero(\cm_1)}$ & If $\pirzero(\cm_1)$ fails, return $\bot$ \\[1em]
    \multicolumn{3}{r}{$\cm_2 = \CMCom([\id, \ctx]; 0), \; \cmm = \cm_1 \cdot \cm_2 $} \\[1em]
    If $\cmm \neq \CMCom([\id, \ctx];\usk) \; $ or  & $\xleftarrow{\cmm, \id, \ctx, \sigmam}$ & $u \sample \Z_p$, $\sigmam \sample \RSSign(\cmm, \osk, u)$ \\[1em]
    \multicolumn{3}{l}{If $\RSVer(\sigmam, \cmm, \opk) = 0$, return $\bot$} \\[1em]
    \multicolumn{3}{l}{Else, return $\credm \gets (\sigmam, \cmm, \opkm)$} \\[1em]
    \multicolumn{3}{l}{$\underline{(\mathsf{Show}, \mathsf{Verify}):}$}\\[1em]
    \multicolumn{3}{l}{$\pirsok(\credm') = \zkpok\{(\id, \ctx,\usk') \; | \; \cmm' = \CMCom([\id, \ctx]; \usk') \wedge \RSVer(\sigmam', \opkm) = 1 \; \wedge \; \ctx = "master"\}$}\\[1em]
    $\underline{\mathsf{Show}(\credm)}$ && $\underline{\mathsf{Verify(\sigmam', \cmm', \opkm)}}$ \\[1em]
    \multicolumn{3}{l}{Let $\credm = (\sigmam, \cmm, \uskm, \opkm)$, sample $\usk_\Delta, u_\Delta \sample \Z_p^2$}\\[1em]
    \multicolumn{3}{l}{$\sigmam' = (\sigmamone^{u_\Delta}, (\sigmamtwo \cdot \sigmamone^{\usk_\Delta})^{u_\Delta}) \gets \RSRand(\sigmam, \usk_\Delta, u_\Delta)$}\\[1em]
    \multicolumn{3}{l}{$\cmm' = (\cmm \cdot g^{\usk_\Delta}) \gets \CMRand(\cmm, \usk_\Delta)$, $\usk' = \usk + \usk_\Delta$}\\[1em]
    $\credm' = (\sigmam', \cmm', \usk', u_\Delta)$ & $\xrightarrow{\pirsok(\credm')}$ & If $\pirsok(\credm')$ fails, return 0, else 1\\[1em]
    \end{tabular}
    \end{center}
    \caption{Master Credential Protocol}
    \label{fig:master-cred-protocol}
\end{figure}


\paragraph{Informal Security Analysis}
The two-party process between the user and master credential oracle ensures sybil resistance of unique identifier $\id$; the oracle has access to the user information and checks duplicate issuance within their own identity system. $\User$'s $\usk$ remains hidden via the hiding property of the commitment $\cm_1$ malicious use prevented by $\pirzero$






\newpage
\subsection{Context Credential Protocol}
The context credential issuance protocol enables a user to obtain a context credential linked to their root credential. The Context Credential $\credc$ contains a signature $\sigmac$ over commitment $\cmc = \mathsf{CM.Com}([\id, \ctx]; \uskc)$ issued by $\mathcal{I}_{\mathsf{c}}$


\begin{figure}
    \begin{center}
    \begin{tabular}{l@{\hspace{5em}}c@{\hspace{5em}}l}
    \multicolumn{3}{l}{$\underline{(\mathsf{OrgKeyGen}, \mathsf{UserKeyGen}):}$ proceed analogously to Master Credential} \\[1em] %, outputs are $\ckc, \skc, \vkc, \oskc, \opkc, \uskc$
    \multicolumn{3}{l}{$\underline{\mathsf{(Obtain, Issue)}}$:}\\[1em]
    \multicolumn{3}{l}{$\pirverkey$ proceed analogously to Master Credential}\\[1em]
    \multicolumn{3}{l}{$\pirdisclose(\cmc, \phi) = \zkpok\{(\id, \ctx, \usk)| \cmc = g_1^{\id}g_2^{\ctx}g^{\uskc} \wedge \ctx = "context"\}$}\\[1em]
    \multicolumn{3}{l}{$\pirsok(\credm') = \zkpok\{(\id, \ctx,\usk')| \cmm' = \CMCom([\id, \ctx]; \usk') \wedge \RSVer(\sigmam', \opkm) = 1 \wedge \ctx = "master" \}$}\\[1em]
    \multicolumn{3}{l}{$\pireq(\cmm', \cmc) = \zkpok\{(\id, \ctxm, \ctxc, \uskm, \uskc) | \cmm = \CMCom([\id, \ctxm]; \uskm) \wedge \cmc = \CMCom([\id, \ctxc]; \uskc) \}$}\\[1em]
    $\underline{\mathsf{Obtain}(\uskc, \opkc, \vec{m})}$ && $\underline{\mathsf{Issue(\cmc, \oskc)}}$ \\[1em]
    \multicolumn{3}{c}{$\xrightarrow{\pirsok(\credm'), \pirdisclose(\cmc), \pireq(\cmm', \cmc') }$} \\[1em]
    \multicolumn{3}{r}{If $\pirsok(\credm')$, or $\pirdisclose(\cmc)$, or $\pireq(\cmm', \cmc)$ fails, return $\bot$.} \\[1em]
    If $\cmc \neq \CMCom([\id, \ctx];\uskc) \; $ or  & $\xleftarrow{\cmc, \id, \ctx, \sigmac}$ & Else, $u \sample \Z_p$, $\sigmac \sample \RSSign(\cmc, \oskc, u)$ \\[1em]
    \multicolumn{3}{l}{If $\RSVer(\sigmac, \cmc, \opkc) = 0$, return $\bot$} \\[1em]
    \multicolumn{3}{l}{Else, return $\credc \gets (\sigmac, \cmc, \opkc)$} \\[1em]
    \multicolumn{3}{l}{$\underline{(\mathsf{Show}, \mathsf{Verify}):}$}\\[1em]
    \multicolumn{3}{l}{$\pirsok(\credm') = \zkpok\{(\id, \ctx,\uskm')| \cmm' = \CMCom([\id, \ctx]; \uskm') \wedge \RSVer(\sigmam', \opkm) = 1 \wedge \ctx = "master" \}$}\\[1em]
    \multicolumn{3}{l}{$\pirsok(\credc') = \zkpok\{(\id, \ctx,\uskc')| \cmc' = \CMCom([\id, \ctx]; \uskc') \wedge \RSVer(\sigmac', \opkc) = 1 \wedge \ctx = "context"\}$}\\[1em]
    \multicolumn{3}{l}{$\pireq(\cmm', \cmc) = \zkpok\{(\id, \ctxm, \ctxc, \uskm, \uskc) | \cmm = \CMCom([\id, \ctxm]; \uskm) \wedge \cmc = \CMCom([\id, \ctxc]; \uskc) \}$}\\[1em]
    $\underline{\mathsf{Show}(\credm)}$ && $\underline{\mathsf{Verify(\sigmam', \cmm', \opkm)}}$ \\[1em]
    \multicolumn{3}{l}{Compute $\credm', \credc'$ analogously to Master Credential}\\[1em]
    \multicolumn{3}{c}{$\xrightarrow{\pirsok(\credm'), \pirsok(\credc'), \pireq(\cmm', \cmc')}$} \\[1em]
    \multicolumn{3}{r}{If $\pirsok(\credm')$, or $\pirsok(\credc')$, or $\pireq(\cmm', \cmc')$ fails, return 0, Else 1}\\[1em]
    \end{tabular}
    \end{center}
    \caption{Context Credential Protocol}
    \label{fig:context-cred-protocol}
\end{figure}


\subsection{Intuition of Construction}



% \newpage
% \subsection{Master Credential Issuance}
% The master credential issuance protocol enables a user to obtain their root credential from the Master Credential Oracle $\MCO$ while preserving the privacy of their VRF key $k$ and ensuring accountability. The protocol combines verifiable encryption, Verifiable Random Function, Zero Knowledge Proofs, and Rerandomizable PS Signatures over commitments to achieve Sybil Resistance, Revocation, and Anonymity.

% \begin{figure}
%     \begin{center}
%     \begin{tabular}{l@{\hspace{12em}}c@{\hspace{12em}}l}
%     \multicolumn{3}{l}{$\underline{Setup(1^{\lambda}, 1^n)}$:} \\[0.5em]
%     \multicolumn{3}{l}{System: $(\G_1, \G_2, e, g, \tilg ) \gets BG.Gen(\secparam, p), \; ck_m \gets CM.Setup(BG, \secparam, n)$} \\[1em]
%     \multicolumn{3}{l}{Credential Oracle: $(SK_m, PK_m) \gets PS.KeyGen(ck_m)$} \\[1em]
%     \multicolumn{3}{l}{Auditor: $(SK_A, PK_A) \gets TPKE.KeyGen(ck_m)$} \\[1em]
%     \multicolumn{3}{l}{Auditor setup Revocation List} \\[1em]
%     \underline{User($s$)} && \underline{MCO($SK_M$)} \\[0.5em]
%     \multicolumn{3}{l}{$k_1 \gets \Z_p$, \; $C_1 \gets Com([0,k_1,0,0],r)$}\\[1em]
%     \multicolumn{3}{l}{$\Pi_1 \gets ZKPoK.Prove_{Zeros}(C_1)(k_1, r)$} \\[1em]
%     & $\xrightarrow{C_1, \Pi_1}$ & \\[1em]
%     \multicolumn{3}{r}{If $ZKPoK.Verify_{Zeros}(\Pi_1, C_1) = 0, $ return $ \bot$} \\[1em]
%     \multicolumn{3}{r}{$k_2 \gets \Z_p, \; C_2 \gets Com([s, k_2, "master", attrs], 0)$} \\[1em]
%     \multicolumn{3}{r}{$C_m \gets C_1 \cdot C_2 = Com([s,k_1+k_2,"master", attrs], r)$} \\[1em]
%     & $\xleftarrow{C_2, C_m, s, k_2}$ & \\[1em]
%     \multicolumn{3}{l}{$k \gets k_1 + k_2$} \\[1em]
%     \multicolumn{3}{l}{$\Pi_2 \gets ZKPoK.Prove_{addition}(C_1, C_2, C_m)(k_1, k_2, k, r)$} \\[1em]
%     \multicolumn{3}{l}{$\tau \gets Enc(PK_A, k)$} \\[1em]
%     \multicolumn{3}{l}{$\Pi_3 \gets ZKPOK.Prove_{enc}(C_m)(\tau, k, r)$} \\[1em]
%     & $\xrightarrow{C_1, C_2, C_m, \Pi_2, \Pi_3, \tau}$ &\\[1em]
%     \multicolumn{3}{r}{If $ZKPOK.Verify_{addition}(\Pi_2, C_1, C_2, C_m) = 0, \;$ return $\bot$} \\[0.5em]
%     \multicolumn{3}{r}{If $ZKPOK.Verify_{enc}(C_m)(\Pi_3, PK_A, \tau)  = 0, \;$ return $\bot$} \\[0.5em]
%     \multicolumn{3}{r}{$\sigma_m \gets PS.Sign(SK_M, C_1)$} \\[0.5em]
%     \multicolumn{3}{r}{Store Data Record MCO $(C_m, \sigma_m, \tau, \Pi_2, \Pi_3, C_1, C_2, k_2)$ } \\[1em]
%     & $\xleftarrow{\sigma_m}$ & \\[1em]
%     \multicolumn{3}{l}{If $PS.Verify(PK_A, \sigma_m, C_m) = 1$, Store $Cred_m(\sigma_m, C_m)$} \\[1em]
%     \end{tabular}
%     \end{center}
%     \caption{Master Credential Issuance}
%     \label{fig:master-cred-issuance}
% \end{figure}


% \paragraph{Informal Security Analysis}

% The two-party process between the user and master credential oracle ensures sybil resistance of unique identifier $s$; the oracle has access to the user information and checks duplicate issuance within their own identity system. 
% During VRF key issuance, the anonymity of the master credential is preserved via the secrecy of the VRF key $k$. During the two-party computation, the user's share $k_1$ remains hidden to $\MCO$ via the hiding property of the commitment $C_1$, and malicious commitment usage is prevented by the soundness property of $\Pi_1$. 

% \noindent The user combines  $k_1 + k_2$ to form their VRF key, $\Pi_2$ proves $k_1$ is correctly derived from $C_1$, $k_2$ is derived from $C_2$ and $k$ combines $k_1 + k_2$, $\MCO$'s input to $k$ prevents forgery attempts on the key $k$. The hiding property of the commitments and zero-knowledge property of the proofs ensures correct protocol adherence while maintaining private computation. Revocation is enabled by encryption of the VRF key $k$ with the public key of the Auditor $PK_A$. $\Pi_3$ proves that $\tau$ is an encryption of the committed key $k$. $\tau$ is stored with the credential oracle maintaining privacy during normal operation. Finally, the protocol prevents replay attacks by using interactive zero-knowledge proofs requiring a challenge from the verifier, fresh commitment randomness, and $\MCO$'s input of their share of the VRF key $k_2$ preventing existing transcript reuse.



% \newpage
% \subsection{Context Credential Issuance}
% Context Credential Issuance enables a user to obtain a context-specific credential while proving ownership of a valid master credential. The user first constructs a commitment to their context credential attributes, including their identity $s$ and a deterministic nullifier derived from their VRF key $k$ and the credential context $ctx$. Through zero-knowledge proofs, the user demonstrates their master credential is valid and unrevoked, and proves the context commitment is well-formed with the same identity $s$. The nullifier $\tau$ = $VRF(k,ctx)$ prevents multiple credentials for the same context while maintaining privacy. Upon successful verification, the Context Credential Oracle signs the commitment and records the nullifier.
% \begin{figure}
%         \begin{center}
%         \begin{tabular}{l@{\hspace{12em}}c@{\hspace{12em}}l}
%         \multicolumn{3}{l}{$\underline{Setup(1^{\lambda}, 1^n)}$:} \\[0.5em]
%         \multicolumn{3}{l}{System: $(\G_1, \G_2, e, g, \tilg ) \gets BG.Gen(\secparam, p), \; ck_c \gets CM.Setup(BG, \secparam, n)$} \\[1em]
%         \multicolumn{3}{l}{Credential Oracle: $(SK_c, PK_c) \gets PS.KeyGen(ck_c)$} \\[1em]
%         \underline{User($Cred_m, s, k$)} && \underline{CCO($SK_c$)} \\[0.5em]
%         \multicolumn{3}{l}{$\delta \gets VRF(k, ctx)$} \\[1em]
%         \multicolumn{3}{l}{$r* \sample Z_p, \; C_c \gets Com([s,\delta,ctx,attrs],r*)$} \\[1em]
%         \multicolumn{3}{l}{$\Pi_4 \gets ZKPoK.Prove_{selective-disclosure}(C_c,\delta,ctx,attrs)(s, r*)$} \\[1em]
%         \multicolumn{3}{l}{$r' \sample \Z_p, Cred_{m}' \gets Cred.Rerand(Cred_{m}, r')$} \\[1em]
%         \multicolumn{3}{l}{$\Pi_5 \gets ZKSoK.Prove(Cred_m')(s,k,master,attrs,r')$} \\[1em]
%         \multicolumn{3}{l}{Parse $Cred_m'$ as $C_m', \sigma_m'$} \\[1em]
%         \multicolumn{3}{l}{$\Pi_6 \gets ZKPoK.Prove_{reciprocal}(C_m', C_c,ctx)(s,k,r',r*)$}  \\[1em]
%         \multicolumn{3}{l}{$\Pi_7 \gets ZKPoK.Prove_{equality}(C_m', C_c)(s, r)$} \\[1em]
%         & $\xrightarrow{Cred_m', C_c, \Pi_4, \Pi_5, \Pi_6, \Pi_7}$ & \\[1em]
%         \multicolumn{3}{r}{If} \\[1em]
%         \multicolumn{3}{r}{$ZKPok.Verify_{selective-disclosure}(\Pi_4, C_c)(\delta, ctx, attrs)$ = 1 $\; \wedge$} \\[1em]
%         \multicolumn{3}{r}{$ZKSoK.Verify(\Pi_5, Cred_m')$ = 1 $\; \wedge$} \\[1em]
%         \multicolumn{3}{r}{$ZKPoK.Verify_{reciprocal}(\Pi_6, C_m', C_c, ctx)$ = 1 $\; \wedge$} \\[1em]
%         \multicolumn{3}{r}{$ZKPoK.Verify_{equality}(\Pi_7, C_m', C_c)$ = 1 $\; \wedge$} \\[1em]
%         \multicolumn{3}{r}{$\sigma_c \gets PS.Sign(SK_c, C_c)$} \\[1em]
%         \multicolumn{3}{r}{Store Data Record CCO $(C_c, \sigma_c, \delta, \Pi_4, \Pi_5, \Pi_6, \Pi_7 )$} \\[1em]
%         & $\xleftarrow{\sigma_c}$& \\[1em]
%         \multicolumn{3}{l}{If $PS.Verify(PK_c,\sigma_c, C_c) = 1$, Store $Cred_c(\sigma_c, C_c)$} \\[1em]
%         \end{tabular}
%         \end{center}
%     \caption{Context Credential Issuance}
%     \label{fig:context-cred-issuance}
% \end{figure}







\begin{definition}[Secret Sharing]
    A $(t,n)$ secret sharing scheme $\mathsf{SS}$ is a tuple of $\PPT$ algorithms $(\mathsf{Share}, \mathsf{Combine})$ over message space $x \in X$:
    \begin{itemize}
        \item $\mathsf{Share}^{t,n}(x, r) \torand ([x]_1, \dots, [x]_n)$ takes input $x \in X$, randomness $r$ and outputs $n$ shares $([x]_1, \dots, [x]_n)$
        \item $\mathsf{Combine}^{t,n}([x]_i, \dots, [x]_t) \to x'$ takes a threshold of secret shares $[x]_i$ for $i > t$ as input and combines to form $x'$ the representation of the original message $x' \in X$
    \end{itemize}
\end{definition}

\begin{definition}[Threshold Public-Key Encryption]
A Threshold Public-Key Encryption Scheme $\mathsf{TPK}$ is a set of $\PPT$ algorithms $\mathsf{(KeyGen, Enc, Dec, Verify, Combine)}$ over $\messagespace$: 
    \begin{itemize}
        \item $\mathsf{TPK.Setup}(\secparam, n, t) \torand \{\pk, \vk, (\sk_1, \dots, \sk_n)\}:$ input the $t$ of $n$ threshold, output $\pk$ the public key, $\vk$ the verification key, and $\sk_i$ the shared secret key for each party.
        \item $\mathsf{TPK.Enc}(\pk, m, \rho) \torand \beta:$ input message $m$ and randomness $\rho$, output encryption $\beta$
        \item $\mathsf{TPK.Dec}(\beta, \sk_i)) \to m_i:$ each party decrypts $\beta$ with their shared secret key $\sk_i$
        \item $\mathsf{TPK.Verify}(\pk, \vk , m_i) \to  \bit:$ input $\pk, \vk$ and share of $m_i$, verify $m_i$ was computed correctly from $\pk, \vk$
        \item $\mathsf{TPK.Combine}(\pk, \vk, {m_i}_{i \in \setspace \subseteq [n] s.t. |\setspace| \geq t + 1}) \to m:$ recovers message $m$ given $t + 1$ partial decryptions which verify successfully
    \end{itemize}
\end{definition}



\subsection{Revocation}
Credential revocation is a fundamental challenge in identity management systems. While credentials grant users access to services, there must be mechanisms to invalidate them when necessary. Since the introduction of public key infrastructure, numerous solutions have been proposed to handle certificate revocation such as time-based expiration, usage limits (k-times use), and revocation lists. In the latter approach, a trusted authority manages a whitelist of valid credentials or blacklist of revoked ones, requiring users to prove their credential status with respect to the list.

The challenge becomes more complex in privacy-preserving systems as users must be able to prove revocation status without revealing the credential or its attributes. Furthermore, the revocation list should not leak information about which credentials are valid or revoked. 

\subsubsection{Revocation Scheme}
A revocation scheme enables efficient proofs of credential validity while maintaining privacy of the revocation status. The scheme consists of a revocation authority that manages the revocation state, protocols for revoking credentials, and methods for users to prove their credentials remain valid. A privacy-preserving revocation scheme must satisfy several properties:

\begin{itemize}
    \item Privacy: Users can prove their credential's status without revealing the credential
    \item Unlinkability: Multiple proofs by the same user cannot be linked
    \item Efficiency: Proofs should be succinct and verification efficient
    \item Dynamic Updates: The system supports real-time credential revocation
\end{itemize}

\paragraph{Syntax}
A revocation scheme consists of the following algorithms:

\begin{itemize}
    \item $\revsetup(\secparam) \torand (\ppar, \sk, \pk, \vt):$ Given security parameter $\secparam$, generates system parameters $\ppar$, authority's secret key $\sk$, public key $\pk$, and initial revocation state $\vt$
    
    \item $\revrevoke(\sk, \vt, \cred) \to (\vt', \text{RI}):$ Revokes credential $\cred$, updates revocation state from $\vt$ to $\vt'$, and outputs revocation information RI
    
    \item $\revtokengen(\cred, \vt, \text{RI}) \to \rt:$ Generates a revocation token $\rt$ for credential $\cred$ using the current revocation state $\vt$ and revocation information RI
    
    \item $\revtokenver(\vt, \cred, \rt) \to \bit:$ Verifies revocation token $\rt$ for credential $\cred$ against revocation state $\vt$
\end{itemize}

\subsubsection{Accumulator}
An accumulator allows for compact representation of a set while enabling efficient proofs of membership. Our construction uses a universal accumulator that supports both membership and non-membership proofs. The accumulator maintains a constant-size value regardless of the number of elements in the set, while allowing elements to be dynamically added and removed. For each element, the system can generate succinct witnesses that prove either membership or non-membership in the accumulated set.

\subsubsection{Syntax}
An accumulator $\acu$ is a set of $\PPT$ algorithms $\acu = \mathsf{Setup, Add, Del, VerMem, VerNonMem}$. 
\begin{itemize}
    \item $\acusetup(\secparam) \torand \ppar, \sk, \pk, \vt:$ generates system parameters, takes security parameter $\secparam$ as input, outputs system parameters $\ppar$, secret key $\sk$, public key $\pk$, and initial accumulator value $\vt$
    
    \item $\acuadd(\sk, \vt, \x) \to (\vt', \wx):$ adds element $\x$, takes secret key $\sk$, current accumulator value $\vt$, element $\x$ as input. Outputs updated accumulator value $\vt'$, and membership witness $\wx$
    
    \item $\acudel(\sk, \vt, \x) \to (\vt', \wxhat):$ Deletes element $\x$, takes secret key $\sk$, current accumulator value $\vt$, element $\x$ as input. Outputs updated accumulator value $\vt'$, non-membership witness $\wxhat$ 
    
    \item $\acuvermem(\vt, \x, \wx) \to \bit:$ verifies membership, takes current accumulator value $\vt$, element $\x$, witness $\wx$ as input. Outputs accept/reject
    
    \item $\acuvernonmem(\vt, \x, \wxhat) \to \bit:$ Verifies non-membership, takes current accumulator value $\vt$, element $\x$, non-member witness $\wxhat$ as input. Outputs accept/reject
\end{itemize}

 with additional witness operations $\mathsf{MemWitUpOnAdd/Del, NonMemWitUpOnAdd/Del}$ 


 \subsection{Discussion}
 
The Internet Identity Workshop discussed a problem space summarised by the following problems:
\begin{enumerate}
    \item issuing credentials that are both government and privately issued
    \item retaining accountability in derived credentials, ensuring derived credentials are fit for purpose and have revocation (Proveable Provenance, Linked Data)
    \item combining traditional digital identity with decentralized identity
\end{enumerate}

A user has an Identity linked to multiple credentials, such as a driver's license and university card. Users want to authenticate with various Relying Parties (Verifiers) without being linked between multiple uses of the same service (e.g. a user verifying multiple credentials with 1 service such as a bank requiring proof of multiple credentials linked to an identity), and between uses of different services (e.g. a user presenting their drivers license for age verification on multiple services).

Current decentralized identity systems either don't provide this functionality or provide it at the expense of either accountability or privacy. CanDID stores a map between users multi-layered credentials providing a solution to the problem at the expense of the user's privacy. Other credential systems and pseudonym systems prove equality of hidden attributes in a credential such as name or id, which can more-easily be forged and does not support the hierarchical structure leveraging a highly secure and accountable government identity with not-so secure private credentials.


\noindent \textbf{Credential Chaining}


\noindent \textbf{Pseudonym Systems}
There are 2 main models for Pseudonyms. One where the user has a Master Credential and derives pseudonym, or context credentials from the Master Credential. The applications differ; for example, in \textbf{Model 1}, a user may have their Passport as their Master Credential and wish to use it in a different scenario, such as voting for an election. The user will derive, by themselves, a new credential with the context "voting-2024," which will be verified in the same way as the master credential.
\textbf{Model 2} differs in application scenarios. A context credential represents a credential from a different issuer, for example, a driver's license. During Context Credential issuance, a user will present their Master Credential which will be used to verify the identity of a user and to link the 2 credentials together. During context credential verification, the user may be requested to present just their Context Credential, or perhaps in a high-security verification setting, where a user may need to prove attributes in multiple credentials both Master and Context will need to be presented together. We optimize for this setting while \emph{preserving privacy.}



\noindent \textbf{Pseudonym Model 1: Master Credential, One Issuer, derived Pseudonyms}

SyRA and TACT optimize for Non-Interactivity
They also define context differently to us. Which isn't what CanDID defines context as and doesn't work for the same usescases and CanDID was defined for. 

Previous Methods

\noindent SyRA: Sybil-Resilient Anonymous Signatures  with Applications to Decentralized Identity \cite{crites_syra_2024}
1. enables users to "derive" unlinkable, sybil resistant pseudonyms (signatures) for a context e.g. PRF(sk, ctx) without interacting with the issuer
2. does not store a mapping on the issuer
3. Security properties: Sybil resistance in the context. Anonymity: no information is leaked through their nyms or signatures. Proves UC security for unforgeability, Sybil resilience, privacy, and unlinkability
4. SyRA leaves support for Identity Attributes for future work.

Summary: First, a protocol with issuer creates a user with secret key $s$. $s$ generates a context specific pseudonym, or tag $T$ "that attaches itself to a signature"?

\begin{itemize}
    \item Level 1: $Issue_{isk}(s)$: $VRF_{isk}(s) \to T, \pi_{prf}$ such that $\pi_{prf}$ generates the users keys and is symmetric across $\G_1, \G_2$: This algorithm is computed by the issuer with their secret key $isk$ on identity string $s$ Outputs $T = e(g, \tilde{g})^{1/(s + isk)}$ and $\pi_{prf}$ is $usk = g^{1/(s + isk)} \in \G_1$ and $\widehat{usk} = \tilde{g}^{1/(s + isk)} \in \G_2$. Their verify algorithm is the same as the Dodis Yampolskiy and also verifies the asymmetric keys with bilinear pairing.
    \item Level 2: $Sign_{usk, \widehat{usk}}(ctx, m, ivk)$: $VUF_{usk}(ctx) \to T = e(H(ctx), \widehat{usk})$: This is the "sybil resistant signature". Proof of correctness comes from sigma protocol. During the verify protocol, the 
\end{itemize}

Conclusion: SyRA creates a signature scheme where a user can "sign" on $ctx, m$ from their secret key based on a VRF of their identity and the issuer's key. This does not account for Attribute-based credentials.

Attribute-Based Threshold Issuance Anonymous Counting Tokens \cite{rabaninejad_attribute-based_nodate}
What don't they do that we do?
We avoid Groth Sahai proofs - page 26 they refer to proving the signature scheme with GS proofs. 
They use Naor Pinkas Reingold PRF and verify signature with GS proofs. 
They focus only on deriving credentials / pseudonyms from their

\noindent \textbf{Pseudonym Model 2: Master Credential, Multiple Issuers, Different Pseudonyms}
The Pseudonym Model \cite{goos_pseudonym_2000} presents as an interaction between a User, a Certificate Authority (CA), and a Pseudonym Organisation (O). The user's identity is registered to the CA with their keypair $skU, pkU$, receiving a Master Credential to act as a trust anchor for all pseudonyms. With their Master Credential, Users request \emph{unlinkable} Pseudonyms for other organizations by first proving the knowledge of a Master Credential that verifies with the CA, and the pseudonym requested has the same keypair as the Master Credential. Organizations \emph{blindly} issue Pseudonym credentials on the same keypair as the Master Credential.


\begin{itemize}
    \item \textbf{$MasterCredIssue(skU, pkU, identity, skCA) \to CredM$} is an interactive algorithm run by a user and a credential authority with keypair $skCA, pkCA$. The user is known to the CA and shares their identity and a keypair $skU, pkU$. The $CA$ checks the $skU, pkU$ relation and issues $CredM$, a signature $\sigma_{CA} \gets Sign_{skCA}(pkU)$
    
    \item \textbf{$NymGeneration(CredM, pkCA, Nym, skO) \to CredNym$} is an interactive algorithm run by a user and an organization the user wishes to create a pseudonym with. 
    $Nym1$ is a commitment $Com(skU, pkU, r)$ with randomness $r$, $r$ should be unique per pseudonym. 
    $U$ generates a zero-knowledge proof of knowledge of a new pseudonym $Nym1$ with $skU, pkU$ corresponding to $CredM$, $CredM$ verifies correctly, and $pkU, skU$ are related. 
    \[
    \begin{aligned}
    ZKP
    \{ 
        (skU, pkU, r): Nym &= Com(skU, pkU, r) \; \wedge \\
        Verify_{pkCA}(CredM) &= 1 \; \wedge \\ 
        pkU &= g^{skU}
     \}
    \end{aligned}
    \]
    On successful ZKP verification, algorithm outputs $CredNym \gets Sign_{skO}(Nym)$

    \item \textbf{$NymVerify(CredNym, pkO) \to \bit $} is an interactive algorithm run by a user and a verifier. Recall $CredNym$ is a signature over a commitment $Sign_{skO}(Nym)$. The user randomizes $CredNym' \gets CredNym$ and $Nym' \gets Com(skU, pkU, r)$, and in zero knowledge, proves $CredNym$ verifies correctly with respect to the original signature, and the organisation public key
        \[
        \begin{aligned}
        ZKP
        \{  
            (skU, pkU, r, r'): Nym' &= Com(skU, pkU, r') \; \wedge \\
            \exists \; Nym \text{ such that } Verify_{pkO}(Nym) &= 1 \; \wedge \\ 
            Nym &= Com(skU, pkU, r) \; \wedge \\
            pkU &= g^{skU}
        \}
        \end{aligned}
        \]
\end{itemize}




\newpage
\subsection{NIZK for Sybil Resistant Issuance}
We have $g^{\frac{1}{m}}$ and $g^m$. We want to prove their relationship is reciprocal. We will use this later when proving the output of the Dodis Yampolskiy VRF $g^{\frac{1}{sk + x}}$
Let $m_1 = m$, and $m_2 = \frac{1}{m}$. Therefore, we can prove that $m_1 \cdot m_2 = 1$ 
\[ 
    \begin{aligned}
        C_1 &= g^{m_1}h^{r_1} \\
        C_2 &= g^{m_2}h^{r_2} \\
        C_3 &= C_1^{m_2}h^{r_3} \\ 
        C_4 &= h^{r_1m_2 + r_3} \\ 
    \end{aligned}
\]

We use $C_1, C_2$ in a zero-knowledge proof protocol to prove the relation with public elements $C_1, C_2, g, h$

\[
ZKP
    \left\{ 
    (m_1, m_2, r_1, r_2): C_1 = g^{m_1}h^{r_1} \wedge C_2 = g^{m_2}h^{r_2} \wedge m_1 \cdot m_2 = 1
    \right\}
\]

\pcb{
\prover[m_1, m_2, r_1, r_2] \< \< \verifier[C_1, C_2, g, h]  \\[0.1\baselineskip][\hline]
\<\< \\[-0.5\baselineskip]
\pclinecomment{$C_1 = g^{m_1}h^{r_1}, C_2 = g^{m_2}h^{r_2}$} \\
{\{\rho_i\}_{i=1}^4, \{\beta_i\}_{i=1}^2}  \sample \mathbb{Z}_q^6 \<\< \\
T_1 \gets g^{\beta_1}h^{\rho_1} \<\< \\
T_2 \gets g^{\beta_2}h^{\rho_2} \<\< \\
\pclinecomment{generate interim elements} \\
C_3 \gets C_1^{m_2}h^{r_3} \<\< \\
T_3 \gets C_1^{\beta_2}h^{\rho_3} \<\< \\
r_4 \gets r_1m_2 + r_3 \<\<  \\
C_4 \gets h^{r4} \<\< \\
T_4 \gets h^{\rho_4} \<\< \\
\< \sendmessageright* {\{C_i, T_i\}_{i=1}^4} \< \\
\< \sendmessageleft*{e} \< e \sample \mathbb{Z}_q \\
z_{m1} = \beta_1 + e \cdot m_1 \<\< \\
z_{r1} = \rho_1 + e \cdot r_1 \<\< \\
z_{m2} = \beta_2 + e \cdot m_2 \<\< \\
z_{r2} = \rho_2 + e \cdot r_2 \<\< \\
z_{r3} = \rho_3 + e \cdot r_3 \<\< \\
z_{r4} = \rho_4 + e \cdot r_4 \<\< \\
\< \sendmessageright*{\{z_{mi}\}_{i=1}^2, \{z_{ri}\}_{i=1}^4 } \< \\
\<\< C_1^e \cdot T_1 \stackrel{?}{=} g^{z_{m1}} h^{z_{r1}}\\
\<\< C_2^e \cdot T_2 \stackrel{?}{=}  g^{z_{m2}} h^{z_{r2}}\\
\<\< C_3^e \cdot T_3 \stackrel{?}{=}  C_1^{z_{m2}} h^{z_{r3}}\\
\<\< C_4^e \cdot T_4 \stackrel{?}{=}  h^{z_{r4}}\\
\<\< C_3/C_4 = g \\
}


