\section{Intro}
\subsection{Problem}
Our research addresses the secure and private verification of complex identity assertions using multiple digital credentials from different issuers. The system ensures all credentials are bound to the same identity and, additionally, supports credential relationship binding to prove structured relationships between credentials while preserving privacy through anonymous authentication.

% We introduce the Multi-Issuer Multi-Credential Attribute-Based Anonymous Credential (MIMC-ABC) system, a novel framework for privacy-preserving identity verification. Unlike single-issuer systems like Idemix, MIMC-ABC enables users to combine credentials from multiple issuers without coordination, using rerandomizable Pointcheval-Sanders signatures and commitments. Our system supports expressive predicates (e.g., "age > 18 AND degree = 'BS'") via zero-knowledge proofs. We prove unforgeability and anonymity—even against malicious issuers—in the Algebraic Group Model, addressing key limitations in prior work and aligning with emerging digital identity needs.

\subsubsection{Problem}

Non-digital identity interactions 

The privacy of non-digital identity interactions is often overlooked. Although users may need to present multiple physical identity documents to satisfy a verification requirement, oftentimes, our identity documents will be verified in plain sight and not digitally recorded. During the interaction, the verifier will check identity binding (that both identity documents are for the same person) and that the user provided different types of identity documents. This interaction is anonymous in many ways and unlinkable. 

Traditional identity systems fail to preserve the privacy of the user but retain accountability of the user 
Traditional systems fail to balance privacy, security, and accountability in these multi-issuer scenarios.

\subsubsection{Key dimensions of the problem}
\begin{itemize}
    \item \textbf{Multi-Issuer Multi-Credentials} The need for MIMC stems from the need to combine credentials issued by various issuers such as a government, university, or private issuers and combine multiple credentials together such as having a valid driver's license and healthcare card to satisfy a government requirement. 

    \item \textbf{Identity binding} Ensuring all credentials in a presentation belong to the same identity without compromising privacy or requiring issuer coordination. Without Identity Binding, an attacker could mix credentials from different individuals to falsely satisfy a verification requirement. Especially important in a multi-issuer setting where different users may have equivalent attributes 

    \item \textbf{Credential Relationship Binding}: Beyond linking credentials to a single identity, users often need to prove structured relationships between credentials (e.g., one credential derived from another or a dependency between them). This property supports advanced use cases, such as nullifiers for Sybil-resistant systems or hierarchical credential verification.

    \item \textbf{Anonymity} Users need to present credentials anonymously, ensuring that different presentations (e.g., to different service providers) cannot be linked to the same individual unless intended and that the underlying credential values not used openly. This protects against tracking and profiling, a growing concern in digital systems. preventing different presentations from being linked to the same individual while maintaining essential security properties


\end{itemize}

\subsection{Related Work}
Compare with TACT, Coconut, Idemix, how we improve on them

\subsection{Motivation}



Traditional centralized identity systems expose users to privacy risks (e.g., data breaches) and lack flexibility for multi-issuer scenarios. Existing anonymous credential systems, while privacy-focused, often assume a single issuer or fail to efficiently integrate multiple credentials with features like Sybil resistance and revocation. As digital identity frameworks, such as the EU’s Mandatory Digital Identity Wallet, push for privacy-preserving solutions, there is an urgent need for a system that supports the complexity of real-world identity use cases—where users juggle multiple online credentials—while ensuring security, privacy, and accountability


\subsection{Contributions}

\begin{enumerate}
    \item Extend the rerandomizable signature from \cite{tomescu2022utt} 
    We prove the commitment is position-binding and extend the signature scheme with an algorithm to verify the correctness of the issuer's secret key, verification key, and commitment key. We prove the construction is $\EUFCMA$ secure in the algebraic group model. We then show our optimized version achieves a 10\% reduction in overall prove and verify times to previous construction. 
    
    \item We formalize Multi-Issuer, Multi-Credential Attribute-Based Anonymous Credentials (MIMC-ABC), introducing game-based security definitions tailored to multi-issuer challenges. These include cross-credential unlinkability, identity binding, and credential relationship binding. We construct a $\MIMCABC$ system using a variant of Pointcheval-Sanders (PS) signatures and prove its security in the Algebraic Group Model (AGM). In addition, our system ensures anonymity against malicious issuers

\end{enumerate}







\section{Preliminiaries}
We use a rerandomizable commitment and signature scheme. 

\subsubsection{Rerandomizable Signature}\label{sig-construction}
We assume the existence of a commitment key $\ck$ from $\mathsf{CM.Setup}$ as input into our rerandomizable signature scheme $\mathsf{RS}$. We copy the algorithm below for convenience.
\begin{itemize}
    \item $\mathsf{CM.Setup}(\secparam, \ell, (y_i, \ldots, y_{\ell} \in \Z_p^{\ell})) \to \ck:$  
    Sample $(g, \tilde{g}) \sample \G_1 \times \G_2$, For $i \in [1,\ell]$: Compute $g_i = g^{y_i}$ and $\tilde{g}_i = \tilde{g}^{y_i}$. Return $\ck \gets (g, (g_1,\ldots,g_\ell), \tilde{g}, (\tilde{g}_1,\ldots,\tilde{g}_\ell))$
    
    \item $\mathsf{RS.KeyGen}(\secparam, \ck) \to (\sk, \vk):$ 
        Retrieve $(g, \cdot, \tilde{g}, \cdot)$ from $\mathsf{ck}$,
        Sample $x \sample \Z_p$,
        Set $(\sk, \vk) \gets (g^x, \tilde{g}^x)$, return $(\sk, \vk))$
        % Return $(\mathsf{sk} = (x,g), \mathsf{pk} = (\mathsf{pp}, \mathsf{vk}, \mathsf{ck}))$
    
    \item $\mathsf{RS.Sign}(\mathsf{sk}, \mathsf{cm}; u) \to \sigma:$ 
        Let $h \gets g^u$
        Return $\sigma \gets (h, (\sk \cdot \mathsf{cm})^u)$
    
    \item $\mathsf{RS.Rerand}(\sigma, r_\Delta, u_\Delta) \to \sigma':$
        Parse $\sigma$ as $(\sigma_1, \sigma_2)$
        Set $\sigma_1' \gets \sigma_1^{u_\Delta}$
        Set $\sigma_2' \gets (\sigma_2 \cdot \sigma_1^{r_\Delta})^{u_\Delta}$
        Return $\sigma' \gets (\sigma_1', \sigma_2')$
    
    \item $\mathsf{RS.Ver}(\vk, \cm, \sigma) \to \bit:$
        Parse $\sigma$ as $(\sigma_1, \sigma_2)$, The prover $\Prover$ runs a Proof of Knowledge protocol with the following relation 
    \[
        \mathcal{R} \gets \mathsf{PoK}\{(m_1,\ldots,m_\ell, r + r_\Delta): 
    \]
    \[
         e(\sigma_2', \tilde{g}) = e(\sigma_1', \vk)\cdot e(\sigma_1', \widehat{\cm}') \quad \wedge \quad
        e(\cm', \tilde{g}) = e(g, \widetilde{\cm}') \quad \wedge \quad
        \cm' = g^{r + r_\Delta} \prod_{i=1}^\ell g_i^{m_i}
        \}
    \]

        \item $\mathsf{RS.VerKey}(\sk, \vk, \ck) \to \bit:$ verifies the correctness of the issuers secret and verification key $(\sk, \vk)$ and commitment key $\ck$:
        \[
        \mathcal{R}_{\mathsf{verkey}} = \{\pk = (\vk, \ck),(\sk, x, \{y_i\}_{i=1}^\ell) | sk = g^x \wedge vk = \tilde{g}^x \bigwedge_{i=1}^\ell (g_i = g^{y_i} \wedge \tilde{g}_i = \tilde{g}^{y_i})\}
        \]
        
\end{itemize}

\subsection{Rerandomizable Commitment}
We instantiate a dual-group Pedersen Vector Commitment scheme with groups $\G_1, \G_2$ to enable efficient verification within our signature construction. For commitments $\cm \in \G_1, \widetilde{\cm} \in \G_2$, we verify consistency via the pairing relation $e(\cm, \tilde{g}) = e(g, \widetilde{\cm})$.

Let $\G_1, \G_2$ be cyclic groups of prime order $p$ with an efficient Type-3 pairing $e: \G_1 \times \G_2 \to \G_T$. For message vector $\vec{m} = (m_1, \ldots, m_\ell) \in \Z_p^\ell$, our rerandomizable commitment scheme consists of the following algorithms:

\begin{itemize}
    \item $\mathsf{CM.Setup}(\secparam, \ell) \to \ck$:
    Sample generators $(g, \tilde{g}) \sample \G_1 \times \G_2$
    For $i \in [1,\ell]$: Sample $y_i \sample \Z_p$, compute $(g_i, \tilde{g}_i) \gets (g^{y_i}, \tilde{g}^{y_i})$
    Return $\ck \gets (g, (g_1,\ldots,g_\ell), \tilde{g}, (\tilde{g}_1,\ldots,\tilde{g}_\ell))$
    
    \item $\mathsf{CM.Com}(\ck, \vec{m}) \to (\cm, \widetilde{\cm}, r)$:
    Parse $\ck$ as $(g, (g_1,\ldots,g_\ell), \tilde{g}, (\tilde{g}_1,\ldots,\tilde{g}_\ell))$
    Sample $r \sample \Z_p$
    Compute $\cm \gets g^r \prod_{i=1}^\ell g_i^{m_i}$ and $\widetilde{\cm} \gets \tilde{g}^r \prod_{i=1}^\ell \tilde{g}_i^{m_i}$
    Return $(\cm, \widetilde{\cm}, r)$
    
    \item $\mathsf{CM.Rerand}(\ck, \cm, \widetilde{\cm}, r_\Delta) \to (\cm', \widetilde{\cm'})$:
    Parse $\ck$ as $(g, \cdot, \tilde{g}, \cdot)$
    Compute $\cm' \gets \cm \cdot g^{r_\Delta}$ and $\widetilde{\cm'} \gets \widetilde{\cm} \cdot \tilde{g}^{r_\Delta}$
    Return $(\cm', \widetilde{\cm'})$

    \item $\mathsf{CM.Open}$
\end{itemize}







\section{Multi Issuer Multi Credential Anonymous Credentials (MIMC-ABC)}\label{sec:mimc}


\subsection{Notation}
We base our Multi Issuer, Multi Credential Multi-show Attribute based Anonymous Credentials off the model in \cite{fuchsbauer_structure-preserving_2019} and extend it to support rerandomizable signatures over commitments and predicate-based zero-knowledge proof verification allowing users to prove statements about their committed and signed attributes without revealing any additional information.

\subsection{Predicate Satisfaction}
We define a predicate $\phi$ as a boolean function over an attribute vector $\vec{m}$, formally  $\phi: \mathcal{M} \rightarrow \{0,1\}$, where $\mathcal{M}$ is the space of the attribute vectors. 
For a credential with attributes $m = [\id, \ctx, \attrs]$, we say that "$m$ satisfies $\phi$", denoted as $\phi(m) = 1$, if the boolean function evaluates to true on the attributes.
For example, the predicate $\phi_{master} = \ctx = "master"$ is satisfied by $\vec{m} = [\id="123", \ctx="master", \attrs]$. Our system supports complex predicates such as $\phi = age > 18 \wedge country = US$ enabling expressive policies beyond simple equality checks. In our unforgeability definition, predicate satisfaction ensures an adversary cannot forge a proof for a predicate they do not legitimately satisfy beyond reusing existing credentials in a legimitate way.

\subsection{Syntax}
\begin{definition}[MIMC-ABC System] A Multi-Issuer Multi-Credential Attribute-based Anonymous Credential system consists of the following $\PPT$ algorithms:
    \begin{itemize}
    \item $\mathsf{Setup}(\secparam) \to (\ppar)$ Takes security parameter $\lambda$ in unary, outputs public parameters $\ppar$.
    
    \item $\mathsf{OrgKeygen}(\ppar, \ell) \to (\osk, \opk)$: Is a probabilistic algorithm that takes public parameters $\ppar$ and $\ell$ the upper bound of credential attributes. Outputs organisation's keypair $(\osk, \opk)$
    
    % \item $\mathsf{UserKeyGen}(\ppar) \to (\usk)$: Is a probabilistic algorithm that takes public parameters $\ppar$, outputs user's secret key $\usk$ unique to the credential
    
    \item $(\mathsf{Obtain}(\vec{m}, \opk, \aux), \mathsf{Issue}(\osk, \cm, \aux)) \rightarrow (\cred, \bot)$ is an interactive protocol between a user and an issuing organization. The user inputs their message vector $\vec{m} = [\id, \ctx, \attrs]$ containing a unique identifier $\id$ and context $\ctx$. User generates $\usk \sample Z_p$, commits to their messages $\cm \gets \CMCom(\vec{m}; \usk)$. The issuer inputs their secret key $\osk$. The protocol outputs a credential $\cred$ containing $(\sigma, \cm)$ to the user and $\bot$ to the issuer.    
    
    \item $(\mathsf{Show}(\{\credi\}, \{\uski\}, \phi), \mathsf{Verify}(\{\credi'\}, \pi)) \rightarrow \{0,1\}$ is an interactive protocol between a user and verifier. The user runs $\mathsf{Show}$ with their credentials (signatures and paired commitments), and secret keys. The user rerandomizes their credentials and commitments and computes a proof $\pi$ that satisfies the predicate $\phi$.
    $\Verify$ is run by the verifier, which takes input from the randomized credentials $\cred_i'$, randomized commitments $\cmi'$, and predicate, proof pair $\phi, \pi$. The protocol outputs 1 if verification succeeds, 0 otherwise.
    \end{itemize}
\end{definition}

\newpage
\subsection{Security}
% Intuition of our security. 

% Here i Can talk about the different attack vectors and how the security of our system changes between single issuer, single credential, to multi credential to multiple issuer.

\subsubsection{Security Properties}

\begin{itemize}
    \item Correctness ensures an honest user with valid credentials can always generate a proof for any predicate their credentials satisfy which will verify with high probability

    \item Unforgeability prevents a malicious user, or colluding users, from creating valid proof for new forged credentials, misuse of legitimately issued ones, or unauthorized combination of credentials they don't own.

    \item Anonymity protects user privacy, ensuring proofs reveal only that the predicate is satisfied, even if adversaries control the issuers or define predicates. 
\end{itemize}

To model the adversary’s capabilities and the system’s state, we introduce the following lists and oracles:


\noindent\textbf{Lists}
\begin{itemize}
    \item $\HU$: The set of honest users whose secret keys remain unknown to the adversary $\adv$
    \item $\CU$: The set of corrupt users whose secret keys are known to the adversary $\adv$
    \item $\CRED_j$: A list tracking all credentials issued by issuer $j$, where each credential is associated with a user and their attributes
    \item $\OWNR$: A mapping from each credential to its owning user, i.e., $\OWNR[\cred] = i$ if credential $\cred$ belongs to user $i$
    \item $\SHOW$: A list tracking all credential show outputs (\{\})
\end{itemize} 

\noindent\textbf{Oracles}
\begin{itemize}
    \item $\OHU()$: Creates a new honest user $i$, adds them to $\HU$, and returns $i$
    \item $\OCU(i)$: Corrupts user $i$ by moving them from $\HU$ to $\CU$, revealing their secret keys (e.g., commitment openings) and all credentials ${\cred}$ owned by $i$
    \item $\OOBTAIN(i, j, \vec{m})$: Issues a credential $\cred$ from issuer $j$ to user $i$ for the attribute vector $\vec{m}$, provided $i \in \HU$. The credential is added to $\CRED_j$, and $\OWNR[\cred]$ is set to $i$
    \item $\OSHOW(i, \phi)$: Generates a proof $\pi$ that the credentials of user $i$ satisfy the predicate $\phi$, provided $i \in \HU$ and the credentials meet the condition $\phi$. $\SHOW \cup \SHOW \{i, \pi\}$
\end{itemize} 


\paragraph{Correctness:} A MIMC-ABC system is correct if, when all parties follow the protocol honestly, a user can successfully prove a true statement about their credentials to a verifier. Specifically, for all honestly generated public parameters, keys, credentials, and predicates satisfied by the user’s attributes, the verification process accepts the proof with overwhelming probability. 

    \begin{itemize}
        \item \textbf{Setup:} Challenger $\AdvC$ runs $\Setup(\secparam) \to \ppar$
        \item \textbf{Issuer Keys:} For each issuer $j$ in a set of issuers $\{j\}$, run $\OrgKeyGen(\ppar, \ell) \to (\osk_j, \opk_j)$.
        \item \textbf{Credential Issuance: } For a set of message vectors $\{m_k\}$, each $m_k = [\id, \ctx, \attrs, \usk_k]$ with the same $\id$. User runs $\UserKeyGen(\ppar) \to \usk_k$ and $\Obtain(\ppar, \opk_j, m_k, \aux),\Issue(\osk_j, \cm_k, \aux) \to \{\cred_k\}$. 
        \item \textbf{Proof Generation:} User runs $\Show(\{\cred_k'\}, \{\cm_k'\}, \phi, \pi)$ where $\{\cred_k'\}$ and $\{\cm_k'\}$ are rerandomized credentials and commitments.
        \item \textbf{Winning Condition:} Correctness holds if $\Verify(\{\cred_k'\}, \{\cm_k'\}, \phi, \pi) = 1 $ with $\Pr = 1-\negl[\lambda]$
    \end{itemize}
More formally,
\begin{definition}[Correctness]
    \[
        \Pr \left[ 
            \Verify(\{\cred_k'\}, \{\cm_k'\}, \phi, \pi) = 1 \mid \text{all steps honest} \wedge \phi(\{m_k\}) = 1
        \right] = 1 - \negl[\lambda]
    \]
\end{definition}















\paragraph{Unforgeability:} A MIMC-ABC system is unforgeable if no probabilistic polynomial-time (PPT) adversary can produce a valid proof for a predicate that they cannot legitimately satisfy, based on the credentials they have obtained or corrupted. This prevents \emph{forging credentials} or \emph{proving false statements} about them including faking identity binding and credential relationships when stated by $\phi$.


\begin{definition}[Unforgeability]
A MIMC-ABC system is unforgeable if for all PPT adversaries $\mathcal{A}$, there exists a negligible function $\negl$ such that:
\[
\mathsf{Adv}\left[\mathrm{Game}^{\mathsf{\UNF}}_{\MIMCABC, \adv}(\lambda) = 1\right] \leq \negl[\secparam]
\]
\end{definition}

   


\paragraph{The intuition for the forgery success condition}: The adversary's forgery is successful if their proof verifies correctly \emph{and} the credentials used in the forgery cannot be traced back to a single corrupted user. The trivial forgery is one where the adversary corrupts a user and verifies a statement with their legitimately issued credentials. The adversary can win by combining credentials from multiple corrupt users to create valid proofs, combining credentials from corrupt users with newly forged credentials, and lastly creating entirely forged credentials. This is where our security properties, Identity Binding, and Credential Relationship Binding stem from.

\begin{remark}
    For \emph{identity binding}, if $\phi^*$ requires all $\id$ to match, $\AdvA$ can't mix credentials from different $\id$'s. For \emph{credential relationship binding}, if $\phi^*$ requires a specific relationship, for example $\cred_1$ contains $\CMCom([\id, \ctx="passport", \attrs]) \wedge \cred_2$ contains $\CMCom([\id, \ctx="driversLicense", \attrs])$ then $\AdvA$ can't win with different $\ctx$ or use something in $\attrs$ to satisfy $\phi^*$
    
\end{remark}

\newpage
\paragraph{Anonymity: }A MIMC-ABC system provides anonymity if no PPT adversary can determine which user’s credentials were used in a proof, even if the adversary controls the issuers and chooses the messages and predicates. This ensures that presentations reveal only what the predicate explicitly requires, protecting user privacy.

\paragraph{Intuition}: the challenger sets up the game by picking a random bit $b \sample \bit$, which decides whether it uses "Alice or Bob's" credential in the game. Based on the bit, the challenger generates a credential "show" proof and presents it to the adversary. The adversary's guess should be no better than guessing.


\begin{definition}[MIMC-ABC Anonymity]
A MIMC-ABC system provides anonymity if, for all PPT adversaries $\adv$, the advantage in the following experiment is negligible:
\[
\mathsf{Adv}^{\mathsf{anon}}_{\adv}(\secparam) = \left| \Pr[\mathrm{Game}^{\mathsf{anon-1}}_{\MIMCABC, \adv}(\secparam) = 1] - \Pr[\mathrm{Game}^{\mathsf{anon-0}}_{\MIMCABC, \adv}(\secparam) = 1] \right| \leq \negl(\lambda)
\]
\end{definition}
\begin{pcvstack}[boxed]
\begin{pchstack}
         \begin{pcvstack}[boxed]
         \procedure[]{$\mathrm{Game}^{\mathsf{\UNF}}_{\MIMCABC, \adv}(\secparam)$}{%
            \pccomment{Challenger Setup} \\
            \text{Initialize } \HU \gets \emptyset, \CU \gets \emptyset, \\
            \CRED_j \gets \emptyset \text{ for each $j$}, \OWNR \gets \{\} \\
            \ppar \gets \Setup(\secparam), (\osk_j, \opk_j) \gets \OrgKeyGen(\ppar) \\
            \pccomment{$\AdvA$ queries oracles} \\
            \AdvA^{\OHU, \OCU, \OOBTAIN}(\opk_j) \\
            \pccomment{Forgery} \\
            \AdvA \text{ outputs } (\{\cred_k'^*\} = (\{\sigma_k'^*, \cm_k'^*\}) ) \\
            \pccomment{Winning Condition} \\
            \Verify(\{\cred_k'^*\}, \phi^*, \pi^*, \{\opk_j\}) = 1 \; \wedge \\
            \t \forall k, \OWNR[\{\cred_k'^*\}] \neq i \in \CU \quad \pclinecomment{Version 1}\\
            \t \nexists i \in \CU : \phi^*(\vec{m}_{i,k}) = 1 \quad \pclinecomment{Version 2}\\
            \pccomment{i.e. the set of all $\{\cred_k'^*\}$} \\
            \pccomment{cannot belong to the same corrupt user} \\
        }
    \end{pcvstack}
     \begin{pcvstack}[boxed]
     \procedure[]{$\mathrm{Game}^{\mathsf{\ANON}}_{\MIMCABC, \adv}(\lambda)$}{%
            \ppar \gets \Setup(\secparam), \HU, \gets \emptyset, \CU \gets \emptyset \quad \pclinecomment{Challenger $\AdvC$ Setup} \\
            \{\osk_j, \opk_j\} \gets \AdvA(\OrgKeyGen(\ppar)) \text{ for each issuer $j$}. \\
            \text{For $i$ in } \bit: \qquad \pclinecomment{$\AdvC$ initializes two honest users }\\
            \t \usk_i \gets \UserKeyGen(\ppar), \HU \gets \HU \cup \{i\}, \\
            \t \quad i \text{ has } \vec{m} \text{ such that } \phi(\vec{m}) = 1 \\
            \t \cm_i \gets \CMCom(\vec{m}_i; \usk_i),  \cred_i \gets \Issue(\osk, \cm_i) \\
            \AdvA^{\OHU, \OCU, \OOBTAIN, \OSHOW}(\{\osk_j, \opk_j\} ) \qquad \pclinecomment{Learning Phase} \\
            (i_0, i_1, \phi) \gets \AdvA() \qquad \pclinecomment{Challenge Phase}\\
            \text{Assert } i_0, i_1 \in \HU \setminus \CU, \quad \wedge \quad \phi(\vec{m}_{i_0}) = 1, \phi(\vec{m}_{i_1}) = 1 \\
            b \sample \bit \quad \pclinecomment{$\AdvC$ samples random bit}\\
            (\cred', \cm', \pi) \gets \Show(\creds_{i_b}, \cm_{i_b}, \usk_{i_b}, \phi)\\
            b' \gets \AdvA(\cred', \cm', \pi) \qquad \pclinecomment{$\AdvA$ guesses who's $\cred$ it is } \\
            \text{Return } (b' = b) \\
            \pclinecomment{Wins with the correct guess} \\
        }
    \end{pcvstack}
\end{pchstack}
    \begin{pchstack}
        \begin{pcvstack}
            \procedure[]{$\OHU()$}{%
                \pcif i \notin \HU \cup \CU \\
                \t \HU \gets \HU \cup \{i\} \\
                \pcreturn  i \\
            }
            \procedure[]{$\OCU(i)$}{%
                \pcif i \in \HU:\\
                \t \HU \gets \HU \setminus \{i\} \\
                \t \CU \gets \CU \cup \{i\} \\
                \t \creds_i \gets \{\cred | \OWNR[\cred] = i\} \\
                \t \pcreturn \{(\cred, \usk) | (\cred, \cm, \vec{m}, \usk, i, j) \in \CRED\}\\
                \pcreturn \bot \\
            }
        \end{pcvstack}
        \begin{pcvstack}
            \procedure[]{$\OOBTAIN(i, j, \vec{m})$}{%
                \pcif i \in \HU: \\
                \t \usk \sample \Z_p \\
                \t \cm \gets \CMCom([\vec{m}]; \usk) \\
                \t \cred \gets \Issue(\osk_j, \cm) \\
                \t \CRED \gets (\cred, \cm, \vec{m}, \usk, i, j), \\
                \t \OWNR[\cred] = i \\
                \pcreturn \cred \\
            }
            \procedure[]{$\OSHOW(i, \creds_i, \phi)$}{%
                \pcif i \in \HU \; \wedge \; \phi(\creds_i) = 1: \\
                \t \text{Parse } \creds = \{\sigma, \cm, \vec{m}, \usk \} \\
                \t \pi \gets \Show(\creds_i, \phi) \\
                \t \pcreturn \pi \\
                \pcreturn \bot \\
            }
        \end{pcvstack}
    \end{pchstack}
\end{pcvstack}






























\newpage
\section{Construction}


\subsection{Intuition of Construction}

\subsubsection{Outline}
Our credential system operates over attribute space $\Z_p$. The user is indexed by $i$, the issuer by $j$, and the $k^{th}$ credential issued to user $i$ from issuer $j$. The credential $\cred$ is a rerandomizable Pointcheval-Sanders signature over commitments $\sigma \gets \mathsf{RS.Sign}(\cm, \mathsf{osk})$ where $\cm \gets \CMCom(\vec{m}; \usk)$. During verification, the user rerandomizes both signature and commitment for anonymity, then uses $\Sigma$-protocols to prove their correctness for any predicate $\phi$. This approach leverages the algebraic structure of PS Signatures and Pedersen Commitments, that is, messages are exponents of a commitment which yields well-known, highly expressive and efficient zero-knowledge proofs of group element exponents, supporting a wide range of statements from selective disclosure to complex arithmetic relations. However, proofs are linear in the number of exponents. In contrast, SPS-EQ \cite{fuchsbauer_structure-preserving_2019, hanaoka_improved_2022} use constant-size set commitments and although proofs have limited expressiveness, they are constant size and very efficient. On the other hand, \cite{rabaninejad_attribute-based_2024} use Groth-Sahai proofs. During $\Obtain, \Issue$, the user sends the commitment $\cm$ along with a proof of opening $\pircom(\cm)$ allowing the extraction of $\usk$ for corrupt users in the unforgeability proof.

Consider a user holding credentials from three issuers, denoted $j = 1, 2, 3$, each providing one credential $k = 1$. The user rerandomizes each credential’s commitment and signature as follows: $\cm_{j,1}' \gets \CMRand(\cm_{j,1}, \Delta_{r_{j,1}})$ and $\sigma_{j,1}' \gets \RSRand(\sigma_{j,1}, \Delta_{r_{j,1}}, \Delta_{u_{j,1}})$. These rerandomized pairs $(\cm_{j,1}', \sigma_{j,1}')$ are indistinguishable from their original issuance. In the $\Show$ protocol, the verifier confirms their validity: $\RSVer(\sigma_{j,1}', \cm_{j,1}', \vk_j) = 1$ for all $j \in \{1, 2, 3\}$.

\begin{figure}
        \begin{pchstack}[boxed, center, space=4em]
            \begin{pcvstack}
                \procedure[space=auto]{Passport}{%
                \id: 12345, \\
                \ctx: "passport", \\
                \attrs: \mathsf{values}
                }
            \end{pcvstack}
            \pcvspace
            \begin{pcvstack}
                \procedure[space=auto]{Driver License}{%
                 \id: 12345, \\
                \ctx: "dmv", \\
                 \attrs: \mathsf{values}
                }
            \end{pcvstack}
            \pcvspace
            \begin{pcvstack}
                \procedure[space=auto]{University Degree}{%
                 \id: 12345, \\
                \ctx: "usyd{-}bcompsc", \\
                \attrs: \mathsf{values}
                }
            \end{pcvstack}
        \end{pchstack}
    \caption{Three Example Credentials, $\attrs$ holds arbitrary number of attributes such as expiry}
    \label{fig:three-creds}
\end{figure}

Next, the user proves a relation $\mathcal{R}_\phi$ that ensures the credentials satisfy a predicate $\phi$. 
\[
\mathcal{R}_\phi = \left\{ 
\begin{array}{l} 
\forall j, k: \RSVer(\sigma_{j,k}', \cm_{j,k}', \vk_j) = 1 \\ 
\forall j, k: \cm_{j,k}' = \CMRand(\CMCom([\id, \ctx_{j,k}, \attrs_{j,k}]; \usk_{j,k}), \Delta_{r_{j,k}}) \\ 
\phi(\{\ctx_{j,k}, \attrs_{j,k}\}) = 1 
\end{array} 
\right\}
\]

For instance, if $\phi$ requires a valid passport, driver’s license, and university degree, $\mathcal{R}_\phi$ might enforce $\ctx_{1,1} = \text{``passport''}$, $\attrs_{1,1}.\exp > \text{today}$, $\ctx_{2,1} = \text{``dmv''}$, and $\ctx_{3,1} \in \mathcal{D}$ (a set of accredited universities), with all commitments sharing the same $\id$.

\subsection{Proof Predicate Construction}

The zero-knowledge proof $\Pi_\phi$ demonstrates knowledge of a witness $w = (\id, \{\ctx_{j,k}, \attrs_{j,k}, \usk_{j,k}, \Delta_{r_{j,k}}, \Delta_{u_{j,k}}\})$ satisfying $\mathcal{R}_\phi$. The public inputs are $\{\sigma_{j,k}', \cm_{j,k}', \vk_j, \phi\}$. This proof can be implemented using Sigma protocols (e.g., Schnorr variants for exponent relations), with a proof size linear in the number of credentials and attributes. Practical optimizations, such as batching or multi-scalar multiplication, can reduce computation time, enhancing efficiency even for large attribute sets.

\subsubsection{Freshness}
To prevent replay attacks in credential show/verify protocols, we employ an interactive challenge-response mechanism as per Sigma protocols \cite{desmedt_proofs_1994, damgard_sigma_2010}. During showing, the verifier generates a random challenge that the user must incorporate into their zero-knowledge proofs ensuring each proof is tied to the single transaction. Interaction could be removed using the Fiat-Shamir transform \cite{odlyzko_how_1986}, this would require verifiers to maintain a list of used proofs introducing overhead and potential security concerns in a multi-verifier/distributed setting.


\subsubsection{Malicious Organization Keys}

To ensure security against maliciously generated issuer keys in our rerandomizable signature (RS)-based attribute-based credential (ABC) system, we require each issuer to prove knowledge of their secret key and the correctness of their public parameters. We define an NP-relation $\mathcal{R}_O$ that captures well-formed organization keys:

\[
\mathcal{R}_O = \{ (\opk_j = (\vk_j, \ck_j), (\osk_j, x, \{y_i\}_{i=1}^\ell)) \mid \RSVerKey(\osk_j, \vk_j, \ck_j) = 1 \}
\]

where:
\begin{itemize}
    \item $\opk_j = (\vk_j, \ck_j)$ is the issuer’s public key, with $\vk_j$ as the verification key and $\ck_j = (g, \{g_i = g^{y_i}\}_{i=1}^\ell, \tilde{g}, \{\tilde{g}_i = \tilde{g}^{y_i}\}_{i=1}^\ell)$ as the commitment key;
    \item $\osk_j = g^x$ is the secret key, and $\vk_j = \tilde{g}^x$ is its corresponding verification key;
    \item $\RSVerKey(\osk_j, \vk_j, \ck_j)$ verifies that:
    \[
    \osk_j = g^x \land \vk_j = \tilde{g}^x \land \bigwedge_{i=1}^\ell (g_i = g^{y_i} \land \tilde{g}_i = \tilde{g}^{y_i})
    \]
\end{itemize}

During the credential issuance protocol ($\Obtain$), the issuer generates a zero-knowledge proof of knowledge:

\[
\pi \gets \mathsf{ZKPoK}\{ (\osk_j, x, \{y_i\}_{i=1}^\ell) : (\opk_j, (\osk_j, x, \{y_i\}_{i=1}^\ell)) \in \mathcal{R}_O \}
\]

This proof ensures:
\begin{itemize}
    \item \textbf{Secret Key Knowledge}: The issuer knows $\osk_j$ corresponding to $\vk_j$.
    \item \textbf{Commitment Key Correctness}: The commitment key $\ck_j$ is properly formed with respect to the secret exponents $\{y_i\}_{i=1}^\ell$.
\end{itemize}

This mechanism guarantees that even a malicious issuer cannot generate keys that undermine user anonymity or system unforgeability. In security proofs, the zero-knowledge property allows extraction of $\osk_j$, enabling reductions to the underlying cryptographic assumptions.


\newpage
\subsection{\MIMCABC Construction}
The Credential is a signature $\sigma$ over commitment $\cm = \mathsf{CM.Com}([\id, \ctx, \attrs]; \usk)$ where $\attrs$ represents ancillary committed messages which we do not focus on in our protocol. $j$ indexes the issuers, and $k$ indexes the credentials from a specific issuer. 

\begin{figure}
    \begin{center}
    \begin{tabular}{l@{\hspace{5em}}c@{\hspace{5em}}l}
    \multicolumn{3}{l}{$\underline{\mathsf{OrgKeyGen}(1^{\lambda}, 1^\ell, j)}$ for issuer $j$ and $\vec{m}$ length = $\ell$} \\[1em]
    \multicolumn{3}{l}{$\BG = (\G_1, \G_2, \G_T, e, g, \tilg,p) \sample \BGGen(\secparam), \; \mathsf{ck_j} \sample \mathsf{CM.Setup}(\BG, \secparam, \ell)$}\\[1em]
    \multicolumn{3}{l}{$(\sk_j, \vk_j) \sample \mathsf{RS.KeyGen}(\mathsf{ck}_j), \; \text{ Return } (\osk_j, \opk_j) = ((\sk_j),(\vk_j, \ck_j))$}\\[1em]
    \multicolumn{3}{l}{$\underline{\mathsf{(Obtain, Issue)}}$:}\\[1em]
    \multicolumn{3}{l}{$\pircom(\cm) = \zkpok\{(\id, \ctx, \attrs, \usk)| \cm = g_1^{\id}g_2^{\ctx},\ldots, g^{\usk} \}$}\\[1em]
    \multicolumn{3}{l}{$\pirverkey(\sk, \vk, \ck) = \zkpok\{(\sk, x, \{y_i\}_{i=1}^\ell) | \sk = g^x \wedge \vk = \tilde{g}^x \bigwedge_{i=1}^\ell (g_i = g^{y_i} \wedge \tilde{g}_i = \tilde{g}^{y_i})\}$}\\[1em]
    $\underline{\mathsf{Obtain}(\vec{m}, \opk)}$ && $\underline{\Issue(\pircom, \cm, \osk)}$ \\[1em]
    If  $\pirverkey(\sk, \vk, \ck)$ fails, return $\bot$ & $\xleftarrow{\pirverkey(\sk, \vk, \ck)}$ & \\[1em]
    $\usk \sample \Z_p, \cm = \CMCom([\id,\ctx, \attrs];\usk)$ & $\xrightarrow{\;\; \pircom(\cm) \;\;}$ & \;\; If $ \pircom(\cm)$ fails, return $\bot$ \\[1em]
    If $\RSVer(\sigma, \cm, \opk) = 0$, return $\bot$  & $\xleftarrow{\qquad \sigma \qquad}$ & $u \sample \Z_p$, $\sigma \sample \RSSign(\cm, \osk, u)$ \\[1em]
    \multicolumn{3}{l}{\; Else, return $\cred_{j,i} \gets (\sigma, \cm, \usk, \opk_j)$} \\[1em]
    \multicolumn{3}{l}{$\underline{(\mathsf{Show}, \mathsf{Verify}):}$ for a set $\{\cred_{j,k}\}$ and predicate $\phi$:}\\[1em]
    \multicolumn{3}{l}{$\Pi_\phi = \zkpok\{(\{\id, \ctx_{k}, \attrs_{j,k}, \usk_{j,k}'\}_{j,k}) \; | \; \forall j,k: \cm_{j,k}' = \CMCom([\id, \ctx_{k}, \attrs_{j,k}]; \usk_{j,k}') \wedge$} \\[0.5em]
    \multicolumn{3}{l}{\quad $\RSVer(\sigma_{j,k}', \cm_{j,k}', \opk_j) = 1 \; \wedge \; \phi(\{[\id, \ctx_{k}, \attrs_{j,k}]\}_{j,k}) = 1 \}$}\\[1em]
    $\underline{\mathsf{Show}(\{\cred_{j,k}\}, \phi)}$ && $\underline{\mathsf{Verify}(\{\sigma_{j,k}', \cm_{j,k}'\}_{j,k}, \pi_\phi, \{\opk_j\})}$ \\[1em]
    \multicolumn{3}{l}{For each $\cred_{j,k} = (\sigma_{j,k}, \cm_{j,k}, \usk_{j,k}, \opk_j)$:}\\[0.5em]
    \multicolumn{3}{l}{\quad Sample $\usk_{j,k,\Delta}, u_{j,k,\Delta} \sample \Z_p$}\\[1em]
    \multicolumn{3}{l}{\quad $\sigma_{j,k}' = \RSRand(\sigma_{j,k}, \usk_{j,k,\Delta}, u_{j,k,\Delta})$}\\[1em]
    \multicolumn{3}{l}{\quad $\cm_{j,k}' = \CMRand(\cm_{j,k}, \usk_{j,k,\Delta}), \; \usk_{j,k}' = \usk_{j,k} + \usk_{j,k,\Delta}$}\\[1em]
    & $\xrightarrow{\{\sigma_{j,k}', \cm_{j,k}'\}_{j,k}, \pi_\phi}$ & If $\pi_\phi$ fails, return 0, else 1 \\[1em]
    \end{tabular}
    \end{center}
    \caption{\MIMCABC system}
    \label{fig:master-cred-protocol}
\end{figure}







\newpage
\section{Security}

\subsection{Unforgeability Reduction}









In the unforgeability game, the adversary $\AdvA$ outputs a forgery, $\Verify(\{\cred_k'^*\}, \phi^*, \pi^*, \{\opk_j\}) = 1$. Using the $\Sigma$-protocol's extractor $\Extractor$, we obtain the attributes $\{\vec{m}_k^*\}$ and randomness $\{r^*_k\}$ such that each $\cred_k^*$ contains a valid signature $\sigma_k^*(\cm_k^*, \osk_j)$, and valid commitment commitment $\cm^*_k = g^{r_k^*} \prod_{i=1}^{\ell} g_i^{m_k, i}$ with $\{\vec{m_k^*}\}$ satisfying $\phi(\vec{m_k^*}) = 1$
 







\newpage
\section{Performance Evaluation}



Describe the Variant: Explain what makes it efficient (e.g., fewer exponentiations, optimized pairing checks).
Validate Security: Reference your security proofs or add a short discussion confirming it meets EUF-CMA and rerandomization requirements.
Quantify Benefits: Report the 10\% reduction (or updated figures from your experiments) and compare it to the standard PS scheme.
End to end implementation performance

benchmark
1. 1 issuer, 1 credential
2. 1 issuer, multiple credentials
3. multiple issuer, multiple credentials























\section{ancilliary}
\begin{table}[h]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{Scheme} & \textbf{Commitment} & \textbf{Proof System} & \textbf{Proof Size} & \textbf{Expressiveness} \\
        \hline
        PS-based ABCs & Pedersen & $\Sigma$-protocols & Varies (linear for complex statements) & High: selective disclosure, AND, OR, range proofs \\
        \hline
        SPS-EQ-based ABCs & Set Commitments & Structure-Preserving Proofs & Constant & Limited: selective disclosure, AND statements \\
        \hline
        Threshold Counting Tokens & Pairing-based & Groth-Sahai Proofs & Linear & Moderate: pairing equations (equality, linear combinations) \\
        \hline
    \end{tabular}
    \caption{Comparison of Cryptographic Schemes for Attribute-Based Credentials}
    \label{tab:abc_comparison}
\end{table}

\todonote{Summarize / Introduce the step changes. Introduce all oracles. Introduce the step change in attacks. Summarise reductions after each step}


