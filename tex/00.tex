 \section{Introduction}\label{sec:intro}
Digital Identity systems form the foundation of online trust and authentication, processing billions of verifications daily \cite{noauthor_happy_2021, pang_zanzibar_nodate}. Traditional centralized systems, while effective for regulatory compliance \cite{eltayeb_crucial_2024}, suffer from significant privacy and security vulnerabilities. Ongoing data breaches \cite{zhang_data_2022} affect billions of users, demonstrating the risks of storing identity data and centralizing systems. Decentralized Identity (DID) is a loosely defined framework (W3C specification) having evolved over the past 2 decades, offering users greater control over their credentials \cite{soltani_survey_2021}, many concrete implementations struggle to balance privacy with accountability \cite{maram2021candid} for the required feature set. 


\noindent Anonymous Credential Systems (ACS) \cite{chaum1985security,hutchison_signature_2004, hutchison_constant-size_2006, sako_short_2016, fuchsbauer_structure-preserving_2019} address privacy concerns but face challenges balancing privacy with accountability, orthogonally, unconditionally anonymous payment systems have demonstrated how unconditional anonymity can enable system abuse. Current systems focus on protecting against sybil attacks \cite{crites_syra_2024, rabaninejad_attribute-based_nodate}, enabling revocation \cite{goos_dynamic_2002, robshaw_uc_2016, camenisch_scalable_2016, baldimtsi_accumulators_2017}, rich attribute-based credential authentication \cite{rosenberg_zk-creds_2022, babel_bringing_2023} but very few implement all. The tension between privacy and accountability has become increasingly critical as governments worldwide, particularly the EU's Digital Identity Framework \cite{noauthor_regulation_2024}, move toward privacy-preserving digital identity wallets. These challenges motivate the need for a comprehensive identity system that achieves privacy, accountability, and practical deployment requirements simultaneously.

\subsection{Organization}

Short Summary: We build a new anonymous credential building block for multi-issuer, multi-credential systems. We use it to build a new private digital identity system with sybil resistance and revocation.


\begin{enumerate}
    \item section \ref{sec:mimc} is the new anonymous credential system building block for multi-issuer, multi-credential
    \item section \ref{sec:sigmaproofs} outlines all sigma zkp's used
    \item section \ref{sec:idsys} builds a private identity system from the building block in section \ref{sec:mimc} and proofs in \ref{sec:sigmaproofs}
    \item section \ref{sec:evaluation} shows privacy and sybil resistance can be low-overhead, also shows our benchmarks for proving complex statements about credentials is more efficient than SOTA
\end{enumerate}


\subsection{Related Work}

\subsubsection{Decentralized Identity (DID)}
enables entities to create and manage digital identities without relying on a central authority. W3C specifications for DID and Verifiable Credentials define standards for globally unique, publicly verifiable credentials, allowing a user to prove claims (information) about their identity attributes. DID typically uses Distributed Ledgers and public key cryptography to establish a "web of trust" and maintain revocation registries. 

The DID model consists of 
\begin{enumerate}
    \item \textbf{Holders} Identities with Decentralized Identifiers (DID's) who manage their own keys, and credentials, and request access to resources
    
    \item \textbf{Issuers} create and sign credentials about identity holders
    
    \item \textbf{Verifiers} validate credentials by checking the presented cryptographic information against the registry

    \item  \textbf{Verifiable Data Registry}, often a DLT, is the root of trust, maintaining DID records, keys, and credential schemas, but doesn't store credential data
    
    \item \textbf{Identity Wallet}: the user interface for storing, managing, and presenting verifiable credentials
\end{enumerate}
 
Citations
- U-Prove, U-Port, Connect.me, Sovrin, PingID, w3c

While the W3C DID specifications outline core functionalities such as cryptographic verification, privacy preservation, selective disclosure, and revocation, it requires a formal security definition and proofs to achieve these properties. Anonymous Credential Systems provide well-established formal security definitions for many properties that DID aims to achieve. Specifically, Correctness, Unforgeability, Anonymity, Sybil Resistance, and Revocation. By building DID systems on top of Anonymous Credential primitives, DID systems can inherit these formal security guarantees. 

\subsubsection{Multi Attribute Anonymous Credentials} 
Anonymous Credentials are a long line of orthogonal work with the goal of providing privacy/anonymity to online interactions, These are now deployed in a number of real-world systems (U-Prove, Idemix, PrivacyPass).  
The line of work has improved with features, efficiency, and expressiveness throughout time. 
Abstractly, they provide private protocols to prove information on committed attributes. 
Pairing-based blind signatures enabled efficient multi-show credentials (CL, PS, BBS+).
Other constructions are based on (chase's MAC's, etc) 
Further work was done to the Anonymous Credential primitive to support delegation, update, and pseudonyms and may also require incorporating other cryptographic primitives to enable revocation, auditing, tracing, and sybil resistance. 

\subsubsection{Anonymous Credential Systems (ACS)} 
Anonymous Credential Systems implement primitives together in ways that preserve privacy and offer additional functionality required by systems. The combination of multiple primtiives to be used together in a privacy preserving way is complex it itself. 

\noindent \textbf{Accountable Privacy}
In a parallel industry, fully private financial systems like zcash, monero, and tornado cash where blockchain users can exploit and misuse the system is a big problem and will prevent governments and organisations to deploy private preserving techniques. Innovations in Identity often follow those in financial systems, (Chaum's e-cash and blind signatures, DAC and ZCash for example) as they share similar motivations and infrastructure, spending a coin anonymously is analogous to using an identity anonymously. Therefore, advancements in the field of Accountable Privacy (UTT, other examples), a series of techniques and protocols that balance the tradeoffs between privacy and accountability in financial systems, can inspire and motivate private identity systems.

\noindent \textbf{Privacy Preserving Decentralized Identity Systems}
CanDID proposed a privacy-preserving decentralized identity system achieving Sybil Resistance, Accountability. 
They defined a system architecture that has been extended in many different directions, such as \cite{wang2023hades, rathee_zebra_2022} optimising for blockchain performance and additional private-accountability features. \cite{crites_syra_2024, rabaninejad_attribute-based_nodate} optimize for non-interactivity and minimal stored state with the CanDID threshold committee

CanDID leaves integrating Decentralized Identity with Anonymous Credentials as open work.

\noindent \textbf{Decentralized Identity with Anonymous Credentials}
The strawman approach to combining Decentralized Identity with Anonymous Credentials replaces the existing credential, usually in the form of a signature over attributes, signed by an identity provider and verifiable with their public key, with a blind signature over attributes, which introduces the accountable privacy problems such as how to issue and verify a credential to an anonymous user, and how to retain accountability of an anonymous user, such are the real-world identity system requirements. 
Compatibility for a decentralized architecture requires decentralized cryptography which has propelled the use of threshold cryptography in anonymous credential schemes and other settings e.g. (Coconut, Threshold BBS+, ...). 


\newpage

\subsection{Contributions}

We present a privacy-preserving decentralized identity system for multi-issuer environments. Our system combines anonymous credential primitives with decentralized identity architecture, achieving security and privacy properties that are challenging to realize when naively combining these building blocks. Our main contributions are:

\begin{enumerate}
    
    \item  A privacy-preserving identity system that enables secure credential chaining and complex anonymous identity verification across multiple issuers.

    \item A novel zero-knowledge building block that enables private proofs of VRF derivations from committed messages.
    
    \item  A complete system implementation using PS Signatures over commitments that achieves sybil resistance and revocation while enabling multi-issuer credential chaining - validated through concrete implementations, benchmarks, and formal security analysis.

\end{enumerate}

\subsection{Gap Analysis}

Digital identity is undergoing a fundamental transformation, evolving across three frontiers: decentralization, mandatory institutional adoption, and the emergence of attestation services.    
Identity systems are evolving from trusted, single-issuer models where a user authenticates with a single authority toward a decentralized paradigm where users publicly verify any multitude of credentials, manage multiple credentials for diverse issuers with their digital wallets.

\noindent As traditional organizations increasingly adopt decentralized identity capabilities and while it's also being mandated in the EU, they seek solutions that minimize changes to their existing infrastructure while enabling new DID capabilities and maintaining regulatory compliance. Beyond traditional organisations, a new frontier of credential issuance is emerging through automated attestation services like TLS Notary, Chainlink's DECO, Brave Browser's distefano, and Sui Labs zkLogin which enable verifiable data to become a credential. This transformation, while powerful, introduces challenges to identity systems run by governments and trusted organisations  who require sybil resistance protecation and revocation while maintaining privacy in a system where traditional infrastructure assumptions such as ease of revocation no longer hold.

\noindent \textbf{Core Challenges} Evolving from single-issuer to multi-issuer, multi-credential environments introduces several challenges. While existing solutions support private identity systems with anonymity, sybil resistance and revocation for single issuers. The introduction of multiple credentials and their sources transforms solved problems into new challenges. A decentralized system for the frontier of credentials must maintain anonymity across credential presentations, implement cross credential sybil resistance and efficient revocation checks without centralized trust.

\noindent Additionally, composing privacy-preserving primitives together to achieve the properties we require introduces complexity. While individual primitives for anonymous credentials, Sybil resistance, and revocation are well understood in isolation, the integration highlights the trilemma of accountable privacy systems - the tension between privacy, accountability, and functionality. The core challenge lies in designing efficient zero knowledge proof systems that combine these primitives in protocols that maintain the security and privacy properties of our system with practical efficiency.

\noindent Thirdly arises when users verify attributes from multiple credentials. Secure credential composition is required, while allowing flexible zero knowledge proof attribute attestations and selective disclosure. Lastly, users with multiple credentials require to privately prove their credentials are not revoked, introducing a scaling challenge - enabling efficient zero-knowledge batch proofs of non-membership while maintaining privacy and practical verification times. 




\subsection{Technical Challenges}

Building a privacy-preserving decentralized identity system requires balancing competing requirements: adhereing to strong security and privacy properties while retaining accountability measures and providing efficient verification of complex identity statements. While individual cryptographic primitives exist for many of these properties in isolation, combining them while maintaining security and efficiency introduces technical challenges, we identity three fundamental challenges below: 

\todonote{Rewrite this - start with rerand sigs over commitments, then extending that for multi-issuer, multi-cred, then using that for identity system}

\begin{enumerate}

    \item \textbf{Efficient Rerandomizable Signatures over Commitments} A key technical challenge was designing a signature scheme that efficiently supports both rerandomization and zero-knowledge proofs over-committed attributes. While existing schemes like BBS+, CL, and standard PS provide these properties, we use a customized PS signature with the lowest overhead in the randomization step. %what I want to say here is that after the randomization step, we are given a commitment in G1 which is easy and efficient to work with, rather than some other construction which needs custom proofs and new security proofs for each system built with it. 
    Unlike BBS+ and CL04, we maintain compatibility with standard Pedersen Commitments, enabling efficient proofs from standard techniques in the literature.
    

    \item \textbf{Sybil-Resistant Context Credential Construction} Designing an efficient mechanism to link context credentials to a master credential while preserving privacy, our solution uses a novel building block that combines a VRF with committed attributes - the user's Master Credential contains a commitment with their VRF key and generates a context credential nullifier with a VRF parameterized by the key and input the context string. 
    The complexity lies in efficiently proving in zero knowledge this nullifier was correctly derived from the committed key present in a valid, unrevoked master credential. This construction enables strong sybil resistance while maintaining unlinkability between presentations.

    \item \textbf{Efficient Multi-Credential Proofs and Revocation} enabling efficient proofs over multiple credentials while ensuring practical revocation. Our construction leverages Sigma protocols and Pedersen commitments, which, although they scale linearly with the credential attributes, they are extremely efficient in practice and support the most expressive statements. We integrate existing efficient revocation mechanisms that support batch non-membership proofs, allowing multiple credentials to be efficiently verified simultaneously while maintaining anonymity through zero-knowledge proof protocols. 

\end{enumerate}


\subsubsection{Comparison}


\begin{table}
\begin{center}
\caption{Comparison of our construction over previous work.}
\label{tab:comparison}
\begin{tabular}{l|cccccc}
Features    									& Multi Issuer & Sybil Resistance  & Revocation & Efficient Cred. Chaining$\footnotemark[1]$ & M-ABC$\footnotemark[2]$   & Anonymity$\footnotemark[3]$   \\
\hline

CanDID \cite{maram2021candid}     				& \ding{51}     & \ding{51} 	& \ding{51}  &  \ding{55}     & \ding{55}                     & \ding{55}		\\
SyRA \cite{crites_syra_2024}     				& \ding{55}     & \ding{51}    	& \ding{55}  &  \ding{55}     & \ding{55}                     & \ding{51}		\\
S3ID \cite{rabaninejad_attribute-based_nodate}  & \ding{51}     & \ding{51}    	& \ding{55}  &  \ding{51}     & \ding{55}\footnotemark[4]     & \ding{51}		\\
Our Work  										& \ding{51}     & \ding{51}    	& \ding{51}  &  \ding{51}     & \ding{51}                     & \ding{51}		\\
\end{tabular}
\end{center}

\vspace{1em}
\footnotesize
$\footnotemark[1]$ Credential Chaining is a user presenting multiple credentials to be verified together for a complex identity statement.

\footnotesize
$\footnotemark[2]$ M-ABC is a Multi-Show Attribute Based Credential, allowing a user to satisfy rich, attribute-based identity statements 

\footnotesize
$\footnotemark[3]$ Anonymity is defined in the Anonymous Credential model, no verifier and issuer (collaborating together) may learn more about the user or their credentials other than what the user discloses and what their credentials verify. Multiple credential verifications are unlinkable.

\footnotesize
$\footnotemark[4]$ While possible in S3ID, they mention 

\footnotesize
$\footnotemark[5]$ Multi-issuer means supporting credentials from different authorities that can be cryptographically linked while preserving privacy
\end{table}

\todonote{S3ID is inefficient for attribute-based verification, this table doesn't show that}















% % % % % % % % % % 
% 
% PRELIMINARIES
% 
% % % % % % % % % % 



\section{Preliminaries}\label{sec:preliminaries}
\subsection{Notation}
Let $\N$ is the set of positive integers $\{1,2,3,\ldots\}$. If $x$ is a string, then $|x|$ is its length, if $S$ is a set, $|S|$ denotes its size. If $\lambda \in \N$, then $\secparam$ denotes the string of $\lambda$ ones. If $n$ is an integer, then $[n] = \{1, \ldots,n\}.$ If $S$ is a set, then $s \sample S$ denotes the operation of picking an element $s$ of $S$ uniformly at random. $\$$ denotes randomized algorithm output. We use $z \gets A()$ and $z = A()$ interchangably for deterministic assignment where $z$ is the output of a deterministic algorithm $A$ and $z \gets A(x,y,\ldots)$ is the output of a deterministic algorithm with inputs $x,y,\ldots$ when the set, sum, or product has a single index. 
The notation $\vect{x}$ is used to denote the vector $(x_0, \ldots,x_n)$ or $(x_1, \ldots, x_n)$ where $n$ and choice of $0, 1$ will be clear from the context.

% notation from Algebraic MAC's
The notation $\{x_i\}_1^n, \sum_1^n x_i, \prod_1^n x_i$ are shorthand for $\{x_i\}_{i=1}^n, \sum_{i=1}^n x_i$ and $\prod_{i=1}^n x_i$ respectively. 

% maybe need to rewrite
We write $A(x,y,\ldots : \oracle_1, \oracle_2, \ldots)$ as an algorithm taking $(x,y,\ldots)$ as input with access to oracles $(\oracle_1, \oracle_2, \ldots)$ and $z \sample A(x,y,\ldots : \oracle_1, \oracle_2, \ldots)$ as the assignment of the output of $A$ to $z$.

We write commitments using 1-base indexing. $\cm_m[1]$ represents the message at the first position of the $\cm_m$ commitment, that is, in a commitment $\cm_m = CM.Com([s,k,\ldots];r)$, algebraically, the commitment is $g_1^sg_2^k\ldots h^r$ where $s$ is the first position.


Use this to update mine
\cite{hutchison_get_2010} has good preliminaries
% We let {0, 1}∗ and {0, 1}t denote the set of binary strings of arbitrary length and length t respectively, and let ε denote the empty string. If A is an algorithm, we denote the action of obtaining x by invoking A on inputs y1, . . . , yn by x ← A(y1, . . . , yn), where the probability distribution on x is determined by the internal coin tosses of A.
% We denote an interactive protocol P as P = (P0, P1). Executing the protocol on input in0 and in1, resulting in the respective output out0 and out1, we write as 〈out0; out1〉 ← 〈P0(in0); P1(in1)〉. If arr is an array or list we let arr[i] denote the ith element in the array/list.

$\Z_p^*, \G_1^*$ - the star (*) represents the exclusion of trivial elements. That is, $\Z_p^*$ excludes 0, focusing on invertible (coprime with $p$) elements under multiplication mod $p$ where $|\Z_p^*| = p-1$ and sampling $y \sample \Z_p^*$ selects an integer from $[1, p-1]$ uniformly. $\Z_p$ is the additive group mod $p$, size = $|\Z_p| = p$, sampling $\y \sample \Z_p$ samples uniformly from $[0, p-1]$

$\G_1^*$ excludes the elliptic curve identity element $\{\mathcal{O}\}$ required for discrete log operations as any elliptic curve operation with the identity element results in the identity element. 



\begin{definition}[Bilinear map]
    
\end{definition}


\begin{definition}[Bilinear-group generator]
    
\end{definition}


\begin{definition}[Discrete Log Problem]
    
\end{definition}

.
.
.
Define the assumptions we use

\begin{definition}[q-sdh]
    
\end{definition}

Assumptions from here - as discussed by UTT paper commitment instantiation
The binding property holds under the SDL assumption of \cite{hutchison_get_2010}
which follows from 1-SDH of \cite{boneh_short_2008}. (See Section I for details.) 





\subsection{Digital Signatures}

\begin{definition}[Correctness]
    Correctness
\end{definition}



\begin{definition}[EUF-CMA]
    EUF-CMA
\end{definition}







\subsection{Zero Knowledge Proofs of Knowledge}



\begin{definition}[Completeness]
   Completeness
\end{definition}


\begin{definition}[Knowledge Soundness]
    Knowledge Soundness
\end{definition}


\begin{definition}[Zero Knowledge]
    zero knowledge
\end{definition}


% % % % % % % % % % 
% 
% END PRELIMINARIES
% 
% % % % % % % % % % 


























% % % % % % % % % % 
% 
% Randomizable Vector Commitments
% 
% % % % % % % % % % 


\newpage
\section{Bilinear Rerandomizable Vector Commitments}
We now introduce a specialized commitment scheme based on \cite{tomescu2022utt} as the building block for our anonymous credential system. Our construction extends the classical Pedersen Commitment scheme with three properties that are required for our multi-issuer, multi-credential setting construction:
\begin{enumerate}
    \item \textbf{Position Binding: } we need to commit to a vector of attributes $\{m_1, \ldots, m_n\}$ while ensuring the individual positions within the commitment remain binding. Position binding is useful when proving relations about specific committed attributes across multiple credentials. 
    
    \item \textbf{Symmetric across bilinear groups: } in order to support our pairing-based signatures and efficient zero-knowledge proofs, we require commitments to be represented and verified in both $\G_1, \G_2$ curve groups. 
    
    \item \textbf{Rerandomization: } we need the ability to rerandomize commitments while preserving their structure which supports unlinkability in credential presentations
\end{enumerate}

\noindent Furthermore, our scheme often leverages Pedersen Commitments homomorphic properties, allowing us to combine multiple commitments with group operations. This enables us to bind credential attributes and hide secrets while maintaining privacy. 



\begin{definition}[Rerandomizable Vector Commitment scheme] 
    A rerandomizable vector commitment scheme $\mathsf{RVC}$ is a tuple $(\mathsf{Setup}, \mathsf{Commit}, \mathsf{Open}, \mathsf{Rerand})$ of PPT algorithms where:
    
    \begin{itemize}
        \item $\mathsf{Setup}(1^\lambda, 1^n) \to \mathsf{ck}$ probabilistic algorithm that takes as input the security parameter $\lambda$ and vector length $n$ both in unary. It outputs the commitment key $\mathsf{ck}$ of length $n$
        
        \item $\mathsf{Commit}(\mathsf{ck}, \vect{m}) \to (\cm, r)$: probabilistic algorithm takes as input the commitment key $\mathsf{ck}$ and message vector $\vect{m} \in \mathcal{M}^n$ . Outputs the commitment $\cm$ and opening key $r$

        \item $\mathsf{Open}(\mathsf{ck, cm}, \vec{m}, r) \to \bit$: deterministic algorithm, takes as input the commitment key $\mathsf{ck}$, commitment $\mathsf{cm}$, messages $\vec{m}$ and randomness $r$, outputs 1 if success, 0 for failure

        \item $\mathsf{Rerand}(\mathsf{ck, cm}) \to (cm', r')$: probabilistic algorithm, takes as input the commitment key $\mathsf{ck}$, commitment $\mathsf{cm}$ outputs randomized commitment $\cm'$ and new randomness $r'$. 
        
    \end{itemize}
\end{definition}

\noindent A rerandomizable vector commitment scheme is secure if it's correct, hiding, binding, position binding, rerandomizable, and symmetric group correct. We use standard definitions for correctness, hiding, and binding.


\begin{definition}[Correctness] A rerandomizable vector commitment scheme $\mathsf{RVC}$ is correct if for all $n \in \N$ and all $\vec{m} \in \mathcal{M}^n$:
        \[
        \Pr
            \left [
                \begin{array}{l}
                    \mathsf{ck} \gets \mathsf{Setup}(1^\lambda, 1^n) \\
                    (\cm, r) \gets \mathsf{Commit}(\mathsf{ck}, \vec{m}) \\
                \end{array}
                : 1 \gets \mathsf{Open}(\mathsf{ck}, \cm, \vec{m}, r)
            \right ] = 1
    \]
\end{definition}



\begin{definition}[Hiding] A rerandomizable vector commitment scheme $\mathsf{RVC}$ is hiding if for all $\PPT$ adversaries $\Adv$ and all message vectors $\vec{m}_0, \vec{m}_1$ of equal length, there is a negligible function $\negl$ such that:
\[
    \left |
        \Pr
            \left [
                \begin{array}{l}
                    \mathsf{ck} \gets \mathsf{Setup}(1^\lambda, 1^n) \\
                    (\vec{m}_0, \vec{m}_1) \gets \mathcal{A}(\mathsf{ck}) \\
                    b \sample \bit \\
                    (\cm_b, r) \gets \mathsf{Commit}(\mathsf{ck}, \vec{m}_b) \\
                    b' \gets \Adv(\mathsf{ck}, \cm_b) \\
                \end{array}
                : b' = b
                \right ]
                - \frac{1}{2}
    \right | \leq \negl
\]
\end{definition}


\begin{definition}[Binding] A rerandomizable vector commitment scheme $\mathsf{RVC}$ is binding if for all $\PPT$ adversaries $\Adv$ and all message vectors $\vec{m}_0, \vec{m}_1$ of equal length, there is a negligible function $\negl$ such that:
    \[
        \Pr
        \left [
            \begin{array}{l}
            \mathsf{ck} \gets \mathsf{Setup}(1^\lambda, 1^n) \\
            (\cm, \vec{m}_0, \vec{m}_1, r_0, r_1) \gets \Adv(\mathsf{ck}) \\
            b_0 \gets \mathsf{Open}(\mathsf{ck}, \cm, \vec{m}_0, r_0) \\
            b_1 \gets \mathsf{Open}(\mathsf{ck}, \cm, \vec{m}_1, r_1) \\
            \end{array}
            : b_0 = b_1 = 1 \land \vec{m}_0 \neq  \vec{m}_1
        \right ] \leq \negl
    \]
\end{definition}


\begin{definition}[Position Binding]
A rerandomizable vector commitment scheme $\mathsf{RVC}$ is position binding if for all $\PPT$ adversaries $\Adv$ and where $\vec{m}, \vec{m}'$ are vectors that differ only at position $i$, there is a negligible function $\negl$ such that:
\[
    \Pr
    \left[
        \begin{array}{l}
        \mathsf{ck} \sample \mathsf{Setup}(1^\lambda, 1^n) \\
        (\cm, i, m, m', r, r') \sample \mathcal{A}(\mathsf{ck}) \\
        b \gets \mathsf{Open}(\mathsf{ck}, \cm, \vec{m}, r) \\
        b' \gets \mathsf{Open}(\mathsf{ck}, \cm, \vec{m}', r') \\
        \end{array}
        : \begin{array}{l}
            b = b' = 1 \land \\
            m_i \neq m'_i \land \\
            0 \leq i < n
          \end{array}
    \right] \leq \negl
\]
\end{definition}



\begin{definition}[Symmetric Group Correctness]
A rerandomizable vector commitment scheme $\mathsf{RVC}$ satisfies symmetric group correctness if for all $n \in \mathbb{N}$ and all $\vec{m} \in \mathcal{M}^n$:
  \[
        \Pr\left[
        \begin{array}{l}
            \mathsf{ck} \sample \mathsf{Setup}(1^\lambda, 1^n) \\
            (\cm, \widehat{\cm}, r) \sample \mathsf{Commit}(\mathsf{ck}, \vec{m})
        \end{array}
        : e(\cm, \widehat{g}) = e(g, \widehat{cm})
        \right] = 1
    \]
    \[
        \Pr\left[
        \begin{array}{l}
            (\cm', \widehat{\cm'}, r') \sample \mathsf{Rerand}(\mathsf{ck}, \cm, \widehat{\cm}, r)
        \end{array}
        : e(\cm', \widehat{g}) = e(g, \widehat{\cm'})
        \right] = 1
    \]
\noindent where $g, \widehat{g}$ are the generators specified in $\mathsf{ck}$ for $\G_1, \G_2$ respectively.
\end{definition}




\begin{definition}[Additive Homomorphism]
A rerandomizable vector commitment scheme $\mathsf{RVC}$ is additively homomorphic if for all $\vec{m}_1, \vec{m}_2 \in \mathcal{M}^n$ and randomness $r_1, r_2 \in \Z_p$:
\[
    \Pr\left[
    \begin{array}{l}
        \mathsf{ck} \sample \mathsf{Setup}(1^\lambda, 1^n) \\
        (\cm_1, r_1) \sample \mathsf{Commit}(\mathsf{ck}, \vec{m}_1) \\
        (\cm_2, r_2) \sample \mathsf{Commit}(\mathsf{ck}, \vec{m}_2)
    \end{array}
    : \cm_1 \cdot \cm_2 = \mathsf{Commit}(\mathsf{ck}, \vec{m}_1 + \vec{m}_2, r_1 + r_2)
    \right] = 1
\]

\noindent Furthermore, for symmetric group correctness, the homomorphism must hold across groups:
\[
    e(\cm_1 \cdot \cm_2, \widehat{g}) = e(g, \widehat{\cm_1} \cdot \widehat{\cm_2})
\]
\end{definition}

% The homomorphic operation is the standard component-wise addition over Zp, and therefore one can add a value to a single entry without changing the other entries (by adding zeroes in all other locations). From UTT


\subsection{Construction}

We instantiate the Pedersen Vector Commitment over both $\G_1 and \G_2$ for use within the PS signature. We denote $\cm \in \G_1, \widehat{\cm} \in \G_2$ and verify $\cm \equiv \tilde{\cm}$ by asserting $e(\cm, \tilde{g}) = e(g, \tilde{\cm})$. 
Let $\G_1, \G_2$ be cyclic groups of large prime order $p$ with an efficient Type 3 pairing $e : \G_1 \times \G_2 \to \G_t$. 
For a vector of messages $\vec{m} = (m_1, \ldots, m_n) \in \Z_q^n$, the rerandomizable Pedersen vector commitment scheme consists of the following PPT algorithms:

\begin{itemize}
    \item $\mathsf{CM.Setup}(1^\lambda, 1^n) \to \mathsf{ck}$: 
    On input the security parameter $\secparam$ and maximum message vector length $1^n$ in unary. Compute a bilinear group $\mathsf{BG =}(p, \G_1, \G_2, \G_T, e, G, \widehat{G}) \sample \mathsf{BGGen}(\secparam)$, 
    sample $n$ elements $\{y_i\}_1^n \sample \Z_p$, and $x \sample \Z_p$, compute $(H, \widehat{H}) \gets (xG, x\widehat{G})$ and $\{G_i, \widehat{G}_i\}_1^n \gets (y_iG, y_i\widehat{G})_1^n$ Return $\ck$ as $(\mathsf{BG}, \{G_i, \widehat{G}_i\}_1^n, H,\widehat{H})$

    \item $\mathsf{CM.Com}(\ck, \vec{m}) \to (\mathsf{cm}, \widehat{\mathsf{cm}}, r)$: On input $\ck = (\mathsf{BG}, \{G_i, \widehat{G}_i\}_1^n, H,\widehat{H})$, a message vector $\vec{m} = \{m_1, \ldots, m_n\}$. Sample $r \sample \Z_p$, compute $\cm \gets rH + \sum_1^n m_iG_i$ and $\widehat{\cm} \gets r\widehat{H} + \sum_1^n m_i\widehat{G}_i$. Output $(\cm, \widehat{cm}, r)$ where equality of commitments across groups can be verified $e(\cm, \widehat{G}) = e(G, \widehat{\cm})$
    
    \item $\mathsf{CM.Rerand}(\ck, \cm, \widehat{\cm}, \Delta_r) \to (\mathsf{cm'}, \widehat{\mathsf{cm'}}):$
    On input $\ck = (\mathsf{BG}, \{G_i, \widehat{G}_i\}_1^n, H,\widehat{H})$, commitments $\cm, \widehat{cm}$ and new randomness $\Delta_r$, compute blinding points $\Delta_rH, \Delta_r\widehat{H}$, add points to commitments, $\cm' = \cm + \Delta_rH$, and $\widehat{\cm'} = \widehat{\cm} + \Delta_r\widehat{H}$, the randomized commitment is now $\cm = m_1G_1 + \ldots + m_iG_i + (r + \Delta_r)H$ and new opening key $(r + \Delta_r)$
\end{itemize}


\subsubsection{Additive Homomorphism}

We leverage Pedersen commitment's additively homomorphic properties multiple times in our construction. 
\begin{itemize}
    \item \textbf{Rerandomization: } given a commitment $\cm = mG + rH$ and fresh randomness $\Delta_r \in \Z_p$, the rerandomized commitment $\cm'$ is $\cm + \Delta_rH$ = $mG + rH + \Delta_rH$ = $mG + (r+\Delta_r)H$. This operation preserves the committed value $m$ while updating the randomness from $r$ to $r + \Delta_r$. $\cm'$ is computationally indistinguishable from $\cm$.

    \textbf{Two Party Protocol:} During credential generation, a two-party computation protocol establishes a shared secret between user and authority:
    \begin{enumerate}
        \item User generates secret share $s_1 \sample \Z_p$ and commits with randomness $r \sample \Z_p$: 
            $\cm_1 \gets s_1G + rH$
        \item Authority receives $\cm_1$, samples $s_2 \sample \Z_p$ and computes:
            $\cm_2 = s_2G + \cm_1 = (s_1 + s_2)G + rH$
        \item Authority returns $(\cm_2, s_2)$ to user who now holds shared secret $s_1 + s_2$
    \end{enumerate}
    
    Security holds against both malicious parties:
    \begin{itemize}
        \item \textbf{Unforgeability (malicious user):} The binding property ensures committed $s_1$ cannot be changed after authority responds (computational binding under DL assumption). Fresh $s_2$ per interaction prevents replay attacks.
        \item \textbf{Anonymity (malicious issuer):} Perfect hiding of $\cm_1$ ensures issuer learns nothing about $s_1$, while DL assumption prevents extraction even given $\cm_1$.
    \end{itemize}

    \item \textbf{Proofs of Knowledge}
    
\end{itemize}

\subsubsection{Security}
\textbf{From UTT}
We use a dual bilinear version of the well-known Pedersen commitment \cite{feigenbaum_non-interactive_1992}
The binding property holds under the SDL assumption of \cite{hutchison_get_2010}
which follows from 1-SDH of \cite{boneh_short_2008}. (See Section I for details.) 
As already mentioned, the hiding property hold information theoretically.



% % % % % % % % % % 
% 
% END Randomizable Vector Commitments
% 
% % % % % % % % % % 















% % % % % % % % % % 
% 
% PS Signature
% 
% % % % % % % % % % 
\newpage
\section{Rerandomizable Signature over Commitments}
Early work by Camenisch and Lysanskaya defined a multi-show attribute-based anonymous credential as a commitment and signature scheme with protocols to "issue blindly" - to receive a signature over-committed values without revealing the attributes during issuance and protocols to use the credential anonymously. The three main signature-based constructions are CL04, BBs+ and PS signatures. 

\noindent In this section, we analyze their relative merits as justification for settling on our construction. We demonstrate this variant of PS signatures offers a compelling advantage - they naturally output verified Pedersen commitments that integrate with standardised $\sigma-$protocols. Although this approach introduces small overhead, we argue the security benefits of using well-studied and well-understood proof protocols with pedersen commitments outweigh the computational overhead. 

To demonstrate the problem \ref{}
- Initial schemes BBS+, CL04, PS used sigma protocols with proofs in Gt. Computation is slow, group elements are large, implementations are more complex. 
- CL signatures can be rerandomized but the pairings are linear in the number of attributes. 
- BBS+ are constant size signatures but can't essentially be rerandomized because the message commitment is "intertwined" with the signature and thus the signature and committed messages must be proven together, this makes the proof more complex but overhead smaller.
- Anonymous Attestation improved BBS+ by proving in G1 adding overhead by 1 pairing and but because of the structure of the signature, remains complex zkp's
- UTT version added 2 pairings, proving in G1 but with the added simplicity of proving knowledge of a pedersen commitment. This is extremely important for practical use cases. 

Improvements started with
Anonymous Attestation - improved BBS+
CL04? not sure if it was improved
PS - improved, that's what we're using, the first to use it


















\subsubsection{Syntax}
\begin{itemize}
    \item $PS.KeyGen(\secparam, \ck) \to (\sk, \vk):$ Parse $\ck$ as $ck \gets (g, \gb, \tilg, \tilgb)$. Sample $x \sample \Zp$, set $(\sk, \vk) \gets (g^x, \tilg^x)$

    \item $PS.Sign_{ck}(\sk, \cm) \to \sigma:$ Parse $\ck$ as $\gets (g, \cdot, \tilg, \cdot)$ Sample $u \sample \Zp$, compute $\sigma_1 \gets g^u$, $\sigma_2 \gets (\sk \cdot \cm)^u$
     and return $\sigma \gets (\sigma_1, \sigma_2)$

     \item $PS.Rerand(\sigma, \rd, \ud) \to \sigma': $ Parse $\sigma$ as $(\sigma_1, \sigma_2)$. Compute $\sigma_1' \gets \sigma_1^{\ud}$ and $\sigma_2' \gets (\sigma_2 \cdot \sigma_1^{\rd})^{\ud}$. Return $\sigma' \gets (\sigma_1', \sigma_2')$

     \item $PS.Verify_{ck, vk}(\sigma, (\cm, \tilcm)) \to \bit: $ Verify $ZKPoK.Open_{ck}(\cm)$. Parse $\ck$ as $(g, \cdot, \tilg, \cdot)$ and $\sigma$ as $(\sigma_1, \sigma_2)$. Assert $e(\cm, \tilg) = e(g, \tilcm)$ and $e(\sigma_2, \tilg) = e(\sigma_1, \vk \cdot \tilcm)$

     \item $\mathsf{PS.VKey}(\sk, \vk)$ 
     
\end{itemize}
\subsubsection{Construction}
\begin{itemize}
    \item $PS.KeyGen_{\ck}(\secparam) \to (\sk, \vk):$ The PS Signature KeyGen algorithm is parameterized by the corresponding commitment key $\ck$. The Signer retreives $(g, \cdot, \tilg, \cdot)$ from $\ck$, samples secret $x \sample \Zp$, sets $X \gets g^x$ and $\tilx \gets \tilg^x$, sets $\sk$ as $(g, X)$ and the public verification key $\vk$ as $(\ck, \tilx)$ and returns $(\sk, \vk)$

    \item $PS.Sign_{\sk}(\cm) \to \sigma: $ The signing algorithm signs the commitment. Retreives $(g, \cdot, \tilg, \cdot)$ from $\ck$, Samples $u \sample \Zp$, Computes $\sigma_1$ as $g^u$ and $\sigma_2 \gets (X \cdot \cm)^u$ both are notably in $\G_1$ and thus $(X \cdot \cm)^u$ = $(g_1^{m_1u}\dots g_n^{m_nu}g^{xu+ru})$. Returns $\sigma \gets (\sigma_1, \sigma_2)$    

    \item $PS.Rerand(\sigma, \rd, \ud) \to \sigma':$ Parse $\sigma$ as $(\sigma_1, \sigma_2)$. Compute $\sigma_1' \gets \sigma_1^{\ud}$ and $\sigma_2' \gets (\sigma_2 \cdot \sigma_1^{\rd})^{\ud}$. Return $\sigma' \gets (\sigma_1', \sigma_2')$

    \item $PS.Verify(\sigma, (\cm, \tilcm)) \to \bit:$ Verify $ZKPoK.Open_{ck}(\cm)$. Parse $\ck$ as $(g, \cdot, \tilg, \cdot)$ and $\sigma$ as $(\sigma_1, \sigma_2)$. Assert $e(\cm, \tilg) = e(g, \tilcm)$ and $e(\sigma_2, \tilg) = e(\sigma_1, \vk \cdot \tilcm)$

    \item $\mathsf{PS.VKey}(\sk, \vk)$ 

\end{itemize}


\subsection{PS Signature over Commitment Construction}
\begin{itemize}
    \item $PS.Rerand_{ck,vk}(\sigma, \rd, \ud) \to \sigma'$: Rerandomization of the signature must preserve the algebraic properties of the commitment itself to allow the commitment to be used for zero knowledge proof protocols. To do so, the commitment is re-randomized with the random factor $\rd$ such that a commitment and signature pair 
\end{itemize}




% % % % % % % % % % 
% 
% END PS Signature
% 
% % % % % % % % % % 



































% % % % % % % % % % 
% 
% MIMC-ABC Construction
% 
% % % % % % % % % % 




\cleardoublepage
\section{Multi Issuer Multi Credential Anonymous Credentials (MIMC-ABC)}\label{sec:mimc}

We base our Multi Issuer, Multi Credential Multi-show Attribute based Anonymous Credentials off the model in \cite{fuchsbauer_structure-preserving_2019}


\subsection{Syntax}
\begin{definition}[MIMC-ABC System] A Multi-Issuer Multi-Credential Attribute based Anonymous Credential system consists of the following $\PPT$ algorithms:
    \begin{itemize}
    \item $\mathsf{Setup}(\secparam) \to (\ppar)$ Takes security parameter $\lambda$ in unary, outputs public parameters $\ppar$.

    \item $\mathsf{OrgKeygen}(\ppar, n) \torand (\osk, \opk)$: is a probabilistic algorithm that takes public parameters $\ppar$ and $n$ the upper bound of credential attributes. Outputs organisations keypair $(\osk, \opk)$

    \item $\mathsf{UserKeygen}(\secparam) \torand (\usk)$ is a probabilistic algorithm. Outputs user secret key $\usk$ consisting of PRF key $k$ and identity string $s$

    \item $(\mathsf{Obtain Master}(usk_m, \textbf{m}, aux), \mathsf{IssueMaster}(osk_m, cm, aux)) \to Cred_m:$ An interactive protocol. $Obtain Master$ is a probabilistic algorithm run by a user, inputs secret key, credential attribute vector $\textbf{m}$, and auxiliary info. $Issue Master$ is a probabilistic algorithm run by an issuing organization that takes a commitment $cm$, issuer secret key $osk_m$, and auxiliary info. Outputs a master credential $Cred_m$ binding $cm$ to the issuer signature.
    
    \item $(\mathsf{Obtain Context}(usk_c, \textbf{m}, Cred_m, aux), \mathsf{Issue Context}(opk_m, Cred_m', osk_c, cm, aux)) \to Cred_c:$ An interactive protocol. $Obtain Context$ is a probabilistic algorithm run by a user, inputs master credential $Cred_m$ and corresponding organisation public key $opk_m$, the users new secret key $usk_c$, credential attribute vector $\textbf{m}$, and auxiliary info. $Issue Context$ is a probabilistic algorithm run by an issuing organization that takes a commitment $cm$, issuer secret key $osk_c$, and auxiliary info. Outputs a credential $Cred_c$ binding $cm$ to the issuer signature.

    \item $(\mathsf{Show}(\{usk_i, cred_i\}_{i=1}^n, \phi), \mathsf{Verify}(\{cred'_i, opk_i\}_{i=1}^n, \pi)) \to \bit$ An interactive protocol. $Show$ is a probabilistic algorithm run by a user. Takes $n$ secret keys, $n$ credentials, and predicate statement $\phi$. $Verify$ is a deterministic algorithm run by a verifier, takes $n$ randomized credentials $cred'$ and associated public keys $opk$ and proof $\pi$. Outputs 1 if verification succeeds, otherwise 0.
\end{itemize}
\end{definition}



\subsection{Security Model}
We build upon the security model for Multi-Show ABCs from \cite{fuchsbauer_structure-preserving_2019} which is based on earlier work for group signatures \cite{hutchison_foundations_2005}. We extend it by supporting multiple organizations (issuers) with malicious keys for malicious issuer in anonymity, and support malicious users with credentials from multiple organizations. We add a Credential Binding property to enforce multi-credential, multi-issuer security.

\subsubsection{Security Properties}
% sec. property defines which party is malicious
Our Multi Issuer, Multi Credential Anonymous Credential system satisfies the following security and privacy properties:
\begin{enumerate}
    \item \textbf{Correctness: } a showing of a valid set of credentials and their corresponding commitments always verifies if the credentials are issued honestly and with respect to their corresponding issuer public keys. 
    
    \item \textbf{Unforgeability}: A malicious user can't show/verify attributes for credentials they don't own, can't mix credentials from different users, can't present a valid multi-credential proof without controlling all constituent credentials, can't replay a credential show from a different honest user. 
    
    \item \textbf{Anonymity:} A malicious verifier or organization can't identify the user or learn about the user more than the public information presented in the protocol, and that the credential satisfies the verification statement. The malicious verifier can't link multiple showings of the same credential, and for any set of credentials $\{Cred_1,\dots,Cred_n\}$ satisfying a predicate $\phi$, the adversary cannot distinguish whether they belong to the same or different users.

    \item \textbf{Credential Binding}: A malicious user cannot produce valid proofs linking credentials unless they were legitimately issued to the same user identifier. Specifically, an adversary cannot: combine credentials from different users into a valid multi-credential proof, even if each credential is individually valid. Can't create a valid linking proof without knowing the user secret for all constituent credentials, and can't forge proofs that falsely demonstrate credential ownership consistency

\end{enumerate}

\subsection{Model and Definitions}
We begin by presenting a model for privacy-preserving credential systems that supports multiple issuers and credential composition, extending the anonymous credential framework pioneered by \cite{hutchison_signature_2004}, extended in group signatures \cite{hutchison_foundations_2005} and modelled in an Attribute Based Anonymous Credential System \cite{fuchsbauer_structure-preserving_2019}.

\subsection{Global Variables}
At the beginning of each experiment, the following state is maintained:

\noindent \textbf{System Parameters:} For each issuer $i$, either the experiment computes an issuer keypair $(\mathsf{osk}_i, \mathsf{opk}_i)$ or the adversary outputs $\mathsf{opk}_i$. In the anonymity game, there is a challenge bit $b$, which the adversary must guess.

\noindent \textbf{User Management:} The system maintains:
\begin{itemize}
\item Sets $\mathsf{HU}$ and $\mathsf{CU}$ of honest and corrupted users
\item Lists $\mathsf{UPK}$, $\mathsf{USK}$ tracking user keypairs
\item Lists $\mathsf{CRED}$, $\mathsf{COM}$, $\mathsf{OWNR}$ recording credentials, their commitments, and ownership
\end{itemize}

\noindent \textbf{Challenge State:} For the anonymity game, sets $\mathcal{J}_{\mathsf{LoR}}$ and $\mathcal{I}_{\mathsf{LoR}}$ track credential tuples and corresponding users during challenge phases.

\noindent  Our model extends the ABC system from \cite{fuchsbauer_structure-preserving_2019} in two ways:
\begin{enumerate}
    \item \textit{Multi-Issuer Support:} Users can obtain and compose credentials from different issuers while maintaining privacy across contexts
    \item \textit{Credential Composition:} Users can prove statements about multiple credentials while preserving unlinkability both within and across showings
\end{enumerate}

\noindent  \textbf{The Oracles.} The security properties are defined via experiments where an adversary $\mathcal{A}$ interacts with the following oracles:

\noindent $\mathcal{O}_{\mathsf{HU}}(i)$ - By calling this honest user oracle with identity $i \in \mathbb{N}$, $\mathcal{A}$ can add $i$ to the set $\mathsf{HU}$ of honest users. The oracle generates $(\mathsf{usk}[i], \mathsf{upk}[i]) \sample \mathsf{UserKeyGen}(\mathsf{opk})$, adds $i$ to $\mathsf{HU}$, and returns $\mathsf{upk}[i]$.

\noindent $\mathcal{O}_{\mathsf{CU}}(i, \mathsf{upk})$ - By calling this corrupt user oracle with identity $i$ and optional public key $\mathsf{upk}$, $\mathcal{A}$ can either register a new corrupt user (if $i \notin \mathsf{HU}$) or corrupt an honest user (if $i \in \mathsf{HU}$). In the latter case, $\mathcal{A}$ receives $\mathsf{usk}[i]$ and all credentials.

\noindent $\mathcal{O}_{\mathsf{ObtIss}}(i, \mathbf{attrs}, aux)$ - This oracle represents the honest user execution of the Obtain-Issue protocol between an honest user and honest organization. In the unforgeability game (malicious user), this oracle lets the adversary observe honest protocol executions. 
By calling this obtain-issue oracle with identity $i$, attribute vector $\mathbf{attrs}$, and auxiliary information $aux$, $\mathcal{A}$ initiates an honest credential issuance. If $i \notin \mathsf{HU}$ (user is corrupt), returns $\bot$. Otherwise, computes $(\mathsf{cm}, r) \sample \mathsf{Com}(\mathbf{attrs})$ and runs the following honestly:
\[
(\mathsf{cred}, \top) \sample (\mathsf{Obtain}(\mathsf{usk}[i], \mathsf{opk}, \mathsf{cm}, r), \mathsf{Issue}(\mathsf{upk}[i], \mathsf{osk}, \mathsf{cm}))
\]
If $\mathsf{cred} = \bot$, returns $\bot$. Else appends $(i, \mathsf{cred}, \mathsf{cm})$ to $(\mathsf{OWNR}, \mathsf{CRED}, \mathsf{COM})$.

\noindent  $\mathcal{O}_{\mathsf{Obtain}}(i, \mathsf{cm})$ - 


Models a malicious issuer interacting with an honest user $i \in \mathsf{HU}$. Takes a commitment $\mathsf{cm}$ to attributes. If $i \notin \mathsf{HU}$, returns $\bot$. Runs:
\[
(\mathsf{cred}, \cdot) \sample (\mathsf{Obtain}(\mathsf{USK}[i], \mathsf{opk}, \mathsf{cm}), \cdot)
\]
where Issue is executed by $\mathcal{A}$. On success, appends $(i, \mathsf{cred}, \mathsf{cm})$ to $(\mathsf{OWNR}, \mathsf{CRED}, \mathsf{COM})$.

\noindent  $\mathcal{O}_{\mathsf{Issue}}(i, \mathsf{cm})$ - This oracle models a malicious user interacting with an honest issuer. Takes identity $i$ and commitment $\mathsf{cm}$. If $i \notin \mathsf{CU}$, returns $\bot$ ($\mathcal{O}_{\mathsf{Issue}}$ is only for Corrupt Users). Runs:
\[
(\cdot, I) \sample (\cdot, \mathsf{Issue}(\mathsf{UPK}[i], \mathsf{osk}, \mathsf{cm}))
\]
where Obtain is executed by $\mathcal{A}$. If $I$ = $\bot$, it returns $\bot$. Else, it appends $(i, \bot, \mathsf{cm}$ to $(\mathsf{OWNR}, \mathsf{CRED}, \mathsf{COM})$ and returns $\bot$.

\noindent  $\mathcal{O}_{\mathsf{Show}}(\mathsf{cred}, \phi)$ - Models credential verification with malicious verifier. Takes credential $\mathsf{cred}$ and predicate $\phi$. Let $i \gets \mathsf{OWNR}[\mathsf{cred}]$. If $i \notin \mathsf{HU}$, returns $\bot$. Runs:
\[
(S, \cdot) \sample (\mathsf{Show}(\mathsf{opk}, \phi, \mathsf{cred}), \cdot)
\]
where Verify is executed by $\mathcal{A}$.

\noindent $\mathcal{O}_{\mathsf{LoR}}(\mathsf{Creds}_0, \mathsf{Creds}_1, \phi)$ - By calling this challenge oracle, $\mathcal{A}$ attempts to distinguish between two credential sets in an anonymous showing. Each $\mathsf{Creds}_b = (\mathsf{cred}_{b,1},\ldots,\mathsf{cred}_{b,n})$ represents a tuple of credentials, where each credential contains a commitment to its attributes. The oracle enforces that credentials within each tuple belong to the same user (binding) while maintaining unlinkability across showings. The predicate $\phi: \mathsf{COM}^n \rightarrow \{0,1\}$ validates statements over committed attributes. If $\mathcal{J}_{\mathsf{LoR}} \neq \emptyset$ and $\mathcal{J}_{\mathsf{LoR}} \neq \{\mathsf{Creds}_0, \mathsf{Creds}_1\}$, returns $\bot$. Otherwise, verifies single ownership and honest user conditions, then executes:
$(S, \cdot) \sample (\mathsf{Show}(\mathsf{opk}, \phi, \mathsf{Creds}_b), \cdot)$


\subsubsection{Correctness}
\begin{definition}[MIMC-ABC Correctness]
A Multi-Issuer Multi-Credential Anonymous Credential system (MIMC-ABC) is correct if for all security parameters $\lambda > 0$, the following properties hold for all honestly generated credentials where attributes are committed using commitment scheme $\mathsf{Com}$

\begin{enumerate}
    \item Individual Validity: For each credential $cred_i $with commitment $cm_i$ = $Com(attrs_i; r_i)$, the credential verifies independently under its issuer's public key $opk_i$

    \item Multi-Issuer Composition: For any set of credentials ${cred_1,...,cred_n}$ with corresponding commitments ${cm_1,...,cm_n} $belonging to the same user, any valid predicate $\phi$ over their committed attributes verifies successfully and $\phi$ enforces the user owning credentials

    \item Commitment Binding: The showing protocol preserves the binding between credentials and their committed attributes while maintaining zero-knowledge
\end{enumerate}

\noindent More formally:
\[
        \Pr
            \left [
            \begin{array}{l}
                (osk_i, opk_i) \sample OrgKeyGen(\secparam \text{ for } i \in [n]),\\
                (usk, upk) \sample UserKeyGen(opk),\\
                (cm_i, r_i) \sample Com(\mathbf{attrs}_i) \text{ for } i \in [n],\\
                (\mathsf{cred}_i, \top) \sample (Obtain(usk, opk_i, cm_i),\\
                \quad Issue(upk, osk_i, cm_i)) \text{ for } i \in [n],\\
            \end{array}
                : 
                \begin{array}{l}
                    (\top, 1) \sample (Show(opk, \phi, \{\mathsf{cred}_i\}_{i \in [n]}),\\
                    \quad Verify(opk, \phi))
                \end{array}
                \right ]
             = 1
\]
\end{definition}


\newpage

\subsubsection{Unforgeability}
Unforgeability models security against malicious users. The definition gives the adversary (representing malicious users) access to oracles 
\begin{itemize}
    \item $\mathcal{O}_{\mathsf{HU}}$ to create honest users, $\mathcal{O}_{\mathsf{CU}}$ to corrupt users
    \item $\mathcal{O}_{\mathsf{ObtIss}}$ Complete honest Obtain-Issue protocol execution between honest user and issuer
    \item $\mathcal{O}_{\mathsf{Issue}}$ Protocol interaction where $\Adv$ plays malicious user to obtain credentials from honest issuer
    \item $\mathcal{O}_{\mathsf{Show}}$: Observe honest users' credential showings
\end{itemize}
Note that the unforgeability game lacks access to $\mathcal{O}_{\mathsf{Obtain}}$ because it models malicious issuer behavior. 

\noindent The game proceeds as follows:
\begin{enumerate}
    \item Honest issuer generates keys $(\osk, \opk) \gets \mathsf{OrgKeyGen(\secparam)}$
    \item $\Adv$ can create/corrupt users, obtain credentials legitimately, and observe honest showings
    \item $\Adv$ wins if it produces a valid showing for attributes not contained in any credential owned by corrupt users
\end{enumerate}
This captures threats of individual credential forgeries, credential pooling attempts, and replay attacks.

\begin{definition}[MIMC-ABC Unforgeability]
\noindent A Multi-Issuer Multi-Credential Anonymous Credential system provides unforgeability if no probabilistic polynomial-time adversary $\mathcal{A}$ can:
\begin{enumerate}
    \item forge valid credentials for honest users
    \item use credentials belonging to other users
    \item combine multiple credentials to create new ones
    \item replay a credential showing from a different user
\end{enumerate}

\noindent More formally, for any PPT adversary $\mathcal{A}$, the following probability is negligible in $\lambda$:
\[ \Pr[\mathsf{Exp}^{\mathsf{unf}}_{\mathsf{MIMC\mbox{-}ABC},\mathcal{A}}(1^\lambda) = 1] \leq \mathsf{negl}(\lambda) \]
\end{definition}

\noindent \textbf{MIMC-ABC Unforgeability} 
The experiment $\mathsf{Exp}^{\mathsf{unf}}_{\mathsf{MIMC\mbox{-}ABC},\mathcal{A}}(1^\lambda)$ proceeds as follows:

\begin{enumerate}
    \item Setup Phase:
    \begin{itemize}
        \item For each issuer $i \in [n]$: $(osk_i, opk_i) \sample \mathsf{OrgKeyGen}(1^\lambda)$
        \item Initialize $\mathsf{HU, CU} \gets \emptyset$
        \item Initialize $\mathsf{CRED, COM, OWNR} \gets \emptyset$
    \end{itemize}

    \item Query Phase: $\mathcal{A}^{\mathcal{O}}(1^\lambda, \{opk_i\}_{i \in [n]})$ where $\mathcal{O}$ includes:
    \begin{itemize}
        \item $\mathcal{O}_{\mathsf{HU}}, \mathcal{O}_{\mathsf{CU}}$ (user management)
        \item $\mathcal{O}_{\mathsf{ObtIss}}, \mathcal{O}_{\mathsf{Issue}}$ (credential operations)
        \item $\mathcal{O}_{\mathsf{Show}}$ (showing protocol)
    \end{itemize}

    \item Forgery Phase: $\mathcal{A}$ outputs $(\{\mathsf{cred}_i\}_{i \in [k]}, \phi, \pi)$

    \item The experiment returns 1 if:
    \begin{itemize}
        \item $\mathsf{Verify}(opk, \phi, \{\mathsf{cred}_i\}_{i \in [k]}, \pi) = 1$ and
        \item At least one of the following holds:
            \begin{enumerate}
                \item $\exists i: \mathsf{cred}_i \notin \mathsf{CRED}$ (credential forgery)
                \item $\exists i,j: \mathsf{OWNR}(\mathsf{cred}_i) \neq \mathsf{OWNR}(\mathsf{cred}_j)$ (mixed ownership)
                \item $\mathsf{OWNR}(\mathsf{cred}_1) \in \mathsf{HU}$ (honest user credential misuse)
            \end{enumerate}
    \end{itemize}
\end{enumerate}












\newpage
\subsubsection{Anonymity}
Anonymity models security against malicious issuers and verifiers. The definition gives the adversary $\Adv$ (representing malicious issuer and verifier) access to oracles
\begin{itemize}
    \item $\mathcal{O}_{\mathsf{HU}}$ to create honest users, $\mathcal{O}_{\mathsf{CU}}$ to corrupt users
    \item $\mathcal{O}_{\mathsf{Obtain}}$: Protocol interaction where $\Adv$ plays malicious issuer to issue credentials to honest users
    \item $\mathcal{O}_{\mathsf{Show}}$: Protocol interaction where $\Adv$ plays malicious verifier observing credential showings
    \item $\mathcal{O}_{\mathsf{LoR}}$: The challenge oracle providing $\Adv$ showing transcripts from either credential $j_0$ or $j_1$ based on challenge bit $b$
\end{itemize}
Note that the anonymity game lacks access to $\mathcal{O}{\mathsf{Issue}}$ because, as a malicious issuer, it can use its $(opk, osk)$ in a real protocol run, and lacks access to $\mathcal{O}_{\mathsf{ObtIss}}$ as that oracle models honest issuance. Instead, the anonymity game needs $\mathcal{O}_{\mathsf{Obtain}}$ to allow honest users to obtain credentials from the malicious issuer ($\Adv$).

\noindent The Anonymity Game proceeds as follows
\begin{enumerate}
    \item $\Adv$ generates (potentially) malicious organization keys $(opk, st) \gets \Adv(\secparam)$
    \item $\Adv$ can create honest users, issue them credentials (as a malicious issuer), and observe their showings (as a malicious verifier)
    \item For the challenge, $\Adv$ selects 2 users' credentials and must distinguish which is being shown
    \item $\Adv$ wins if it correctly guesses bit $b$ used by $\mathcal{O}_{\mathsf{LoR}}$
\end{enumerate}

\begin{definition}[MIMC-ABC Anonymity]
A Multi-Issuer Multi-Credential Anonymous Credential system provides anonymity if no probabilistic polynomial-time adversary $\mathcal{A}$ can:

\begin{enumerate}
    \item learn any information beyond the public information
    \item link multiple showings of the same credential
    \item correlate different credentials belonging to the same user
    \item identify which credentials were issued by the same issuer
\end{enumerate}

\noindent More formally, for any PPT adversary $\mathcal{A}$, the following advantage is negligible in $\lambda$:
\[ \mathsf{Adv}^{\mathsf{anon}}_{\mathsf{MIMC\mbox{-}ABC},\mathcal{A}}(\lambda) := |\Pr[\mathsf{Exp}^{\mathsf{anon\mbox{-}1}}_{\mathsf{MIMC\mbox{-}ABC},\mathcal{A}}(1^\lambda) = 1] - \Pr[\mathsf{Exp}^{\mathsf{anon\mbox{-}0}}_{\mathsf{MIMC\mbox{-}ABC},\mathcal{A}}(1^\lambda) = 1]| \leq \mathsf{negl}(\lambda) \]
\end{definition}


\noindent \textbf{MIMC-ABC Anonymity Experiment.} 
The experiment $\mathsf{Exp}^{\mathsf{anon\mbox{-}b}}_{\mathsf{MIMC\mbox{-}ABC},\mathcal{A}}(1^\lambda)$ proceeds as follows:

\begin{enumerate}
    \item Setup Phase:
    \begin{itemize}
        \item For each issuer $i \in [n]$: $(osk_i, opk_i) \sample \mathsf{OrgKeyGen}(1^\lambda)$
        \item Initialize $\mathsf{HU, CU} \gets \emptyset$
        \item Initialize $\mathsf{CRED, COM, OWNR} \gets \emptyset$
        \item Initialize $\mathcal{J}_{\mathsf{LoR}}, \mathcal{I}_{\mathsf{LoR}} \gets \emptyset$
        \item Sample challenge bit $b \sample \{0,1\}$
    \end{itemize}

    \item Query Phase: $\mathcal{A}^{\mathcal{O}}(1^\lambda, \{opk_i\}_{i \in [n]})$ where $\mathcal{O}$ includes:
    \begin{itemize}
        \item $\mathcal{O}_{\mathsf{HU}}, \mathcal{O}_{\mathsf{CU}}$ (user management)
        \item $\mathcal{O}_{\mathsf{Obtain}}, \mathcal{O}_{\mathsf{Issue}}$ (credential operations)
        \item $\mathcal{O}_{\mathsf{Show}}$ (showing protocol)
        \item $\mathcal{O}_{\mathsf{LoR}}$ (challenge oracle)
    \end{itemize}

    \item Challenge Phase: 
    $\mathcal{A}$ can query $\mathcal{O}_{\mathsf{LoR}}(\mathsf{Creds}_0, \mathsf{Creds}_1, \phi)$ where:
    \begin{itemize}
        \item $\mathsf{Creds}_b = (\mathsf{cred}_{b,1},...,\mathsf{cred}_{b,n})$ for $b \in \{0,1\}$
        \item Credentials in each tuple must belong to the same user
        \item Both credential sets must satisfy predicate $\phi$
    \end{itemize}

    \item $\mathcal{A}$ outputs a guess $b' \in \{0,1\}$

    \item The experiment returns 1 if $b = b'$
\end{enumerate}




\newpage
\subsubsection{Credential Binding}
Credential binding models security against malicious users attempting to combine credentials across different user identities. The definition gives the adversary (representing malicious users) access to oracles
\begin{itemize}
    \item $\mathcal{O}_{\mathsf{HU}}$ to create honest users, $\mathcal{O}_{\mathsf{CU}}$ to corrupt users
    \item $\mathcal{O}_{\mathsf{ObtIss}}$ Complete honest Obtain-Issue protocol execution between honest user and issuer
    \item $\mathcal{O}_{\mathsf{Issue}}$ Protocol interaction where $\Adv$ plays malicious user to obtain credentials from honest issuer
\end{itemize}
Note that like unforgeability, the binding game lacks access to $\mathcal{O}_{\mathsf{Obtain}}$ as it models malicious user behavior. We also omit $\mathcal{O}_{\mathsf{Show}}$ since observing honest showings does not help in violating binding property.

\noindent The game proceeds as follows:
\begin{enumerate}
    \item Each honest issuer generates keys $(osk_i, opk_i) \gets \mathsf{OrgKeyGen(\secparam)}$
    \item $\Adv$ can create/corrupt users and obtain credentials legitimately from honest issuers
    \item $\Adv$ wins if it produces a valid proof linking credentials that were issued to different user identifiers
\end{enumerate}
This captures the essential requirement that credentials can only be combined in proofs if they share the same underlying user identity, analogous to the binding property in commitment schemes but extended to the multi-credential setting.

We define Binding Constraint and then use it in the Credential Binding game. 
\begin{definition}[Binding Constraint]
A predicate $\phi$ contains a binding constraint if it requires proving equality of user identifiers across credentials. Formally, $\phi \in \Phi_{\mathsf{binding}}$ if:
\begin{enumerate}
    \item $\phi: \mathsf{CRED}^k \rightarrow \{0,1\}$ where $k \geq 2$
    \item For credentials $\{\mathsf{cred}_i\}_{i \in [n]}$ with user identifiers $\{s_i\}_{i \in [n]}$:
        \[ \phi(\{\mathsf{cred}_i\}_{i \in [n]}) = 1 \implies s_1 = s_2 = ... = s_n \]
    \item The proof $\pi$ must demonstrate knowledge of openings that satisfy this equality
\end{enumerate}
\end{definition}

\begin{definition}[MIMC-ABC Credential Binding]
A Multi-Issuer Multi-Credential Anonymous Credential system provides credential binding if no probabilistic polynomial-time adversary $\mathcal{A}$ can successfully combine credentials from different user identities into a valid proof. Specifically, $\mathcal{A}$ cannot:
\begin{enumerate}
    \item produce a valid proof linking credentials issued to different user identifiers
    \item create a valid multi-credential proof without knowing all constituent credential openings
    \item forge proofs that falsely demonstrate credential ownership consistency across issuers
\end{enumerate}

\noindent More formally, for any PPT adversary $\mathcal{A}$, the following probability is negligible in $\lambda$:
\[ \Pr[\mathsf{Exp}^{\mathsf{bind}}_{\mathsf{MIMC\mbox{-}ABC},\mathcal{A}}(1^\lambda) = 1] \leq \mathsf{negl}(\lambda) \]
\end{definition}

\noindent \textbf{MIMC-ABC Credential Binding} 
The experiment $\mathsf{Exp}^{\mathsf{bind}}_{\mathsf{MIMC\mbox{-}ABC},\mathcal{A}}(1^\lambda)$ proceeds as follows:

\begin{enumerate}
    \item Setup Phase:
    \begin{itemize}
        \item For each issuer $i \in [n]$: $(osk_i, opk_i) \sample \mathsf{OrgKeyGen}(1^\lambda)$
        \item Initialize $\mathsf{HU, CU} \gets \emptyset$
        \item Initialize $\mathsf{CRED, COM, OWNR} \gets \emptyset$
    \end{itemize}

    \item Query Phase: $\mathcal{A}^{\mathcal{O}}(1^\lambda, \{opk_i\}_{i \in [n]})$ where $\mathcal{O}$ includes:
    \begin{itemize}
        \item $\mathcal{O}_{\mathsf{HU}}, \mathcal{O}_{\mathsf{CU}}$ (user management)
        \item $\mathcal{O}_{\mathsf{ObtIss}}, \mathcal{O}_{\mathsf{Issue}}$ (credential operations)
    \end{itemize}

    \item Challenge Phase: $\mathcal{A}$ outputs $(\{\mathsf{cred}_i\}_{i \in [n]}, \phi, \pi)$

    \item The experiment returns 1 if:
    \begin{enumerate}
        \item $\phi \in \Phi_{\mathsf{binding}}$
        \item $\mathsf{Verify}(opk, \phi, \{\mathsf{cred}_i\}_{i \in [n]}, \pi) = 1$
        \item At least one of:
            \begin{enumerate}
                \item $\exists \; i,j: \mathsf{OWNR}(\mathsf{cred}_i) \neq \mathsf{OWNR}(\mathsf{cred}_j)$ - credentials from different owners
                \item $\exists \; i: \mathsf{cred}_i \notin \mathsf{CRED}$ - a forged credential
                \item $\exists \; i: \mathsf{OWNR}(\mathsf{cred}_i) \notin \mathsf{CU}$ - using honest user's credential
            \end{enumerate}
    \end{enumerate}
\end{enumerate}



















\newpage
\subsection{MIMC-ABC Construction}\label{sec:mimcabc-construction}
\subsubsection{Intuition of our Construction}

Our construction builds a new anonymous credential building block for multi-issuer, multi-credential systems. The key insight is combining three well-known cryptographic primitives using clever modifications that achieves privacy, efficiency, and practical deployment requirements.

\begin{enumerate}
    \item \textbf{Modified Rerandomizable Pointcheval-Sanders Signatures:} 
    Our construction builds on Pointcheval-Sanders signatures which provide constant-sized signatures and efficient verification via bilinear pairings. We employ the modification in \cite{tomescu2022utt}, rather than randomizing just the signature, then proving knowledge of messages with respect to the randomized signature, we first randomize the commitment with $\Delta_u$, then randomize the signature with the commitment randomness $\Delta_u$ and new randomness $\Delta_r$.
    
    The modification removes the need to run zero-knowledge protocols on the randomized signature, which are bespoke for this scheme and often needed in anonymous credentials e.g. \cite{sako_short_2016, hutchison_signature_2004}. Instead, ours outputs a verified randomized Pedersen commitment to be used in standardized zero-knowledge proof protocols \cite{stephan_krenn_proposal_nodate}, which are widely used with security reducing to the original PS signature under the q-SDH assumption. Furthermore, our modification avoids sigma protocols with computation in $\G_2$ significantly reducing overhead. 
    
    \item \textbf{Commitment Scheme: } 
    We employ a dual Pedersen Commitment, inspired by \cite{tomescu2022utt} that maintains commitments in both $\G_1$ and $\G_2$ of our bilinear group, which is needed to support the modification mentioned above. We leverage key properties of Pedersen Commitments throughout our system
    \begin{enumerate}
        \item Perfect hiding supports statistical zero knowledge 
        \item Computational binding under the discrete log assumption supports unforgeability of signatures
        \item Position binding adds functionality to our zero knowledge proof protocols, specifically for proving attributes at the same position of a message vector are equal
        \item Homomorphic properties support complex interactive protocols as in Figures \ref{fig:master-cred-issuance}
    \end{enumerate}

    \item \textbf{Zero-Knowledge Proofs} 
    Our construction liberally employs Sigma protocols for proving statements about committed attributes. While these proofs scale linearly with attributes and credentials being verified i.e., $\mathcal{O}(n + m)$ where $n$ attributes across $m$ credentials. The security reduces to the discrete logarithm assumption in the underlying groups, aligning with our commitment scheme security assumptions. The combination of Sigma protocols and Pedersen commitments enables: Selective attribute disclosure, complex predicate proofs over committed values, Support for AND/OR/NOT logic, and greater than proofs.

\end{enumerate}


\subsubsection{Example} Consider an employers recruitment scenario where they wish to verify personal information, $\phi$ requires proving three credentials as in Figure \ref{fig:three-creds} :
\begin{enumerate}
    \item Possession of a valid master credential
    \item Possession of a driver's license
    \item An Australian University degree (revealing the degree name)
\end{enumerate}

\begin{figure}
        \begin{pchstack}[boxed, center, space=4em]
            \begin{pcvstack}
                \procedure[space=auto]{Master Credential}{%
                s: 12345, \\
                k: 89898, \\
                ctx: "master", \\
                exp: 01/01/2030, \\
                \ldots \\
                }
            \end{pcvstack}
            \pcvspace
            \begin{pcvstack}
                \procedure[space=auto]{Driver License}{%
                s: 12345, \\
                \delta: VRF(k, "dmv"), \\
                ctx: "dmv", \\
                exp: 02/02/2027, \\
                \ldots \\
                }
            \end{pcvstack}
            \pcvspace
            \begin{pcvstack}
                \procedure[space=auto]{University Degree}{%
                s: 12345, \\
                \delta: VRF(k, "usyd{-}bcompsc"), \\
                ctx: "usyd{-}bcompsc", \\
                issued: 06/06/2020, \\
                \ldots \\
                }
            \end{pcvstack}
        \end{pchstack}
    \caption{Three Example Credentials}
    \label{fig:three-creds}
\end{figure}

\noindent A user with three valid credentials first rerandomizes their signatures and commitments:
\begin{align*}
    \cm_i' \gets& \mathsf{Com.Rerand}(\cm_i, \Delta_{r_i}) \text{ for } i \in [1,3] \\
    \sigma_i' \gets& \mathsf{PS.Rerand}(\sigma_i, \Delta_{r_i}, \Delta_{u_i} \text{ for } i \in [1,3])
\end{align*}
The rerandomized credentials and commitments $\cm_i', \sigma_i'$ are now indistinguishable from their original issuance.  
Next, the user and verifier interact in a two-party protocol where the user first verifies the randomized signatures and their commitments, 
\[
\mathsf{PS.Verify}(\sigma_i',\cm_i',pk_i') = 1 \quad \forall i \in [3]
\]

\noindent Let $\mathcal{R}$ be a relation for public input $(\sigma_m', \sigma_d', \sigma_u', pk_m, pk_d, pk_u, \cm_m', \cm_d', \cm_u')$ where:

$\mathcal{R}$ = {$(s, k, r_m, r_d, r_u, \delta_d, \delta_u, \mathsf{ctx}_m, \mathsf{ctx}_d, \mathsf{ctx}_u, \mathsf{exp}_m, \mathsf{exp}_d, \mathsf{issued}_u)$:
\begin{align*}
    \cm_m &= \mathsf{CM.Com}([s, k, \mathsf{ctx}_m, \mathsf{exp}_m]; r_m) \; \wedge \; \mathsf{exp}_m > \mathsf{today} \; \wedge \mathsf{ctx}_m = \text{"master"} \; \wedge\\
    \cm_d &= \mathsf{CM.Com}([s, \delta_d, \mathsf{ctx}_d, \mathsf{exp}_d]; r_d) \; \wedge \; \mathsf{exp}_d > \mathsf{today} \; \wedge \mathsf{ctx}_d = \text{"dmv"} \; \wedge\\
    \cm_u &= \mathsf{CM.Com}([s, \delta_u, \mathsf{ctx}_u, \mathsf{issued}_u]; r_u) \; \wedge \; \mathsf{ctx}_u \in \mathcal{D} \; \wedge\\
    s &= \cm_m[0] = \cm_d[0] = \cm_u[0]
\end{align*}





\subsubsection{Outline}
Our credential system operates over attribute space $\Z_p$ with arbitrary string attributes mapped to field elements by a collision-resistant hash function $H: \bit^* \to \Z_p$. A credential for user $i$ consists of a 
commitment $\cm_i \gets \mathsf{CM.Commit}([attr_1,\ldots,attr_n]; r)$ to $n$ attributes with randomness $r \sample \Z_p^*$, a Pointcheval-Sanders signature $\sigma \gets \mathsf{PS.Sign}(\cm_i, \mathsf{osk})$ on the commitment, verifiable by $\mathsf{PS.Verify}(\sigma, \cm_i, \mathsf{opk}) = 1$

\subsubsection{Freshness}
To prevent replay attacks in credential show/verify protocols, we employ an interactive challenge-response mechanism as per Sigma protocols \textbf{Cite Sigma Protocols}. During showing, the verifier provides a random challenge that must be incorporated in the zero-knowledge proofs, ensuring uniqueness of each showing. Interaction could be removed using the Fiat-Shamir transform \textbf{Cite Fiat Shamir}, this would require verifiers to maintain a list of used proofs introducing overhead and potential security concerns in a multi-verifier/distributed setting.

\newpage
\subsubsection{Malicious Organization Keys.}
For our PS signature-based ABC system, we define an NP-relation $\mathcal{R}_O$ capturing well-formed organization keys:
$$ ((pk, pp_{cm}), (sk, r)) \in \mathcal{R}_O \iff \mathsf{PS.VKey}(sk, pk) = 1 \land pp_{cm} = \mathsf{Setup}(1^\lambda; r) $$

During credential issuance, the organization must provide a zero-knowledge proof of knowledge 
$\pi \gets \mathsf{ZKPoK}\{(sk,r): ((pk, pp_{cm}), (sk,r)) \in \mathcal{R}_O\}$. 
This ensures:
\begin{itemize}
    \item The organization knows its PS signing key $sk$
    \item The commitment parameters $pp_{cm}$ are properly generated with known randomness $r$
\end{itemize}



























\newpage
\subsection{Master Credential Issuance}
The master credential issuance protocol enables a user to obtain their root credential from the Master Credential Oracle $\MCO$ while preserving the privacy of their VRF key $k$ and ensuring accountability. The protocol combines verifiable encryption, Verifiable Random Function, Zero Knowledge Proofs, and Rerandomizable PS Signatures over commitments to achieve Sybil Resistance, Revocation, and Anonymity.

\begin{figure}
    \begin{center}
    \begin{tabular}{l@{\hspace{12em}}c@{\hspace{12em}}l}
    \multicolumn{3}{l}{$\underline{Setup(1^{\lambda}, 1^n)}$:} \\[0.5em]
    \multicolumn{3}{l}{System: $(\G_1, \G_2, e, g, \tilg ) \gets BG.Gen(\secparam, p), \; ck_m \gets CM.Setup(BG, \secparam, n)$} \\[1em]
    \multicolumn{3}{l}{Credential Oracle: $(SK_m, PK_m) \gets PS.KeyGen(ck_m)$} \\[1em]
    \multicolumn{3}{l}{Auditor: $(SK_A, PK_A) \gets TPKE.KeyGen(ck_m)$} \\[1em]
    \multicolumn{3}{l}{Auditor setup Revocation List} \\[1em]
    \underline{User($s$)} && \underline{MCO($SK_M$)} \\[0.5em]
    \multicolumn{3}{l}{$k_1 \gets \Z_p$, \; $C_1 \gets Com([0,k_1,0,0],r)$}\\[1em]
    \multicolumn{3}{l}{$\Pi_1 \gets ZKPoK.Prove_{Zeros}(C_1)(k_1, r)$} \\[1em]
    & $\xrightarrow{C_1, \Pi_1}$ & \\[1em]
    \multicolumn{3}{r}{If $ZKPoK.Verify_{Zeros}(\Pi_1, C_1) = 0, $ return $ \bot$} \\[1em]
    \multicolumn{3}{r}{$k_2 \gets \Z_p, \; C_2 \gets Com([s, k_2, "master", attrs], 0)$} \\[1em]
    \multicolumn{3}{r}{$C_m \gets C_1 \cdot C_2 = Com([s,k_1+k_2,"master", attrs], r)$} \\[1em]
    & $\xleftarrow{C_2, C_m, s, k_2}$ & \\[1em]
    \multicolumn{3}{l}{$k \gets k_1 + k_2$} \\[1em]
    \multicolumn{3}{l}{$\Pi_2 \gets ZKPoK.Prove_{addition}(C_1, C_2, C_m)(k_1, k_2, k, r)$} \\[1em]
    \multicolumn{3}{l}{$\tau \gets Enc(PK_A, k)$} \\[1em]
    \multicolumn{3}{l}{$\Pi_3 \gets ZKPOK.Prove_{enc}(C_m)(\tau, k, r)$} \\[1em]
    & $\xrightarrow{C_1, C_2, C_m, \Pi_2, \Pi_3, \tau}$ &\\[1em]
    \multicolumn{3}{r}{If $ZKPOK.Verify_{addition}(\Pi_2, C_1, C_2, C_m) = 0, \;$ return $\bot$} \\[0.5em]
    \multicolumn{3}{r}{If $ZKPOK.Verify_{enc}(C_m)(\Pi_3, PK_A, \tau)  = 0, \;$ return $\bot$} \\[0.5em]
    \multicolumn{3}{r}{$\sigma_m \gets PS.Sign(SK_M, C_1)$} \\[0.5em]
    \multicolumn{3}{r}{Store Data Record MCO $(C_m, \sigma_m, \tau, \Pi_2, \Pi_3, C_1, C_2, k_2)$ } \\[1em]
    & $\xleftarrow{\sigma_m}$ & \\[1em]
    \multicolumn{3}{l}{If $PS.Verify(PK_A, \sigma_m, C_m) = 1$, Store $Cred_m(\sigma_m, C_m)$} \\[1em]
    \end{tabular}
    \end{center}
    \caption{Master Credential Issuance}
    \label{fig:master-cred-issuance}
\end{figure}


\paragraph{Informal Security Analysis}

The two-party process between the user and master credential oracle ensures sybil resistance of unique identifier $s$; the oracle has access to the user information and checks duplicate issuance within their own identity system. 
During VRF key issuance, the anonymity of the master credential is preserved via the secrecy of the VRF key $k$. During the two-party computation, the user's share $k_1$ remains hidden to $\MCO$ via the hiding property of the commitment $C_1$, and malicious commitment usage is prevented by the soundness property of $\Pi_1$. 

\noindent The user combines  $k_1 + k_2$ to form their VRF key, $\Pi_2$ proves $k_1$ is correctly derived from $C_1$, $k_2$ is derived from $C_2$ and $k$ combines $k_1 + k_2$, $\MCO$'s input to $k$ prevents forgery attempts on the key $k$. The hiding property of the commitments and zero-knowledge property of the proofs ensures correct protocol adherence while maintaining private computation. Revocation is enabled by encryption of the VRF key $k$ with the public key of the Auditor $PK_A$. $\Pi_3$ proves that $\tau$ is an encryption of the committed key $k$. $\tau$ is stored with the credential oracle maintaining privacy during normal operation. Finally, the protocol prevents replay attacks by using interactive zero-knowledge proofs requiring a challenge from the verifier, fresh commitment randomness, and $\MCO$'s input of their share of the VRF key $k_2$ preventing existing transcript reuse.



\newpage
\subsection{Context Credential Issuance}
Context Credential Issuance enables a user to obtain a context-specific credential while proving ownership of a valid master credential. The user first constructs a commitment to their context credential attributes, including their identity $s$ and a deterministic nullifier derived from their VRF key $k$ and the credential context $ctx$. Through zero-knowledge proofs, the user demonstrates their master credential is valid and unrevoked, and proves the context commitment is well-formed with the same identity $s$. The nullifier $\tau$ = $VRF(k,ctx)$ prevents multiple credentials for the same context while maintaining privacy. Upon successful verification, the Context Credential Oracle signs the commitment and records the nullifier.
\begin{figure}
        \begin{center}
        \begin{tabular}{l@{\hspace{12em}}c@{\hspace{12em}}l}
        \multicolumn{3}{l}{$\underline{Setup(1^{\lambda}, 1^n)}$:} \\[0.5em]
        \multicolumn{3}{l}{System: $(\G_1, \G_2, e, g, \tilg ) \gets BG.Gen(\secparam, p), \; ck_c \gets CM.Setup(BG, \secparam, n)$} \\[1em]
        \multicolumn{3}{l}{Credential Oracle: $(SK_c, PK_c) \gets PS.KeyGen(ck_c)$} \\[1em]
        \underline{User($Cred_m, s, k$)} && \underline{CCO($SK_c$)} \\[0.5em]
        \multicolumn{3}{l}{$\delta \gets VRF(k, ctx)$} \\[1em]
        \multicolumn{3}{l}{$r* \sample Z_p, \; C_c \gets Com([s,\delta,ctx,attrs],r*)$} \\[1em]
        \multicolumn{3}{l}{$\Pi_4 \gets ZKPoK.Prove_{selective-disclosure}(C_c,\delta,ctx,attrs)(s, r*)$} \\[1em]
        \multicolumn{3}{l}{$r' \sample \Z_p, Cred_{m}' \gets Cred.Rerand(Cred_{m}, r')$} \\[1em]
        \multicolumn{3}{l}{$\Pi_5 \gets ZKSoK.Prove(Cred_m')(s,k,master,attrs,r')$} \\[1em]
        \multicolumn{3}{l}{Parse $Cred_m'$ as $C_m', \sigma_m'$} \\[1em]
        \multicolumn{3}{l}{$\Pi_6 \gets ZKPoK.Prove_{reciprocal}(C_m', C_c,ctx)(s,k,r',r*)$}  \\[1em]
        \multicolumn{3}{l}{$\Pi_7 \gets ZKPoK.Prove_{equality}(C_m', C_c)(s, r)$} \\[1em]
        & $\xrightarrow{Cred_m', C_c, \Pi_4, \Pi_5, \Pi_6, \Pi_7}$ & \\[1em]
        \multicolumn{3}{r}{If} \\[1em]
        \multicolumn{3}{r}{$ZKPok.Verify_{selective-disclosure}(\Pi_4, C_c)(\delta, ctx, attrs)$ = 1 $\; \wedge$} \\[1em]
        \multicolumn{3}{r}{$ZKSoK.Verify(\Pi_5, Cred_m')$ = 1 $\; \wedge$} \\[1em]
        \multicolumn{3}{r}{$ZKPoK.Verify_{reciprocal}(\Pi_6, C_m', C_c, ctx)$ = 1 $\; \wedge$} \\[1em]
        \multicolumn{3}{r}{$ZKPoK.Verify_{equality}(\Pi_7, C_m', C_c)$ = 1 $\; \wedge$} \\[1em]
        \multicolumn{3}{r}{$\sigma_c \gets PS.Sign(SK_c, C_c)$} \\[1em]
        \multicolumn{3}{r}{Store Data Record CCO $(C_c, \sigma_c, \delta, \Pi_4, \Pi_5, \Pi_6, \Pi_7 )$} \\[1em]
        & $\xleftarrow{\sigma_c}$& \\[1em]
        \multicolumn{3}{l}{If $PS.Verify(PK_c,\sigma_c, C_c) = 1$, Store $Cred_c(\sigma_c, C_c)$} \\[1em]
        \end{tabular}
        \end{center}
    \caption{Context Credential Issuance}
    \label{fig:context-cred-issuance}
\end{figure}



\subsubsection{Informal Security Analysis}
Sybil Resistance: The deterministic nullifier $\delta \gets VRF(k,ctx)$ binds each context credential to a unique (user, context) pair, preventing multiple credentials for the same context. The reciprocal proof $\Pi_6$ ensures correct nullifier derivation from the master key $k$. 
Credential Binding: Context Credentials are bound to master credentials through shared identity $s$ and $\Pi_7$. The selective disclosure proof $\Pi_4$ ensures correct commitment structure without revealing private values. 
Privacy: The protocol only reveals $ctx$ and $attrs$ to CCO to allow identity verification while hiding $s$. The Master Credential $Cred_m$ remains unlinkable by being  rerandomized and proven in zero knowledge it verifies with the Master Credential Oracles public key.






\subsubsection{Verification}
A user $user$ wants to prove to any relying party $rely$ they have a valid credential that satisfies a verification statement $\phi$.
The protocol takes as input $(rcd, ccd, \phi, rpk, acc, n)$ and outputs success or failure.
$rely$ starts by sending $(\phi, n, acc)$ to $user$ where $\phi$ is a statement that specifies the requirements for a successful verification and $acc$ is the current accumulator value of revoked nullifiers.
$user$ starts by randomizing their credentials $rcd' = psrerand(rcd)$ and $ccd' = psrerand(ccd)$ and verifies $psverify_{ck_{rcd}}(rcd')$ and $psverify_{ck_{ccd}}(ccd')$. $user$ generate their nullifiers $nullif_{pid} \gets PRF_s(pid)$ and $nullif_{ctx} \gets PRF_s(ctxid)$ and obtains non-membership witnesses $wpid$, $wctx$ for nullifiers against $acc$.
$user$ generates a zero-knowledge proof $\pi$ showing 1) their credentials are valid, 2) they're not expired $(expiry > current_time)$, 3) their nullifiers are correctly formed from $s$, 4) their nullifiers are not in $acc$ using witnesses $wpid, wctx$, 5) the credential attributes satisfy $\phi$, 6) proof freshness using $n$.
$user$ sends $(\pi, attrs_{\phi})$ to $rely$, $rely$ verifies $\pi$ against $acc$ and validates $attrs_{\phi}$ satisfies $\phi$. Returns accept if all checks pass, reject otherwise.



% % % % % % % % % % 
% 
% END MIMC-ABC Construction
% 
% % % % % % % % % % 





\newpage




% % % % % % % % % % 
% 
% Sigma Protocols
% 
% good notes on introducing proofs for this section
% https://web.mat.upc.edu/jorge.villar/doc/notes/DataProt/zk.pdf#page=5.44
% 
% % % % % % % % % % 

\section{Construction of $\Sigma$-protocols}\label{sec:sigmaproofs}
% Recall definitions and introduction here: https://infoscience.epfl.ch/server/api/core/bitstreams/fc1cfb22-d943-4c96-a942-d715b76e6cc4/content#page=6.31

Use standardisation notation / other information from standardisation proof
% https://www.youtube.com/watch?v=bh0hBwxOiVI
Concretely
- $\varphi : \Z_p^n \to \G^m$ is a homomorphism 
Proving knowledge of a preimage
Relation is $\{(w) : Y = \varphi(w)\}$
Relation is $\{(w) : Y = g^w\}$
Relation is $\{(w) : Y = wG\}$



We use the notation of Camenisch and Stadler to represent proofs of knowledge of discrete logarithms relations and the validity of statements about discrete logarithms. 

\[
    \mathcal{R} = \left\{ (\alpha, \beta, \gamma) | \; y = g^{\alpha}h^{\beta} \; \wedge \; \tilde{y} = \tilde{g}^{\alpha}h^{\gamma} \right\}
\]

The relation $\mathcal{R}$ denotes a zero knowledge proof ofknowledge of private integers $\alpha, \beta, \gamma$ such that $\tilde{y} = \tilde{g}^{\alpha}h^{\gamma}$ holds. $y, g, h$ are elements of some group $\G$ and $\tilde{y}, \tilde{g}, \tilde{h}$ are elements of some group $\tilde{\G}$. 



% $<g>, <h>$ - what does this mean? refer to CL04


\begin{enumerate}
    \item Completeness: an honest prover who knows the opening will always convince the verifier.
    
    \item Special Soundness: Show that given two accepting transcripts $(T, c, \{s\}_{i=1}^n, u)$ and $(T, c', \{s'\}_{i=1}^n, u')$ for $c \neq c'$ we can extract a valid witness.
    
    \item Honest Verifier Zero Knowledge: construct a simulator that given a challenge $c$, produces transcripts indistinguishable from real protocol runs.
\end{enumerate}

















% Our discussion on protocols is largely inspired by the work of Feige and Shamir \cite{FeigeShamir}, though some technical details are omitted in this abstract for brevity.

% The protocols involve two parties: a prover \( P \) and a verifier \( V \), both modeled as interactive probabilistic polynomial-time Turing machines. Each has private auxiliary input tapes. The prover's auxiliary input is denoted by \( w \), and both share a common input \( x \) of length \( k \) bits, where \( k \) is often referred to as the security parameter. A probability is considered negligible if, as a function of \( k \), it decreases to zero faster than any polynomial fraction.

% The proof system is defined with respect to a binary relation \( R = \{(x, w)\} \), which can be verified in polynomial time. For any \( x \), the witness set \( w(x) \) consists of all \( w \) such that \( (x, w) \in R \). The protocol's objective is for \( P \) to demonstrate that it possesses an element from \( w(x) \) on its private input tape. We assume that the protocol is complete with probability 1, meaning that if \( w \in w(x) \), the verifier will always accept.

% \section*{Protocol Structure}

% For simplicity, we focus on three-round public-coin protocols, though this restriction can be relaxed. The protocol's conversations are ordered triples of the form:

% \[
% m_1, c, m_2
% \]

% The second message, \( c \), is a random bit string chosen by the verifier, referred to as the challenge. The prover's final message, \( m_2 \), is termed the answer. The length of \( c \) is such that the number of possible values for \( c \) is super-polynomial in \( k \).

% We assume the protocol satisfies knowledge soundness in the following manner: for any prover \( P^* \), given two conversations between \( P^* \) and \( V \): \( (m_1, c, m_2) \) and \( (m_1, c', m_2') \), where \( c \neq c' \), an element of \( w(x) \) can be computed in polynomial time. This is known as the \textit{special soundness property}. This property implies the standard soundness definition, which requires the existence of a knowledge extractor capable of extracting a witness in polynomial time from any prover that succeeds with non-negligible probability.

% Although special soundness is less general than the standard definition, all known proofs of knowledge exhibit this property or a variant where the witness can be computed from a small number of correct answers. Therefore, assuming special soundness is not a significant limitation.

% A protocol that is both sound and complete in the above sense is termed a \textit{proof of knowledge for the relation \( R \)}.

% Finally, we assume the protocol is \textit{honest verifier zero-knowledge}: there exists a simulator \( S \) that, on input \( x \), produces conversations indistinguishable from real conversations between the honest prover and verifier with input \( x \). For simplicity, we assume perfect indistinguishability; extending this to other forms of indistinguishability is straightforward. Most known honest verifier zero-knowledge protocols satisfy a stronger condition: there is a procedure that, given any \( c \), can produce a conversation indistinguishable from all possible conversations between the honest prover and verifier where \( c \) is the challenge. This is referred to as \textit{special honest verifier zero-knowledge}.















































\newpage

\begin{protocol}{ZKPoK for Pedersen Commitment Opening}{openproof}
    \vspace{1em}
    \textbf{Public parameters:}  $g_1, \dots, g_n, h \in \G$

    \textbf{Inputs:} $\cm$ such that $\cm = \prod_{i=1}^ng_i^{m_i}h^r$, \;    $\Prover$ knows $\{m\}_{i=1}^n, r \in \Z_q^{n+1}$.

    \vspace{1em}

    \begin{enumerate}
        \item $\Prover$ samples $\alpha_i \sample \Z_p$ for $i \in [1,n]$, $\rho \sample \Z_p$, computes $T \gets (\prod_{i=1}^ng_i^{\alpha_i})\cdot h^{\rho}$, sends $T$ to $\Verifier$
        
        \item $\Verifier$ sends challenge $c \sample \Z_p$
    
        \item $\Prover$ computes responses $s_i \gets \alpha_i + cm_i$ for $i \in [1,n]$, and $u \gets \rho + cr$. Sends $\{s_i\}_{i=1}^n$ and $u$ to $\Verifier$
    
        \item $\Verifier$ verifies that $ (\prod_{i=1}^ng_i^{s_i})\cdot h^u = \cm^cT$
    \end{enumerate}
\end{protocol}

\begin{theorem}[Perfect Completeness]
    Construction \ref{prot:openproof} is a $\Sigma-$protocol for the relation $\mathcal{R}$
    \[
        \mathcal{R} = \left\{ (\cm,g_1,\dots,g_n,h),(m_1,\dots,m_n,r) \; | \; \cm = (\prod_{i=1}^ng_i^{m_i})h^r \right\}
    \]
    with perfect completeness: 
\end{theorem}


\begin{proof}
    We prove completeness by showing that for any valid inputs and witnesses, when both $\Prover$ and $\Verifier$ follow the protocol, $\Verifier$ accepts with $\Pr$ = 1.
    Consider an execution of the protocol where:
    \begin{enumerate}
        \item $\Prover$ samples $\alpha_i \sample \Z_p$ for $i \in [1,n]$, $\rho \sample \Z_p$ and sends $T \gets (\prod_{i=1}^n g_i^{\alpha_i})h^{\rho}$
        \item $\Verifier$ sends challenge $c \sample \Z_p$
        \item $\Prover$ responds with $s_i \gets \alpha_i + cm_i$ for $i \in [1,n]$, $u \gets \rho + cr$
    \end{enumerate}
    Verification holds by 
    \begin{align}
        (\prod_{i=1}^n g_i^{s_i})h^u &\stackrel{?}{=} \cm^cT \notag \\
        (\prod_{i=1}^n g_i^{\alpha_i + cm_i})h^{\rho + cr} &\stackrel{?}{=} (\prod_{i=1}^n g_i^{m_i}h^r)^c(\prod_{i=1}^n g_i^{\alpha_i})h^{\rho} \notag  \\
        (\prod_{i=1}^n g_i^{\alpha_i + cm_i})h^{\rho + cr} &= (\prod_{i=1}^n g_i^{cm_i + \alpha_i})h^{cr + \rho} \notag 
    \end{align}
    Thus, an honest verifier always accepts an honest prover's proof.
\end{proof}




\begin{theorem}[Special Soundness]
    Construction 1 satisfies the special soundness of relation $\mathcal{R}$. 
\end{theorem}
\begin{proof}
    Let $Tr_1 = (T, c, \{s_i\}_{i=1}^n, u)$ and $Tr_2 = (T, c', \{s'_i\}_{i=1}^n, u')$ be two accepting transcripts for the same initial commitment $T$ where $c \neq c'$. We construct a knowledge extractor $\Extractor$ that extracts the witness $w = (\{m_i\}_{i=1}^n,r)$ as follows:
    \begin{enumerate}
        \item Since both transcripts are accepting, they satisfy: 
        $(\prod_{i=1}^n g_i^{s_i})h^u = \cm^cT$ and $(\prod_{i=1}^n g_i^{s'_i})h^{u'} = \cm^{c'}T$
        
        \item Evaluate as a system of linear equations:
             \begin{align}
               \frac{(\prod_{i=1}^n g_i^{s_i})h^u}{(\prod_{i=1}^n g_i^{s'_i})h^{u'}} &= \frac{\cm^c}{\cm^{c'}} \notag \\
               (\prod_{i=1}^n g_i^{s_i-s'_i})h^{u-u'} &= (\prod_{i=1}^n g_i^{m_i(c-c')})h^{r(c-c')} \notag
            \end{align}
            
       \item By the homomorphic property of the exponents and the uniqueness of discrete logarithm representations, we obtain the system of equations:
       \[
       s_i-s'_i = m_i(c-c') \text{ for } i \in [1,n] \qquad u-u' = r(c-c')
       \] 
       therefore $\Extractor$ extracts: 
       \[
       m_i = \frac{s_i-s'_i}{c-c'} \text{ for } i \in [1,n] \qquad r = \frac{u-u'}{c-c'}
       \]
       Which satisfies the commitment construction $\cm = (\prod_{i=1}^n g_i^{m_i})h^r$
    \end{enumerate}
    This shows that if $\Prover$ can respond correctly to 2 different challenges for the commitment $T$, they must "know" all messages $\{m_i\}_{i=1}^n$ and the randomness $r$.
\end{proof}



\begin{remark}
    The special soundness property of our protocol relies on the same discrete logarithm assumption as the binding property of Pedersen commitments. Specifically, if an adversary could find two different openings $(\{m_i\}_{i=1}^n, r) \neq (\{m'_i\}_{i=1}^n, r')$ for the same commitment $\cm$, they could use these to compute discrete logarithms between the generators $(g_1,\ldots,g_n,h)$. Our extractor demonstrates that producing two valid transcripts for different challenges is equivalent to breaking this binding property.
\end{remark}



\begin{theorem}[Honest-Verifier Zero-Knowledge]
    Construction 1 is honest-verifier zero-knowledge.
\end{theorem}
\begin{proof}
    We construct a simulator $\Simulator$ that, given only public input $\cm$ and a challenge $c$, produces transcripts that are identically distributed to those of real protocol executions. $\Simulator$ works as follows:
    \begin{enumerate}
        \item On input $(\cm, c)$, $\Simulator$ samples:
            \begin{itemize}
                \item $s_i \sample \Z_p$ for $i \in [1,n]$
                \item $u \sample \Z_p$
            \end{itemize}
            
        \item Computes $T \gets (\prod_{i=1}^n g_i^{s_i})h^u\cm^{-c}$
        
        \item Outputs transcript $(T, c, \{s_i\}_{i=1}^n, u)$
    \end{enumerate}

    To show perfect HVZK, we prove the distribution of simulated transcripts is identical to real transcripts:
    \begin{itemize}
        \item In real protocol: 
            \begin{itemize}
                \item $s_i = \alpha_i + cm_i$ where $\alpha_i \sample \Z_p$
                \item $u = \rho + cr$ where $\rho \sample \Z_p$
            \end{itemize}
        \item Since $\alpha_i, \rho$ are uniform in $\Z_p$, the real $s_i, u$ are uniformly distributed in $\Z_p$
        \item In simulation, $s_i, u$ are sampled uniformly from $\Z_p$
        \item Therefore, $(s_i, u)$ have identical distributions in both cases
        \item Given fixed $(s_i, u)$, $T$ is uniquely determined by the verification equation in both real and simulated transcripts
    \end{itemize}
    Thus, the simulated transcripts are perfectly indistinguishable from real protocol transcripts.
\end{proof}


\begin{corollary}[Proof of Zero Values]
    Let $I \subseteq [1,n]$ be a set of indices. Given a commitment $\cm$ and commitment key $\ck$, we construct modified public parameters $\ck'$ by removing the generators $g_i$ for all $i \in I$ from $\ck$. Using $\ck'$ with Construction 1 proves that $m_i = 0$ for all $i \in I$ while maintaining the properties of a $\Sigma$-protocol.
\end{corollary}

\begin{proof}
    Consider commitment $\cm = (\prod_{i=1}^n g_i^{m_i})h^r$. When proving with modified generators, the prover must demonstrate knowledge of opening $(\{m_i\}_{i \notin I}, r)$ such that:
    \[
    \cm = (\prod_{i \notin I} g_i^{m_i})h^r
    \]
    
    If this equation holds and $\cm$ was constructed using all generators, then necessarily $m_i = 0$ for all $i \in I$, as otherwise the verification would fail.

    We now show the protocol maintains all properties of a $\Sigma$-protocol:

    Completeness: For any valid commitment $\cm$ where $m_i = 0$ for all $i \in I$, the protocol succeeds with probability 1. The prover samples $\alpha_i \sample \Z_p$ for $i \notin I$ and $\rho \sample \Z_p$, computes $T = (\prod_{i \notin I} g_i^{\alpha_i})h^{\rho}$, and responds to challenge $c$ with $s_i = \alpha_i + cm_i$ for $i \notin I$ and $u = \rho + cr$. Verification holds because:
    \[
    (\prod_{i \notin I} g_i^{s_i})h^u = (\prod_{i \notin I} g_i^{\alpha_i + cm_i})h^{\rho + cr} = \cm^c \cdot T
    \]

    Special Soundness: Given two accepting transcripts $(T, c, \{s_i\}_{i \notin I}, u)$ and $(T, c', \{s'_i\}_{i \notin I}, u')$ with $c \neq c'$, the extractor from Theorem 1 works on the reduced generator set to extract valid openings $m_i = \frac{s_i-s'_i}{c-c'}$ for $i \notin I$ and $r = \frac{u-u'}{c-c'}$. Since these values must satisfy the verification equation with the full generator set, all omitted indices must correspond to zero values.

    HVZK: The simulator from Theorem 1 operates identically on the reduced generator set, producing perfectly indistinguishable transcripts.
\end{proof}


\begin{corollary}[AND proofs]
    AND proofs
    % https://web.mat.upc.edu/jorge.villar/doc/notes/DataProt/zk.pdf#page=5.44
\end{corollary}




\begin{corollary}[Equality of Committed Values]
    Construction 1 can be used to prove equality of messages in two (or more) Pedersen commitments. Specifically, for commitments $\cm_1 = g_1^m h_1^{r_1}$ and $\cm_2 = g_2^m h_2^{r_2}$, we can prove knowledge of $(m, r_1, r_2)$ satisfying the relation:
    \[
    \mathcal{R} = \left\{ ((\cm_1, \cm_2, g_1, g_2, h_1, h_2), (m,r_1,r_2)) \; | \; \cm_1 = g_1^{m}h_1^{r_1} \; \wedge \; \cm_2 = g_2^{m}h_2^{r_2} \right\}
    \]    
\end{corollary}

\begin{proof}
    We instantiate Construction 1 with generators $(g_1, g_2, h_1, h_2)$ and prove knowledge of opening:
    \[
    \cm = (g_1^m h_1^{r_1}, g_2^m h_2^{r_2})
    \]
    
\noindent    The protocol runs as follows:
    \begin{enumerate}
        \item $\Prover$ samples $\alpha, \rho_1, \rho_2 \sample \Z_p$ and sends $T_1 \gets g_1^{\alpha}h_1^{\rho_1}, T_2 \gets g_2^{\alpha}h_2^{\rho_2}$
        \item $\Verifier$ sends challenge $c \sample \Z_p$
        \item $\Prover$ sends $s \gets \alpha + cm, u_1 \gets \rho_1 + cr_1, u_2 \gets \rho_2 + cr_2$
        \item $\Verifier$ checks $g_1^s h_1^{u_1} = \cm_1^c T_1 \wedge g_2^s h_2^{u_2} = \cm_2^c T_2$
    \end{enumerate}

\noindent Security follows from Theorem 1:
    \begin{itemize}
        \item Completeness: Inherits directly as this is a specific instantiation
        \item Special Soundness: The extractor obtains a single $m$ from $s$ and corresponding $r_1, r_2$ from $u_1, u_2$
        \item HVZK: The simulator from Theorem 1 extends naturally by sampling a single $s$ for both equations
    \end{itemize}
    
    Crucially, using the same $\alpha$ for both $T_1$ and $T_2$ ensures the extracted message $m$ must be identical in both commitments.
\end{proof}

\begin{corollary}[Proof of Multiplicative Inverse]
    Construction 1 can be used to prove that two committed values are multiplicative inverses. Specifically, for commitments $\cm_1 = g^{m_1}h^{r_1}$ and $\cm_2 = g^{m_2}h^{r_2}$, we can prove knowledge of $(m_1, m_2, r_1, r_2)$ satisfying the relation:
    \[
    \mathcal{R} = \left\{ ((\cm_1, \cm_2, g, h), (m_1, m_2, r_1, r_2)) \; | \; \cm_1 = g^{m_1}h^{r_1} \; \wedge \; \cm_2 = g^{m_2}h^{r_2} \; \wedge \; m_1 \cdot m_2 = 1 \right\}
    \]    
\end{corollary}

\begin{proof}
    The protocol runs as follows:
    \begin{enumerate}
        \item $\Prover$ samples $\alpha_1, \alpha_2, \rho_1, \rho_2, \rho_3, \rho_4 \sample \Z_q$ and computes:
            \begin{itemize}
                \item $T_1 \gets g^{\alpha_1}h^{\rho_1}$, $T_2 \gets g^{\alpha_2}h^{\rho_2}$
                \item $\cm_3 \gets \cm_1^{m_2}h^{\rho_3}$, $\cm_4 \gets h^{\rho_4}$
                \item $T_3 \gets \cm_1^{\alpha_2}h^{\rho_3}$, $T_4 \gets h^{\rho_4}$
            \end{itemize}
        
        \item $\Verifier$ sends challenge $c \sample \Z_q$
        
        \item $\Prover$ responds with:
            \begin{itemize}
                \item $s_1 \gets \alpha_1 + cm_1$, $s_2 \gets \alpha_2 + cm_2$
                \item $u_1 \gets \rho_1 + cr_1$, $u_2 \gets \rho_2 + cr_2$
                \item $u_3 \gets \rho_3 + cr_3$, $u_4 \gets \rho_4 + cr_4$
            \end{itemize}
            
        \item $\Verifier$ checks:
         \begin{itemize}
            \item $g^{s_1}h^{u_1} = \cm_1^cT_1$ $\;\; \wedge \;\;$ $g^{s_2}h^{u_2} = \cm_2^cT_2$ $\; \; \wedge \;\;$ $\cm_1^{s_2}h^{u_3} = \cm_3^cT_3$ $\;\; \wedge \;\;$ $h^{u_4} = \cm_4^cT_4$ $\;\; \wedge \;\;$ $\cm_3 / \cm_4 = g$
         \end{itemize}
    \end{enumerate}

    \noindent Security follows from Theorem 1 as we are effectively running multiple instances of the base protocol with additional algebraic constraints. The final check $\cm_3/\cm_4 = g$ ensures $m_1 \cdot m_2 = 1$ because:
    \begin{itemize}
        \item $\cm_3 = \cm_1^{m_2}h^{\rho_3} = g^{m_1m_2}h^{r_1m_2 + \rho_3}$
        \item $\cm_4 = h^{\rho_4}$
        \item Therefore $\cm_3/\cm_4 = g^{m_1m_2}h^{r_1m_2 + \rho_3 - \rho_4}$
        \item If this equals $g$, then $m_1 \cdot m_2 = 1$
    \end{itemize}
\end{proof}


\noindent Special Soundness: Given two accepting transcripts $(T_1,T_2,T_3,T_4,c,s_1,s_2,u_1,u_2,u_3,u_4)$ and $(T_1,T_2,T_3,T_4,c',s'_1,s'_2,u'_1,u'_2,u'_3,u'_4)$ for $c \neq c'$, we can extract a valid witness $(m_1,m_2,r_1,r_2,r_3,r_4)$ as follows:

For $i \in \{1,2\}$:
\begin{align*}
m_i &= \frac{s_i - s'_i}{c - c'} \\
r_i &= \frac{u_i - u'_i}{c - c'} 
\end{align*}

For $i \in \{3,4\}$:
\[
r_i = \frac{u_i - u'_i}{c - c'}
\]

\noindent The extracted values satisfy the relation $\mathcal{R}$ because:
\begin{itemize}
    \item From verification equations 1 and 2, we obtain valid openings of $\cm_1$ and $\cm_2$
    \item From equation 3, we get that $\cm_3 = \cm_1^{m_2}h^{r_3}$
    \item From equation 4, we get that $\cm_4 = h^{r_4}$
    \item The final check $\cm_3/\cm_4 = g$ ensures $m_1 \cdot m_2 = 1$
\end{itemize}

\noindent Honest-Verifier Zero-Knowledge: We construct a simulator $\Simulator$ that produces transcripts indistinguishable from real protocol runs:

\begin{enumerate}
    \item On input $(\cm_1,\cm_2,c)$, $\Simulator$ samples:
        \begin{itemize}
            \item $s_1,s_2 \sample \Z_q$
            \item $u_1,u_2,u_3,u_4 \sample \Z_q$
        \end{itemize}
    
    \item Computes:
        \begin{itemize}
            \item $T_1 \gets g^{s_1}h^{u_1}\cm_1^{-c}$
            \item $T_2 \gets g^{s_2}h^{u_2}\cm_2^{-c}$
            \item $T_3 \gets \cm_1^{s_2}h^{u_3}\cm_3^{-c}$
            \item $T_4 \gets h^{u_4}\cm_4^{-c}$
        \end{itemize}
        where $\cm_3,\cm_4$ are computed such that $\cm_3/\cm_4 = g$
    
    \item Outputs $(T_1,T_2,T_3,T_4,c,s_1,s_2,u_1,u_2,u_3,u_4)$
\end{enumerate}

\noindent The simulated transcript is perfectly indistinguishable from real transcripts because:
\begin{itemize}
    \item $s_1,s_2,u_1,u_2,u_3,u_4$ are uniformly random in both real and simulated transcripts
    \item Given these values, $T_1,T_2,T_3,T_4$ are uniquely determined by the verification equations
    \item The relation $\cm_3/\cm_4 = g$ is maintained in both real and simulated transcripts
\end{itemize}


\begin{corollary}[Selective Disclosure]
Given a commitment $\cm = (\prod_{i=1}^ng_i^{m_i})h^r$ and $I \subseteq [1,k]$ be a set of indices of disclosed messages where $k < n$, we construct $\cm' = (\prod_{i \notin I}^{n-k}g_i^{m_i})h^r $ and $D = [m_j]_{j\in I}$. Construction 1 can be used to prove that $\cm$ commits to all messages, $D$ contains disclosed messages and $\cm'$ commits to $m_i \notin D$ satisfying the relation:
\[
    \mathcal{R} = \left\{(\cm, \cm', \ck, D)([m_i]_{i\notin D}, r) \; |  \; \cm' = (\prod_{i=1, i \notin I}^n g_i^{m_i})h^r \; \wedge \; \cm_d = \prod_{i=1, i \in I}^n g_i^{m_i} \wedge \cm' \cdot \cm_d = \cm
    \right\}
\]
\end{corollary}

\begin{corollary}[Selective Disclosure]
Let $\cm = (\prod_{i=1}^n g_i^{m_i})h^r$ be a Pedersen commitment to messages $(m_1,\ldots,m_n)$ and let $I \subseteq [1,n]$ be the set of indices to be disclosed. The protocol proves knowledge of openings for undisclosed messages while revealing values for disclosed messages satisfying the relation:

\[
\mathcal{R} = \left\{ ((\cm, {g_i}_{i=1}^n, h, I, {m_i}{i \in I}), ({m_i}_{i \notin I}, r)) \middle|
\begin{array}{l}
\cm = (\prod_{i=1}^n g_i^{m_i})h^r \wedge \
\text{disclosed values match } {m_i}_{i \in I}
\end{array} \right\}
\]


\end{corollary}




\begin{proof}
   The protocol runs as follows:
    \begin{enumerate}
        \item $\Prover$ computes
            \begin{itemize}
                \item  $\cm_d$, a commitment to disclosed attributes $\cm_d = \prod_{i \in I}g_i^{m_i}$
                \item $\cm' = \cm \cdot \cm_d^{-1}$ the remaining commitment with private attributes
                \item $\cm' = \cm / \cm_d$ the remaining commitment with private attributes
            \end{itemize}
        \item $\Prover$ executes Construction 1 with $\cm'$ and sends $\Verifier$ $\cm$ and disclosed attributes 
        \item $\Verifier$ computes $\cm_d' \gets \prod_{i \in I}g_i^{m_i}$ from disclosed attributes and checks
        \begin{itemize}
            \item $\Prover$'s proofs from $\cm'$
            \item  Checks if $\cm_d' \cdot \cm' = \cm$
        \end{itemize}
    \end{enumerate}
\end{proof}

\noindent Security: Special Soundness and Honest Verifier Zero Knowledge follows from Theorem 1 as we are running the same protocol but with subset of attributes. Completeness holds 
\begin{itemize}
    \item $\cm_d$ is computed from the disclosed attributes
    \item $\cm'$ is computed from the private attributes
    \item The homomorphic property of the commitments ensures commitment completeness.
\end{itemize}


% % % % % % % % % % 
% 
% END Sigma Protocols
% 
% % % % % % % % % % 

















% % % % % % % % % % 
% 
% Private Identity System from MIMC-ABC
% 
% % % % % % % % % % 



\cleardoublepage
\section{Private Identity System from MIMC-ABC}\label{sec:idsys}

Our identity system establishes a secure framework for issuing and managing privacy-preserving credentials across multiple authorities while maintaining accountability. The system involves four key entities: users, credential oracles (which verify and attest to user attributes), auditor (who manage revocation), and credential verifiers.

\noindent At the core of our system is a master credential issued by a government credential oracle, which serves as a root of trust. This credential contains two crucial committed elements: a secret identifier $s$ that enables secure credential linking, and a committed VRF key $k$ that generates context-specific nullifiers. These nullifiers serve dual purposes: preventing Sybil attacks at credential oracles and enabling efficient revocation. During master credential issuance, the VRF key is verifiably encrypted, the ciphertext is stored in the government system which associates a plaintext user profile to their ciphertext for revocation.


\noindent Users can obtain context credentials from various credential oracles by proving possession of a valid, unrevoked master credential and deriving a unique nullifier using their VRF key and the credential context. This design allows credential oracles to restrict issuance to users with trusted government-issued credentials, ensuring their credentials are only issued to verified identities. The system supports expressive verification statements that can combine attributes across multiple credentials. Since master credentials are government-issued and require stringent security checks, verifiers can leverage this trust by incorporating master credential validity, expiration, and revocation checks into their verification statements, inheriting the strong security properties of government-issued credentials. This enables credential oracles to maintain trust by ensuring their credentials become unusable if the underlying government credential is revoked.


\noindent The system supports flexible revocation through two mechanisms: targeted revocation of specific credentials via their nullifiers, and complete revocation of all user credentials by recovering their VRF key through the auditors. Government systems can initiate revocation by using plaintext identifiers, with auditors managing the conversion to the appropriate nullifiers. This approach maintains privacy while enabling practical accountability and administration.

We use the Multi Issuer Multi Credential Anonymous Credential system to implement a privacy-preserving digital identity system

\subsection{Entities}
Our identity system involves users, credential issuers, auditors, and credential verifiers.

\noindent \textbf{User} ($\User$) holds a master credential $Cred_{master}$ and any number of context credentials $Cred_{ctx}$ in their identity wallet. The master credential contains a unique identifier $s$, a VRF key $k$, and additional attributes, and is issued by a government entity. Context credentials are issued by participating organizations like universities or licensing authorities.

\noindent \textbf{Credential Oracle} ($\MCO, \CCO$) verifies user identity and issues digital credentials. The Master Credential Oracle $\MCO$ operates with keypair $(SK_{m}, PK_{m})$ for issuing "root" credentials, while Context Credential Oracles $\CCO$ use $(SK_{c}, PK_{c})$ for issuing domain-specific credentials.

\noindent \textbf{Auditor} ($\Auditor$) consists of a threshold of nodes holding encryption and accumulator keypairs; for simplicity, we refer to both as $(sk_A, pk_A)$. Users encrypt their VRF keys under the auditors' public key, as in key escrow schemes. Auditors can decrypt this key during revocation. The Auditor updates the revocation list. 

\noindent \textbf{Verifier} ($\Verifier$) represents any party wishing to verify a user's credentials.

\subsection{Data Objects}

We now describe the data objects that form our privacy-preserving decentralized identity system. At its core, a Master Credential serves as a root of trust, from which Context Credentials can be derived. During Context Credential issuance, users generate a deterministic nullifier unique to each context using their Master Credential's secrets and the context string, enabling privacy-preserving credential linking.

\subsubsection{Master Credential $Cred_m$}: 
A master credential is a high-security root credential issued by a government entity containing:

\begin{itemize}
    \item Identity string $s$: a unique identifier
    \item VRF key $k$: used to generate context-specific nullifiers
    \item Context type $ctx$: always set to "master" for master credentials
    \item Additional attributes $attrs$: including expiry date, date of birth, etc.
    \item Credential Structure:
    \begin{itemize}
        \item Master Commitment $C_m = Com([s, k, ctx, attrs],r)$: A Pedersen commitment to the credential attributes using randomness $r$
        \item Oracle signature $\sigma_m$: A rerandomizable signature over $C_m$, verifiable under $PK_m$
    \end{itemize}
\end{itemize}

\subsubsection{Master Credential Oracle Data Record:} Following successful master credential issuance, the oracle maintains a record containing:
\begin{itemize}
    \item Commitment-Signature Pair $(C_m, Cred_m)$:
    \begin{itemize}
        \item Master commitment $C_m = Com([s,k,ctx,attrs],r)$: the Pedersen commitment over credential attributes
        \item Oracle Signature $Cred_m$ The signature over commitment $C_m$
    \end{itemize}
    \item Key Encryption and Proof:
    \begin{itemize}
        \item Encrypted VRF Key $CT_k$: the encryption of the user's VRF key, encrypted with the Auditor's public key $Enc_{PK_a}(k)$
        \item Consistency proof $\Pi_{CT}$: The zero-knowledge proof that $CT_k$ encrypts the committed key $k$
    \end{itemize}
\end{itemize}


\subsubsection{Context Credential $Cred_c$}: 
A user interacts with the Context Credential oracle to obtain a context-specific credential, which contains:
\begin{itemize}
    \item Identity string $s$: The user's unique identifier from their master credential
    \item Nullifier $\tau$: A deterministic value generated from $(s, ctx)$
    \item Context string $ctx$: A hashed identifier of the credential type (e.g., $dmv$, $universityofsydney$)
    \item Attribute list $attrs$: Additional credential-specific information such as expiry date
    \item $\sigma_c$ the rerandomizable signature over $C_c$ from the context credential oracle that proves the user has been issued $Cred_c$ over $C_c$
    \item Credential Structure:
    \begin{itemize}
        \item Context commitment $C_c$: A Pedersen commitment $Com([s, \tau, ctx, attrs],r')$ to the credential attributes using randomness $r'$
        \item Oracle signature $\sigma_c$: A rerandomizable signature over $C_c$, verifiable under $PK_c$
    \end{itemize}
    
\end{itemize}


\subsubsection{Context Credential Oracle Data Record:} During credential issuance, the oracle maintains a record of the interaction containing:
\begin{itemize}
    \item Master Credential Verification: 
        \begin{itemize}
            \item Randomized credential $Cred_m'$: a rerandomized version of the master credential
            \item Randomized commitment $C_m'$: the corresponding rerandomized commitment
            \item Opening proof $\Pi_{ComOpen}$: Zero-knowledge proof of correct commitment opening
            \item Revocation proof $\Pi_{NonRevoked}$:  Zero-knowledge proof that the credential has not been revoked
        \end{itemize}
    \item Nullifier Components:
    \begin{itemize}
        \item Context nullifier $\tau$: The value $VRF(k,ctx)$ derived from the user's committed VRF key and credential context
        \item Derivation proof $\Pi_{\tau}$: Zero-knowledge proof establishing that
        \begin{itemize}
            \item The VRF computation is correct
            \item The key $k$ matches the one committed in $Cred_m$
            \item The context string $ctx$ is correctly incorporated
        \end{itemize}
    \end{itemize}
\end{itemize}

\subsubsection{Revocation List:} 
\begin{itemize}
    \item Accumulator Structure:
    \begin{itemize}
        \item Accumulator value $A$: The current state of the accumulator representing non-revoked credentials
        \item Secret key $sk_A$: The accumulator manager's key for updates
        \item Auxiliary information $aux$: Additional data needed for witness updates
    \end{itemize}
    \item Revoked Elements:
    \begin{itemize}
        \item Master revocations $k$: VRF keys of revoked master credentials
        \item Context revocations $\tau$: Nullifiers of revoked context credentials
        \item Timestamp $t$: Time of revocation
        \item Reason code $rc$: Justification for revocation
    \end{itemize}
    \item Witness Management:
    \begin{itemize}
        \item Non-membership witness $w$: Proof that a credential is not in the revocation set
        \item Update information $upd$: Data for users to update their witnesses after accumulator changes
    \end{itemize}
\end{itemize}

\betteridea{Notes on Threat/Trust model: threat model has issuer/verifier, trust model has credd oracle, auditor, etc. Keep consistent. Also, state what's out of scope e.g. network, physical, side-channel. domain in arke = context}

\subsubsection{Trust Model}
\begin{itemize}
    \item Credential Oracles: trusted to verify real-world identity before issuing credentials, they aren't trusted for privacy and may be compromised but can't issue credentials without the user participating in their protocol

    \item Auditors: are trusted to only decrypt user keys for legitimate revocation requests

    \item Network: communication assumed to be over encrypted channels, any storage is not trusted for credential contents
\end{itemize}

\subsubsection{Threat Model}
We assume the auditor maintaining the revocation cannot be corrupted.

\begin{itemize}
    \item Malicious Credential Oracle: A malicious credential oracle could "falsely issue attestations and impersonate any user it desires. Fortunately, recent work on authenticating web data has shown privacy-preserving, untrusted and correct credential oracles can be realized in practice [DECO, distefano, etc]. Additionally, we mitigate the threat level by confining each credential oracle to a unique domain." - from Arke. 
    \item Malicious User: attempts to obtain multiple credentials for the same context, tries to forge credentials or share them with others, attempts to link credentials with other credentials not issued to the same master secret key
    \item Malicious Issuer: attempts to link multiple showing, collude with issuers to deanonymize users, stores presentation proofs to track users
    \item Malicious Verifier: issue credentials without proper verification, attempts to track credential usage, colludes with issuers or other verifiers
\end{itemize}



\subsection{Syntax}
\todonote{Sam to update this to include master and context cred and revocation}

Syntax of Anonymous Identity System with Sybil Resistance and Revocation
\begin{itemize}
    \item $\mathsf{Setup}(\secparam) \to (\ppar, \UL, \RL)$ Takes security parameter $\lambda$ in unary, outputs public parameters $\ppar$, empty user list $\UL$ and revocation list $\RL$.

    \item $\mathsf{OrgKeygen}(\ppar, n) \torand (\osk, \opk)$: is a probabilistic algorithm that takes public parameters $\ppar$ and $n$ the upper bound of credential attributes. Outputs organisations keypair $(\osk, \opk)$

    \item $\mathsf{UserKeygen}(\secparam) \torand (\usk)$ is a probabilistic algorithm. Outputs user secret key $\usk$ consisting of PRF key $k$ and identity string $s$

    \item $(\mathsf{Obtain Master}(usk, \textbf{m}, aux), \mathsf{Issue Master}(osk, cm, aux)) \to cred:$ An interactive protocol. $Obtain$ is a probabilistic alrogithm run by a user, inputs secret key, credential attribute vector $\textbf{m}$ and auxiliary info. $Issue$ is a probabilistic algorithm run by an issuing organization that takes a commitment $cm$, issuers secret key $osk$, and auxiliary info. Outputs a credential $cred$ binding $cm$ to the issuer signature.

    \item $(\mathsf{Obtain Context}(usk, \textbf{m}, aux), \mathsf{Issue Context}(osk, cm, aux)) \to cred:$ An interactive protocol. $Obtain$ is a probabilistic alrogithm run by a user, inputs secret key, credential attribute vector $\textbf{m}$ and auxiliary info. $Issue$ is a probabilistic algorithm run by an issuing organization that takes a commitment $cm$, issuers secret key $osk$, and auxiliary info. Outputs a credential $cred$ binding $cm$ to the issuer signature.

    \item $(\mathsf{Show}(usk, cred, \phi), \mathsf{Verify}(cred', cm, \pi)) \to \bit$ An interactive protocol. $Show$ is a probabilistic algorithm run by a Prover. Takes secret key, credential, and predicate statement $\phi$. $Verify$ is a deterministic algorithm run by a verifier, takes a randomized credential and commitment $cred', cm'$ and proof $\pi$. Otuputs 1 if verification succeeds, otherwise 0.

    \item $\mathsf{Revoke}(\RL, k') \to \RL'$ revoke is a deterministic algorithm, updates revocation list with revoked key $k'$
\end{itemize}

\subsection{Security Model}
\begin{itemize}
    \item \textbf{Sybil resistance}: For any given context, no probabilistic polynomial time adversary can obtain more than 1 valid credential with non-negligible probability 
    
    \item \textbf{Revocability}: For any given context, no probabilistic polynomial time adversary use a revoked credential 
\end{itemize}

\subsubsection{Sybil Resistance}

\subsubsection{Revocation}
When $ra$ needs to revoke a user's credential/s (due to user request or credential provider request), $ra$ finds $escrow$ based on the user's $pid$, recall $ra$ has a user list $ul$ = $(pid, escrow)$ and requests the auditor $audit$ to decrypt $s \gets tpkdec_{ask}(escrow)$. $audit$ computes the nullifiers to add to the revocation accumulator. $nullif_{rcd} \gets PRF_s(pid)$ and for each context credential to revoke, $nullif_{ctxid} \gets PRF_s(ctxid)$. $audit$ updates the accumulator $acc' \gets Acc.Add(acc)$
If the registration credential requires revocation, $audit$ can compute each $nullif \gets PRF_{s}(ctxid) ; \forall ; ctxid ; \in ; ctxl$ and add $(nullif, timestamp, reason)$ to $rl$. For record-keeping, $ra$ stores Revocation Information $ri = (nullif, timestamp, reason)$ allowing $ra$ to track which credentials are revoked and why, $nullif$ in $rl$ ensures revoked credentials can't be verified.
During credential verification, verifiers check if a credential's nullifier appears in $rl$, if present, the verification fails.














\newpage
\section{Performance Evaluation}\label{sec:evaluation}
What is the takeaway message from the evaluation?
\begin{itemize}
    \item For non-private system, we enable privacy with little overhead. Our building block sigma protocol for private sybil resistance adds negligible overhead. 
    \item For private system, but better efficiency, we have a SOTA paper TACT/S3ID (in the comparison table). Their paper does multi-attribute/multi-issuer credentials (they issue 1 credential per attribute), but their benchmarks don't show the complexity in verifying credentials together, or proving statements about their credential which they say would have non-negligible impact and theirs is lower bound. For us, by using simpler and well-known construction, we are more efficient (need to test this but I think so due to their construction) and better functionality. 
\end{itemize}








\newpage
\section{Anonymous Credential Algebraic Comparison}

\section{Comparison of Signature Schemes for Anonymous Credentials}
\label{sec:signature-comparison}

Anonymous Credentials allow users to prove the authenticity of issuer-signed attributes, without revealing the underlying credential, preventing authentication systems from linking and profiling the credential holders. In the concrete setting, this allows users to verify attributes of their credentials without revealing and thus disclosing more personal information than necessary - increasingly important in a world with increasing cyber threat and personal information threat. 

Accountable Privacy is the term assigned to the balance between authentication systems needing to authenticate users and comply with regulations and the user's ambition to remain anonymous or minimally disclose personal information. The area was first introduced by Chaum in early work \cite{chaum_untraceable_1981, chaum1985security} and later formalized as the \emph{CL framework} \cite{goos_pseudonym_2000, goos_efficient_2001} merging advancements in zero-knowledge proofs and sigma protocols, commitment schemes, and pairing-based signatures. 

From a cryptographic construction point of view, A natural framework for constructing anonymous credentials, the so-called, CL framework proposed by Camenisch and Lysyanskaya [CL03], is instantiated in several anonymous credentials systems such as [CL01,CL04,CDL16,PS16,TZ23]. In the CL framework, a credential is a signature on a set of attributes, and to prove possession of the credential, the holder proves in zero-knowledge that they hold a signature on a set of attributes that verifies under the credential issuer’s public key.

Traditional signature schemes like RSA, DSA, El-Gamal, while secure for standard digital signatures, lacked the algebraic structure for anonymous credentials. That is, Anonymous Credentials require homomorphic properties required for credential randomization and zero knowledge proof of knowledge of exponents. Prior digital signature schemes used hash functions which don't have the algebraic properties for randomization. 

The real breakthrough came when researchers realized that pairing-based signatures provided the perfect algebraic structure to combine with both Pedersen commitments and sigma protocols. The homomorphic properties of pairings meant you could randomize signatures while preserving verifiability, and the discrete log setting of both commitments and sigma protocols meant that the user with a randomized signature could prove their signature, which after randomization appears indistinguishable from the signature signed by the authority, was signed by the authority and over attributes. Furthermore, the proofs could prove in zero-knowledge that certain relations hold without disclosing attributes. 

Current constructions combine 3 areas of improvement
\begin{enumerate}
    \item \textbf{Zero-Knowledge Proofs and Sigma Protocols:} Fiat-Shamir introduced practical zero-knowledge protocols \textbf{CITE Fiat Shamir}, Schnorr's identification protocol build the foundation of sigma protocols over the discrete logarithm relations \cite{brands1996privacy, goos_rapid_1997, brands_rethinking_2000} and Camenisch-Stadler formalized proofs of knowledge for group homomorphism which is the building block for proving discrete log relations in commitment schemes \cite{goos_efficient_1997} and damgards work on sigma protocols \cite{damgard_sigma_2010}.

    \item \textbf{Pairing-based Signatures: } Boneh-Lynn-Shacham (BLS) \cite{goos_short_2001} introduced the first short signature using bilinear pairings, Boneh-Boyen-Shacham (BBS) \cite{hutchison_short_2004} showed how to sign committed messages, Camenisch-Lysyanskaya \cite{cimato_signature_2003, hutchison_signature_2004} demonstrated how pairings enable signature randomization.

    \item \textbf{Commitments: } \cite{pedersen1991non} Pedersen introduced his commitment scheme with perfect hiding and computational binding under the discrete log, \cite{goos_efficient_1997} Camenisch-Stadler formalized the ntoationa dn composition of sigma protocols over commitments and due to their algebraic compatibility with pairing based signatures, pedersen commitments were integrated in the early BLS, BBS, CL signatures \cite{goos_short_2001, hutchison_short_2004, hutchison_signature_2004}. 
    
\end{enumerate}

\subsubsection{computational consideration}
Anonymous Credentials introduce computational overhead compared to standard signature verification. 


While anonymous credentials introduce additional computational overhead compared to standard signature verification, developments in practical pairing libraries significantly improve their practical efficiency. 






\begin{table}[ht]
\centering
\begin{tabular}{l|cc|cc|ccc}
\toprule
\multirow{2}{*}{\textbf{Scheme}} & \multicolumn{2}{c|}{\textbf{Verify - Public}} & \multicolumn{2}{c|}{\textbf{Show - Anonymous}} & \multicolumn{3}{c}{\textbf{Verify - Anonymous}} \\
& Verify & Data Sent & Preparation & PoK & Pairing & Proof Verify & Data Sent \\
\midrule
CL04 & $3P$ & $3|\G_1|$ & $(2r + 3)E_{\G_1}$ & $(2r + 1)E_{\G_1}$ & $(3r + 2)P$ & $(r + 2)E_{\G_1}$ & $(2r + 3)|\G_1| + |PK|$ \\
BBS+ & $2P$ & $2|\G_1|$ & $3E_{\G_1}$ & $(r + 4)E_{\G_1}$ & $2P$ & $(r + 2)P + (r + 3)E_{\G_T}$ & $2|\G_1| + |PK|$ \\
PS & $2P$ & $2|\G_1|$ & $2E_{\G_1}$ & $(r + 1)E_{\G_T}$ & $2P$ & $(r + 1)E_{\G_T}$ & $2|\G_1| + |PK|$ \\
\bottomrule
\end{tabular}
\caption{Comprehensive comparison of anonymous credential schemes. $P$ denotes pairing operation, $E_{\G_1}$ and $E_{\G_T}$ denote exponentiations in $\G_1$ and target group $\G_T$ respectively, $r$ denotes number of attributes, $|\G_1|$ denotes group element size, and $|PK|$ denotes proof of knowledge size.}
\label{tab:unified-comparison}
\end{table}






\begin{table}[ht]
\centering
\begin{tabular}{l|cc|cc|cc}
\toprule
\multirow{2}{*}{\textbf{Scheme}} & \multicolumn{2}{c|}{\textbf{Verify - Public}} & \multicolumn{2}{c|}{\textbf{Show - Anonymous}} & \multicolumn{2}{c}{\textbf{Verify - Anonymous}} \\
& Verify & Data Sent & Preparation & Gen. Proofs & Pairing & Proof of Knowledge \\
\midrule
CL04 & $3P$ & $3|\G_1|$ & $(2r + 3)E_{\G_1}$ & $(2r + 1)E_{\G_1}$ & $(3r + 2)P$ & $(r + 2)E_{\G_1}$ \\
BBS+ & $2P$ & $2|\G_1|$ & $3E_{\G_1}$ & $(r + 4)E_{\G_1}$ & $2P$ & $(r + 2)P + (r + 3)E_{\G_T}$ \\
PS & $2P$ & $2|\G_1|$ & $2E_{\G_1}$ & $(r + 1)E_{\G_T}$ & $2P$ & $(r + 1)E_{\G_T}$ \\
\bottomrule
\end{tabular}
\caption{Comprehensive comparison of anonymous credential schemes. $P$ denotes pairing operation, $E_{\G_1}$ and $E_{\G_T}$ denote exponentiations in $\G_1$ and target group $\G_T$ respectively, $r$ denotes number of attributes, and $|\G_1|$ denotes group element size.}
\label{tab:unified-comparison}
\end{table}



\begin{table}[ht]
\centering
\begin{tabular}{l|cc|cc|ccc}
\toprule
\multirow{2}{*}{\textbf{Scheme}} & \multicolumn{2}{c|}{\textbf{Verify - Public}} & \multicolumn{2}{c|}{\textbf{Show - Anonymous}} & \multicolumn{3}{c}{\textbf{Verify - Anonymous}} \\
& Verify & Data Sent & Preparation & Gen. Proofs & Pairing & Proof Verify & Data Sent \\
\midrule
CL04 & $3P$ & $3|\G_1|$ & $(2r + 3)E_{\G_1}$ & $(2r + 1)E_{\G_1}$ & $(3r + 2)P$ & $(r + 2)E_{\G_1}$ & $(2r + 3)|\G_1| + (2r + 1)|\G_1|$ \\ \\
BBS+ & $2P$ & $2|\G_1|$ & $3E_{\G_1} + 1P$ & $(r + 4)E_{\G_T}$ & $2P$ & $(r + 2)P + (r + 3)E_{\G_T}$ & $2|\G_1| + (r + 4)|\G_1|$ \\
PS & $2P$ & $2|\G_1|$ & $2E_{\G_1}$ & $(r + 1)E_{\G_T}$ & $2P$ & $(r + 1)E_{\G_T}$ & $2|\G_1| + (r + 1)|\G_T|$ \\
\bottomrule
\end{tabular}
\caption{Comprehensive comparison of anonymous credential schemes. $P$ denotes pairing operation, $E_{\G_1}$ and $E_{\G_T}$ denote exponentiations in $\G_1$ and target group $\G_T$ respectively, $r$ denotes number of attributes, $|\G_1|$ denotes group element size, and $|PK|$ denotes proof of knowledge size.}
\label{tab:unified-comparison}
\end{table}



\subsection{Foundational Schemes}
\begin{table}[ht]
\centering
\label{tab:original-schemes}
\begin{tabular}{l|ccccc}
\toprule
\textbf{Scheme} & \textbf{Verify} & \textbf{Data Sent} & \textbf{Show} & \textbf{Verify} & \textbf{Data Sent} \\
& \textbf{Standard} & \textbf{Standard} & \textbf{(User)} & \textbf{Anonymous} & \textbf{Anonymous} \\
\midrule
CL04 & $3P$ & $3|\G_1|$ & $(2r+4)\G_1$ & $(4r+2)P$ & $(2r+3)|\G_1| + |PK|$ \\
BBS+ & $2P$ & $2|\G_1|$ & $PK{P[r+4]}$ & $Ver(PK)$ & $2|\G_1| + |PK|$ \\
PS & $2P$ & $2|\G_1|$ & $2\G_1 + PK{P[r+1]}$ & $Ver(PK)$ & $2|\G_1| + |PK|$ \\
\bottomrule
\end{tabular}
\caption{$R_{\G_1}, R_\Z$ denotes generating random $\G_1$ point or $\Z_p$ element. $E_{\G_1}, E_{\G_2}, E_P$ denotes exponentiation in either $\G_1, \G_2, \G_T$. $P$ denotes pairing operation.}
\end{table}


\begin{table}[ht]
\centering
\label{tab:show-operations-precise}
\begin{tabular}{l|cc}
\toprule
\textbf{Scheme} & \textbf{Prepare} & \textbf{Proofs} \\
\midrule
CL04 & $(2r + 3)E_{\G_1}$ & $(2r + 1)E_{\G_1}$ \\
BBS+ & $3E_{\G_1}$ & $(r + 4)E_{\G_1}$ \\
PS & $2E_{\G_1}$ & $(r + 1)E_{\G_T}$ \\
\bottomrule
\end{tabular}
\caption{Precise analysis of show operation costs. $E_{\G_1}$ denotes exponentiation in $\G_1$, $E_{\G_T}$ denotes exponentiation in target group $\G_T$. $r$ denotes number of attributes.}
\end{table}

\begin{table}[ht]
\centering
\label{tab:verify-operations-corrected}
\begin{tabular}{l|cc}
\toprule
\textbf{Scheme} & \textbf{Structure} & \textbf{Proof Verification} \\
\midrule
CL04 & $(3r + 2)P$ & $(r + 2)E_{\G_1}$ \\
BBS+ & $2P$ & $(r + 2)P + (r + 3)E_{\G_T}$ \\
PS & $2P$ & $(r + 1)E_{\G_T}$ \\
\bottomrule
\end{tabular}
\caption{Corrected analysis of verification costs. $P$ denotes pairing operation, $E_{\G_1}$ and $E_{\G_T}$ denote exponentiations in $\G_1$ and $\G_T$ respectively. $r$ denotes number of attributes.}
\end{table}



The 2 security properties for anonymous credentials 
- Unforgeability: models a malicious user, derived from the signature construction and generally follows EUF-CMA. As constructions typically build upon a commitment scheme, the hiding and binding properties of a commitment scheme works well with the (some property) of an EUF-CMA signature scheme. or unforgeable committed signature scheme. 
- Anonymity: models a malicious issuer and verifier trying to link multiple presentations of a credential, trying to link credentials to a user, trying to do some other tasks

And thus the goal of an anonymous credential system is to enable 
- Privacy Preserving Authentication - sers can prove possession of certified attributes while maintaining anonymity, leveraging zero-knowledge proofs to demonstrate validity without revealing the credential itself.
- Blind Signing for private issuance
- Unlinkability
- Selective Disclosure
- rerandomization for unlinkable credential presentations

This work examines several foundational signature schemes - CL, BBS+, and PS signatures - analyzing their suitability for anonymous credential systems through the lens of efficiency, privacy features, and practical considerations.





Authentication Overhead


Standard signatures: Direct verification via pairings
Anonymous credentials: Additional zero-knowledge proofs required
Proving knowledge of signature components increases computational cost


Signature Properties for Anonymous Credentials


Rerandomizability enables unlinkability between showings
Blind signing with Pedersen commitments protects user privacy during issuance
Zero-knowledge compatibility enables private attribute proofs
Non-reliance on random oracles strengthens security guarantees


Implementation Considerations


BBS+ offers constant-size signatures but isn't rerandomizable
CL signatures provide rerandomizability but have linear size
PS signatures combine constant size with rerandomizability
Tradeoff between efficiency and privacy features


Thresholdise capability

BBS+ They do not “thresholdize” very well: t-out-of- threshold protocols for BBS+ (and standalone BBS) either require offline preprocessing or multiple rounds of interaction between signers.



Verification Methods


Direct verification: Pairing-based signature checks
Anonymous showing: Zero-knowledge proofs of signature possession
Selective disclosure: Proving subset of attributes while hiding others













\subsection{Foundational Schemes}
\begin{table}[ht]
\centering
\label{tab:original-schemes}
\begin{tabular}{lcccc}
\toprule
\textbf{Feature} & \textbf{CL04} & \textbf{BBS+} & \textbf{PS} \\
\midrule
Signature size & $(1 + 2r)\G_1$ & $3\G_1$ & $2\G_1$ \\
Public key size & $(r+1)\G_1$ & $2\G_1$ & $2\G_1$ \\
Show (User) & $(2r+4)\G_1$ & $PK\{P[r+4]\}$ & $2\G_1 + PK\{P[r+1]\}$ \\
Verify (Verifier) & $(4r+2)P$ & $Ver(PK)$ & $Ver(PK)$ \\
Data Sent & $(2r+3)\G_1 + |PK|$ & $2\G_1 + |PK|$ & $2\G_1 + |PK|$ \\
Randomizable & Yes & No & Yes \\
% Proof complexity & Linear pairings & Joint proofs & Modular \\
\bottomrule
\end{tabular}
\caption{Comparison of original signature schemes, $R_{\G_1}, R_\Z$ denotes generating random $\G_1$ point or $\Z_p$ element. $E_{\G_1}, E_{\G_2}, E_P$ denotes exponentiation in either $\G_1, \G_2, \G_T$. $P$ denotes pairing operation}
\end{table}






Anonymous credential systems require signature schemes that balance efficiency, privacy, and support for complex proofs. 
We analyze three foundational schemes—CL04, BBS+, and PS—and their extensions, focusing on their suitability for multi-issuer, multi-credential attribute-based credential systems. 

There is significant overhead between verifying credentials non-privately or just verifying the credential is valid, and verifying attributes themselves. 



\subsection{Foundational Schemes}
\begin{table}[ht]
\centering
\caption{Comparison of original signature schemes}
\label{tab:original-schemes}
\begin{tabular}{lccc}
\toprule
\textbf{Feature} & \textbf{CL04} & \textbf{BBS+} & \textbf{PS} \\
\midrule
Signature size & $O(n)$ & $O(1)$ & $O(1)$ \\
Public key size & $O(n)$ & $O(1)$ & $O(1)$ \\
Rerandomizable & Yes & No & Yes \\
Proof complexity & Linear pairings & Joint proofs & Modular \\
Attribute consistency & Impractical & Nested ZKPs & Via commitments \\
Batchability (same PK) & No & No & Yes \\
Implementation & Complex $\mathbb{G}_T$ proofs & Custom ZKPs & Standard $\Sigma$-protocols \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Extended Schemes}
\begin{table}[ht]
\centering
\caption{Comparison of improved schemes}
\label{tab:improved-schemes}
\begin{tabular}{lcc}
\toprule
\textbf{Feature} & \textbf{BBS+ (Anonymous Attestation)} & \textbf{PS (UTT Variant)} \\
\midrule
Key improvement & $\mathbb{G}_1$ proofs & Pedersen integration \\
Proof overhead & +1 pairing & +2 pairings \\
Attribute consistency & Nested proofs & Shared randomness \\
Cross-PK batchability & No & Key linking \\
ZKP compatibility & Specialized & Standard libraries \\
\bottomrule 
\end{tabular}
\end{table}



\subsection{Conclusion}
While CL04 and BBS+ established foundational properties, the PS signature scheme with UTT extensions uniquely satisfies modern requirements for multi-credential systems: constant-size signatures, efficient cross-key batchability, and compatibility with standardized ZKP toolchains. The ability to prove attribute consistency via shared Pedersen commitments—without requiring nested proofs or linear overhead—makes it the optimal choice for practical deployments.˝





Outline
- Initial schemes BBS+, CL04, PS used sigma protocols with proofs in Gt. Computation is slow, group elements are large, implementations are more complex. 
- CL signatures can be rerandomized but the pairings are linear in the number of attributes. 
- BBS+ are constant size signatures but can't essentially be rerandomized because the message commitment is "intertwined" with the signature and thus the signature and committed messages must be proven together, this makes the proof more complex but overhead smaller.
- Anonymous Attestation improved BBS+ by proving in G1 adding overhead by 1 pairing and but because of the structure of the signature, remains complex zkp's
- UTT version added 2 pairings, proving in G1 but with the added simplicity of proving knowledge of a pedersen commitment. This is extremely important for practical use cases. 

Improvements started with
Anonymous Attestation - improved BBS+
CL04? not sure if it was improved
PS - improved, that's what we're using, the first to use it












\subsection{BBS+}
Overview the BBS+ signature and protocol for proving knowledge of the attributes.

\sam{need to go through the proofs again for correctness}

\begin{figure}
   \begin{pchstack}[boxed, center, space=1em]
        \begin{pcvstack}
            \procedure[]{$\mathrm{Algorithm} \; \mathsf{BBS.Setup}(\secparam)$}{%
                \mathsf{BG =}(p, \G_1, \G_2, \G_T, e, g, \hat{g}) \sample \mathsf{BGGen}(\secparam) \\
                g \sample G_1, \vec{h} \sample \G_1^{n+1}, \hat{g} \sample \G_2 \\
                pp \gets (p, g, \{{h}_i\}_0^n, \hat{g}, \G_1, \G_2, \G_T, e) \\
                \pcreturn pp \\
        }
            \procedure[]{$\mathrm{Algorithm} \; \mathsf{BBS.KG(pp)}$}{%
                pp \gets (p, g, \{{h}_i\}_0^n, \hat{g}, \G_1, \G_2, \G_T, e) \\
                x \sample \Z_p^*, \hat{w} \gets \hat{g}^x \\
                sk = x, pk = (\hat{w}, \{{h}_i\}_0^n) \\
                \pcreturn (sk, pk) \\
            }
            \procedure[]{$\mathrm{Algorithm} \; \mathsf{BBS.Sign}(sk = x, \vec{m} = (m_1, \ldots, m_n))$}{%
                e, s \sample \Z_p^* \\
                A \gets (gh_0^s\prod_1^n h_i^{m_i})^{\frac{1}{e+x}} \\
                \pcreturn \sigma \gets (A,e,s) \\
            }
            \procedure[]{$\mathrm{Algorithm} \; \mathsf{BBS.Verify}(pk, \vec{m}, \sigma = (A,e,s) )$}{%
                \text{Check } e(A, \hat{w}\cdot \hat{g}^e) = e(gh_0^s\prod_1^n h_i^{m_i}, \hat{g}) \\
            }
            \procedure[]{$\mathrm{Algorithm} \; \mathsf{BBS.SignCommitted}(sk = x, \vec{m})$}{%
                \Prover \text{ samples } s' \sample Z_p^* \; \text{ commits to } \vec{m} : \; \cm = h_0^{s'}\prod_1^n h_i^{m_i}\\
                \t \text{ Computes }\pi = PoK\{(s', \vec{m}) : \cm = h_0^{s'}\prod_{1}^n h_i^{m_i} \} \\
                \mathcal{S} \text{ Signer verifies cm is well formed } \mathsf{ZK.Verify}(\pi, \cm) = 1 \\
                \t \text{ signer samples } s'', e \sample Z_p^* \\
                \t \text{ computes } A = (gh_0^{s''}\cm)^{\frac{1}{e+x}}, \text{ returns } (A,e,s'') \\
                \Prover \text{ computes } s = s' + s'', \text{ and } \sigma = (A,e,s) \\
            }
        \end{pcvstack}
        \begin{pcvstack}
        \procedure[]{$\mathrm{Algorithm} \; \mathsf{BBS.ProveSignature}(pk, \sigma = (A,e,s), \vec{m})$}{%
            r_1 \sample \Z_p^* \\
            A' \gets A^{r_1}, r_3 \gets \frac{1}{r_1} \\
            \Bar{A} \gets A'^{-e} \cdot (gh_0^s\prod_1^n h_i^{m_i})^{r_1} \\
            r_2 \sample \Z_p^* \\
            d \gets (gh_0^s\prod_1^n h_i^{-m_i})^{r_1} \cdot h_0^{-r_2} \\
            s' \gets s - r_2 \cdot r_3 \\
            r_e, r_s, \{r_{m_i}\}_{i=1}^n \sample \Z_p^* \\
            T_1 \gets A^{r_e} \cdot h_0^{r_s} \\
            T_2 \gets g^c\prod_{i=1}^n h_i^{r_{m_i}} \\
            c \gets \mathcal{H}(A', \Bar{A}, T_1, T_2) \\
            z_e \gets r_e + c \cdot e \\
            z_s \gets r_s + c \cdot s \\
            \forall i \in [1,n]: z_{m_i} \gets r_{m_i} + c \cdot m_i \\
            \pi \gets (A', \Bar{A}, d, T_1, T_2, z_e, z_s, \{z_{m_i}\}_{i=1}^n) \\
            \pcreturn \pi \\
        }
        \procedure[]{$\mathrm{Algorithm} \; \mathsf{BBS.VerifyProof}(pk, \pi)$}{%
            \text{Parse } \pi \text{ as } (A', \Bar{A}, d, T_1, T_2, z_e, z_s, \{z_{m_i}\}_{i=1}^n) \\
            \text{Check } A' \neq 1_{\G_1} \\
            \text{Check } e(A',\hat{w}) = e(\Bar{A},\hat{g}) \\
            c \gets \mathcal{H}(A', \Bar{A}, T_1, T_2) \\
            \text{Check } T_1 = A^{z_e} \cdot h_0^{z_s} \cdot (\Bar{A})^{-c} \\
            \text{Check } T_2 = g^c\prod_{i=1}^n h_i^{z_{m_i}} \\
            \pcreturn \text{all checks pass} \\
        }
        \end{pcvstack}
    \end{pchstack}
    \caption{Zero-knowledge proof of knowledge protocol for BBS+ signatures. The proof $\pi$ consists of $(k+5)$ group elements in $\G_1$ and $(k+5)$ scalars in $\Z_p$, where $k$ is the number of hidden message components.}
    \label{fig:bbs-zkp}
\end{figure}


\newpage







\newpage
\subsection{\cite{camenisch_anonymous_2016} BBS+ Signature Proof of Knowledge}
\sam{working on this one, should try to prove soundness in ABar / d = A'e dot h0r2}
\begin{protocol}{CDL16 Zero-Knowledge Proof of Knowledge of BBS+  \cite{camenisch_anonymous_2016}}{bbsplus-pok-2016}
    \textbf{Relation $\mathcal{R}$}
        \[
        \pi \gets \mathsf{SPK}\{(m_1,\ldots,m_{\ell}), e, r_2, r_3, s'): \quad \frac{\Bar{A}}{d} = A'^{-e} \cdot h_0^{r_2} \quad \wedge \quad g = d^{r_3}h_0^{-s'}\prod_{i=1}^n h_i^{-m_i}\}
        \]
    \textbf{Common Input:} $(p, \G_1, \G_2, \G_T, e, g_2)$, $pk = (\hat{w}, \{h_i\}_{i=0}^n)$

    \textbf{Private Input:} $\Prover$ has BBS+ signature $(A,e,s)$ where $A = (gh_0^s\prod_{i=1}^n h_i^{m_i})^{\frac{1}{e+x}}$ and $b = gh_0^s \prod_1^nh_i^{m_i}$

    \vspace{1em}
    \begin{enumerate}
        \item $\Prover$ samples random $r_1, r_2 \sample \Z_p^*$, set $r_3 = \frac{1}{r_1},$ and $s' \gets s - r_2 \cdot r_3$
         \begin{itemize}
        \item Compute blinded signature: $A' \gets A^{r_1}$ and set $\Bar{A} \gets A'^{-e} \cdot b^{r_1}$ $\quad (=A'^{x})$ 
        
        \item compute $d \gets (gh_0^s \prod_1^nh_i^{-m_i})^{r_1} \cdot h_0^{-r_2}$

        \item sample Schnorr blinding factors from $\Z_p$
         \[
         \tilde{x} \text{ for } x \in \{r_1, r_2, e, s, m_1, \ldots, m_{\ell}\}
         \]

        \item compute Schnorr Commitments:
        \[
        T_1 \gets A^{\tilde{e}} \cdot h_0^{\tilde{s}} \qquad T_2 \gets g\prod_{i=1}^n h_i^{\tilde{m_i}}
        \]
        
        \item  Send $(A', \Bar{A}, d, T_1, T_2)$ to $\Verifier$
                
        \end{itemize}

    \item $\Verifier$ sends challenge $c \sample \Z_p^*$\

    \item $\Prover$ computes Schnorr responses:
         \[
         z_x = \tilde{x} + c \cdot x \text{ for } x \in \{r_1, r_2, e, s', m_1, \ldots, m_{\ell}\}
         \]
 
    \item $\Verifier$ checks
        \[
            A' \neq 1_{\G_1} \quad \wedge \quad e(A',\hat{w}) = e(\Bar{A},g_2) \qquad T_1 \stackrel{?}{=} A^{z_e} \cdot h_0^{z_s} \cdot (\Bar{A})^{-c} \qquad T_2 \stackrel{?}{=} g^c\prod_{i=1}^n h_i^{z_{m_i}}
        \]
    \end{enumerate}
\end{protocol}

\newpage
\subsection{Protocol Analysis}


\begin{itemize}
    \item \textbf{Prover's Operations}
        \begin{itemize}
            \item $r_3 = \frac{1}{r_1}$ \qquad $1I_p$
            \item $s' = s - r_2 \cdot r_3$ \qquad $1M_p + 1A_p$
            \item $A' \gets A^{r_1}$ \qquad $(1E\G_1)$
            \item $\Bar{A} \gets A'^{-e} \cdot b^{r_1}$ \qquad   $(2E\G_1)$ + $1M_{\G_1}$
            \item $d \leftarrow (gh_0^{r_1}\prod h_i^{-m_i})^{r_2} \cdot h_0^{r_3}$ \qquad $(n+2)E_{\mathbb{G}_1} + (n-1)M_{\mathbb{G}_1}$
        \end{itemize}
    \item \textbf{Prover Schnorr Operations}
        \begin{itemize}
            \item sample n+4 field elements (negligible)
            \item $T_1 \gets A^{\tilde{e}} \cdot h_0^{\tilde{s}}$ \qquad $(2E\G_1)$
            \item $T_2 \gets g\prod_{i=1}^n h_i^{\tilde{m_i}}$ \qquad  $nE\G_1 + (n-1)M_{\G_1}$
            \item compute n+4 responses (negligible)
        \end{itemize}
    \item \textbf{Proof Size / Data Sent}
        \begin{itemize}
            \item $(A', \Bar{A}, d, T_1, T_2)$ \qquad $5E_{\G_1}$
            \item $z_x = \tilde{x} + c \cdot x \text{ for } x \in \{r_1, r_2, e, s', m_1, \ldots, m_{\ell}\}$ \qquad $(n + 4)\Z_p*$
        \end{itemize}
    \item \textbf{Verifier Operations}
    \begin{itemize}
        \item $e(A',\hat{w}) = e(\Bar{A},g_2)$ \qquad $1P$
    \end{itemize}
    \item \textbf{Verifier Schnorr Operations}
    \begin{itemize}
        \item $T_1 \stackrel{?}{=} A^{z_e} \cdot h_0^{z_s} \cdot (\Bar{A})^{-c}$ \qquad $3E_{\G_1}$ + $2M_{\G_1}$
        \item $T_2 \stackrel{?}{=} g^c\prod_{i=1}^n h_i^{z_{m_i}}$ \qquad $(n+1)E_{\G_1}$ + $(n-1)M_{\G_1}$
    \end{itemize}
\end{itemize}



\noindent\textbf{Notation:}
\begin{itemize}
\item $I_p$: Field inversion in $\mathbb{Z}_p$
\item $M_p$: Field multiplication in $\mathbb{Z}_p$
\item $A_p$: Field addition in $\mathbb{Z}_p$
\item $E_{\mathbb{G}_1}$: Exponentiation in group $\mathbb{G}_1$
\item $M_{\mathbb{G}_1}$: Multiplication in group $\mathbb{G}_1$
\item $P$: Pairing Equality check
\item $n$: Number of $h_i$ elements (system parameter)
\end{itemize}










\newpage

\begin{itemize}
    \item Group elements in $\G_1: $ $A', \Bar{A}, d, T_1, T_2, $
    \item Scalars: blinding factors for PoK $z_e, z_s, \{m_i\}_1^k, r_1, r_2, r_3$
\end{itemize}

Notes
We know $A = b^{\frac{1}{e+x}}$, $b^{\frac{-er_1}{e+x}} \cdot b^{\frac{r_1(e+x)}{e+x}} = A^{r_1x} = A'^x$


The resulting proof is $(A', \Bar{A}, d, \pi)$. To verify, the verifier checks $A' \neq 1_{\G_1} \wedge e(A', \hat{X}) = e(\Bar{A}, \hat{g})$ and verifies $\pi$
we don't want to reveal $k$ components
$CDL$ proof is 3 $\G_1$ and $k+5$ elements in $\G_1$ and $k+5$ scalars


\newpage
We analyze the computational complexity of the Proof of Knowledge of a BBS+ signature with respect to the \textbf{Prover} and \textbf{Verifier}. The computations are categorized into random scalar generation, scalar multiplications, exponentiations in the groups $\mathbb{G}_1$, $\mathbb{G}_2$, and $\mathbb{G}_T$, and pairings.

\subsection{Prover Complexity}
The Prover performs the following computations:
\begin{itemize}
    \item \textbf{Random Scalars:} Generate $r_1, r_2 \in \mathbb{Z}_p^*$ and $L+4$ random scalars for the Schnorr proof. Total: $L+6$ random scalars.
    \item \textbf{Scalar Multiplications:} Compute $\delta_1 = r_1 e$ and $\delta_2 = r_2 e$. Total: 2 scalar multiplications.
    \item \textbf{Exponentiations in $\mathbb{G}_1$:}
    \begin{itemize}
        \item Compute $A_1 = g_1^{r_1} g_2^{r_2}$: 2 exponentiations and 1 group addition.
        \item Compute $A_1^e = g_1^{\delta_1} g_2^{\delta_2}$: 2 exponentiations and 1 group addition.
    \end{itemize}
    Total: 4 exponentiations and 2 group additions.
    \item \textbf{Pairings:} Compute $\mathsf{e}(A_2, w)$ and $\mathsf{e}(g_0, h_0)$. Total: 2 pairings.
    \item \textbf{Schnorr Proof of Knowledge:}
    \begin{itemize}
        \item Prove knowledge of $r_1, r_2, \delta_1, \delta_2, e, s, m_1, \ldots, m_L$. 
        \item Compute $L+4$ commitments in $\mathbb{G}_T$ (one per attribute plus $e$, $s$, $r_1$, $r_2$). Total: $L+4$ exponentiations in $\mathbb{G}_T$.
    \end{itemize}
\end{itemize}

\subsection{Verifier Complexity}
The Verifier performs the following computations:
\begin{itemize}
    \item \textbf{Schnorr Verification:}
    \begin{itemize}
        \item Verify $A_1 = g_1^{r_1} g_2^{r_2}$: 2 exponentiations in $\mathbb{G}_1$.
        \item Verify $A_1^e = g_1^{\delta_1} g_2^{\delta_2}$: 2 exponentiations in $\mathbb{G}_1$.
    \end{itemize}
    Total: 4 exponentiations in $\mathbb{G}_1$.
    \item \textbf{Pairings:}
    \begin{itemize}
        \item Compute $\mathsf{e}(A_2, w)$, $\mathsf{e}(g_0, h_0)$, and $\mathsf{e}(g_{L+1}, h_0), \ldots, \mathsf{e}(g_1, h_0)$. Total: $L+4$ pairings.
    \end{itemize}
    \item \textbf{Exponentiations in $\mathbb{G}_T$:}
    \begin{itemize}
        \item For $L+4$ pairings, compute exponentiations with Schnorr responses. Total: $L+4$ exponentiations in $\mathbb{G}_T$.
    \end{itemize}
\end{itemize}

\subsection{Summary of Computational Cost}
\textbf{Prover:}
\begin{itemize}
    \item Random Scalars: $L+6$
    \item Scalar Multiplications: 2
    \item Exponentiations: 6 in $\mathbb{G}_1$, $L+4$ in $\mathbb{G}_T$
    \item Pairings: 2
\end{itemize}

\textbf{Verifier:}
\begin{itemize}
    \item Pairings: $L+4$
    \item Exponentiations: 4 in $\mathbb{G}_1$, $L+4$ in $\mathbb{G}_T$
\end{itemize}


\subsection{Optimizations}

\begin{itemize}
    \item \textbf{Multi-Exponentiation:} Instead of computing each exponentiation in $\mathbb{G}_1$ individually, the multi-exponentiation technique can be used to compute terms like $g_1^{r_1} g_2^{r_2}$ or $g_1^{\delta_1} g_2^{\delta_2}$ in a single operation. This reduces the overall cost of group exponentiations, especially for the Prover, where such computations dominate.

    \item \textbf{Precomputation:} rather than computing all pairings, Prover and Verifier can have precomputed points for some e.g. points can be computed in advance $\mathsf{e}(g_{L+1}, h_0), \ldots, \mathsf{e}(g_1, h_0)$

    \item \textbf{Miller Loop Optimization:} Pairing computations can be optimized by separating the Miller loop and the final exponentiation. For $L+4$ pairings, only a single final exponentiation in $\mathbb{G}_T$ is required after combining the results of $L+4$ Miller loops. This significantly reduces the overall cost, as the Miller loop is less computationally expensive than the final exponentiation. 

    \item \textbf{Batch Verification: } BBS+ signatures signed under the same public key can be batch verified
\end{itemize}

By employing these techniques:
\begin{itemize}
    \item \textbf{Prover:} Multi-exponentiation reduces the number of scalar multiplications during group operations.
    \item \textbf{Verifier:} Batching and Miller loop optimizations reduce the number of independent pairing computations and minimize the expensive operations in $\mathbb{G}_T$.
\end{itemize}





\newpage
\noindent \textbf{Relation Proved:} Knowledge of $(r_1, r_2, e, \delta_1, \delta_2, s, m_1, \dots, m_L)$ such that:
\[
\begin{aligned}
\mathsf{A}_1 &= \mathsf{g}_1^{r_1} \mathsf{g}_2^{r_2}, \\
\mathsf{A}_1^e &= \mathsf{g}_1^{\delta_1} \mathsf{g}_2^{\delta_2}, \\
\mathsf{A}^{e+\gamma} &= \mathsf{g}_0 \mathsf{g}_1^s \mathsf{g}_2^{m_1} \cdots \mathsf{g}_{L+1}^{m_L}, \\
\delta_1 &= r_1 e, \quad \delta_2 = r_2 e.
\end{aligned}
\]

\section*{Prover's Operations}
\begin{itemize}
  \item \textbf{Commitments in $\mathsf{G}_1$:}
    \begin{itemize}
      \item Compute $\mathsf{A}_1 = \mathsf{g}_1^{r_1} \mathsf{g}_2^{r_2}$, $\mathsf{A}_2 = \mathsf{A} \cdot \mathsf{g}_2^{r_1}$ (3 exponentiations).
      \item Compute $\mathsf{A}_1^e$ (1 exponentiation).
    \end{itemize}
  \item \textbf{Commitments in $\mathsf{G}_T$:}
    \begin{itemize}
      \item Construct $\mathsf{T} = \mathsf{e}(\mathsf{A}_2, \mathsf{h}_0)^{-\tilde{e}} \cdot \mathsf{e}(\mathsf{g}_2, \mathsf{w})^{\tilde{r}_1} \cdot \mathsf{e}(\mathsf{g}_2, \mathsf{h}_0)^{\tilde{\delta}_1} \cdot \mathsf{e}(\mathsf{g}_1, \mathsf{h}_0)^{\tilde{s}} \cdots \mathsf{e}(\mathsf{g}_{L+1}, \mathsf{h}_0)^{\tilde{m}_L}$.
      \item Requires 1 pairing ($\mathsf{e}(\mathsf{A}_2, \mathsf{h}_0)$) and $L+4$ exponentiations in $\mathsf{G}_T$.
    \end{itemize}
  \item \textbf{Responses:} Compute Schnorr responses for all secrets:
    \[
    z_x = \tilde{x} + c \cdot x \quad \text{for } x \in \{r_1, r_2, e, \delta_1, \delta_2, s, m_1, \dots, m_L\}.
    \]
\end{itemize}

\section*{Verifier's Operations}
\begin{itemize}
  \item \textbf{Schnorr Checks in $\mathsf{G}_1$:}
    \begin{itemize}
      \item Verify $\mathsf{A}_1 = \mathsf{g}_1^{r_1} \mathsf{g}_2^{r_2}$: 2 exponentiations.
      \item Verify $\mathsf{A}_1^e = \mathsf{g}_1^{\delta_1} \mathsf{g}_2^{\delta_2}$: 2 exponentiations.
    \end{itemize}
  \item \textbf{Pairing Checks in $\mathsf{G}_T$:}
    \begin{itemize}
      \item Compute $\text{LHS} = \frac{\mathsf{e}(\mathsf{A}_2, \mathsf{w})}{\mathsf{e}(\mathsf{g}_0, \mathsf{h}_0)}$ (2 pairings).
      \item Compute $\text{RHS} = \prod_{i=1}^{L+4} \mathsf{e}(\cdot)^{\text{precomputed}}_{z_i}$ ($L+4$ exponentiations).
      \item Verify $\text{LHS} \stackrel{?}{=} \text{RHS}$.
    \end{itemize}
\end{itemize}

\noindent \textbf{Summary:}
\[
\begin{aligned}
\text{Prover: } & 
\begin{cases} 
4 \text{ $\mathsf{G}_1$ exponentiations} \\
1 \text{ pairing } (\mathsf{e}(\mathsf{A}_2, \mathsf{h}_0)) \\
L+4 \text{ $\mathsf{G}_T$ exponentiations}
\end{cases} \\
\text{Verifier: } & 
\begin{cases} 
4 \text{ $\mathsf{G}_1$ exponentiations} \\
L+4 \text{ $\mathsf{G}_T$ exponentiations} \\
2 \text{ pairings } (\mathsf{e}(\mathsf{A}_2, \mathsf{w}), \mathsf{e}(\mathsf{g}_0, \mathsf{h}_0))
\end{cases}
\end{aligned}
\]


















\newpage
\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Operation} & \textbf{Prover} & \textbf{Verifier} \\
\hline
\multicolumn{3}{|l|}{\textbf{Commitment Equality Method}} \\
\hline
G1 exponentiations & 4 & 5 \\
G1 additions & 2 & 4 \\
Fp multiplications & 3 & 0 \\
Fp additions & 3 & 0 \\
\hline
\multicolumn{3}{|l|}{\textbf{G1 VRF Method}} \\
\hline
G1 exponentiations & 11 & 11 \\
G1 additions & 4 & 7 \\
Fp multiplications & 6 & 0 \\
Fp additions & 6 & 0 \\
\hline
\multicolumn{3}{|l|}{\textbf{Pairing + VRF Method}} \\
\hline
G1 exponentiations & 2 & 3 \\
G2 exponentiations & 2 & 3 \\
G1 additions & 1 & 2 \\
G2 additions & 1 & 2 \\
Fp multiplications & 12 & 0 \\
Fp additions & 8 & 0 \\
GT exponentiations & 8 & 5 \\
GT multiplications & 6 & 4 \\
Pairings & 4 & 4 \\
\hline
\end{tabular}
\caption{Comparison of computational operations between G1 and Pairing methods}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{|l|r|}
\hline
\textbf{Operation} & \textbf{Time} \\
\hline
Full Pairing & 1.6218 ms \\
Miller Loop & 0.6931 ms \\
Final Exponentiation & 0.9287 ms \\
G1 Mixed Addition (Affine + Jacobian) & 672 ns \\
G1 Point Doubling (2P) & 414 ns \\
G2 Mixed Addition (Affine + Jacobian) & 2143 ns \\
G2 Point Doubling (2P) & 1302 ns \\
\hline
Estimated G1 Scalar Mult (255-bit) & 191.59 $\mu$s \\
\emph{\small(255 doublings + ~128 additions)} & \\
Estimated G2 Scalar Mult (255-bit) & 606.01 $\mu$s \\
\emph{\small(255 doublings + ~128 additions)} & \\
\hline
\end{tabular}
\caption{Performance metrics for arkworks BLS12-381 implementation. Scalar multiplication estimates assume naive double-and-add implementation without optimizations.}
\label{tab:arkworks-performance}
\end{table}
\footnotetext{The G1 and G2 scalar multiplication estimates are derived using a naive double-and-add implementation analysis for 255-bit scalars. For a random scalar $k$, we assume approximately 255 doubling operations (one per bit) and 128 addition operations (corresponding to an expected Hamming weight of $\frac{255}{2}$ for a random scalar). The G1 estimate of 191.59$\mu$s is computed as $(255 \times 414\text{ns}) + (128 \times 672\text{ns})$ using the measured doubling and mixed addition timings. Similarly, the G2 estimate of 606.01$\mu$s is computed as $(255 \times 1302\text{ns}) + (128 \times 2143\text{ns})$. These estimates represent upper bounds as they do not account for common optimizations such as windowing methods, NAF (Non-Adjacent Form) representations, or parallel computation strategies.}










\subsection{CL04}
