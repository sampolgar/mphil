 \section{Introduction}\label{sec:intro}
Digital Identity systems form the foundation of online trust and authentication, processing billions of verifications daily \cite{noauthor_happy_2021, pang_zanzibar_nodate}. Traditional centralized systems, while effective for regulatory compliance \cite{eltayeb_crucial_2024}, suffer from significant privacy and security vulnerabilities. Ongoing data breaches \cite{zhang_data_2022} affect billions of users, demonstrating the risks of storing identity data and centralizing systems. Decentralized Identity (DID) is a loosely defined framework (W3C specification) having evolved over the past 2 decades, offering users greater control over their credentials \cite{soltani_survey_2021}, many concrete implementations struggle to balance privacy with accountability \cite{maram2021candid} for the required feature set. 


\noindent Anonymous Credential Systems (ACS) \cite{chaum1985security,hutchison_signature_2004, hutchison_constant-size_2006, sako_short_2016, fuchsbauer_structure-preserving_2019} address privacy concerns but face challenges balancing privacy with accountability, orthogonally, unconditionally anonymous payment systems have demonstrated how unconditional anonymity can enable system abuse. Current systems focus on protecting against sybil attacks \cite{crites_syra_2024, rabaninejad_attribute-based_nodate}, enabling revocation \cite{goos_dynamic_2002, robshaw_uc_2016, camenisch_scalable_2016, baldimtsi_accumulators_2017}, rich attribute-based credential authentication \cite{rosenberg_zk-creds_2022, babel_bringing_2023} but very few implement all. The tension between privacy and accountability has become increasingly critical as governments worldwide, particularly the EU's Digital Identity Framework \cite{noauthor_regulation_2024}, move toward privacy-preserving digital identity wallets. These challenges motivate the need for a comprehensive identity system that achieves privacy, accountability, and practical deployment requirements simultaneously.

\subsection{Organization}

Short Summary: We build a new anonymous credential building block for multi-issuer, multi-credential systems. We use it to build a new private digital identity system with sybil resistance and revocation.


\begin{enumerate}
    \item section \ref{sec:mimc} is the new anonymous credential system building block for multi-issuer, multi-credential
    \item section \ref{sec:sigmaproofs} outlines all sigma zkp's used
    \item section \ref{sec:idsys} builds a private identity system from the building block in section \ref{sec:mimc} and proofs in \ref{sec:sigmaproofs}
    \item section \ref{sec:evaluation} shows privacy and sybil resistance can be low-overhead, also shows our benchmarks for proving complex statements about credentials is more efficient than SOTA
\end{enumerate}

\subsection{Organization Update 8/2}
We build a new anonymous credential building block for multi-issuer, multi-credential systems with an improved credential and sigma proof for sybil resistance. 

Outline and Contributions
\begin{itemize}
    \item \ref{sec:commitment} Outline the variant of Pedersen Commitments we use, we prove position binding in SDLP (first to do that)
    \item \ref{sec:pssignature} Outline the variant of PS signatures we use, we prove security in AGM (best detailed proof) and improve verification efficiency and proof size compared to SOTA. We show why it's the best for complex use cases
    \item \ref{sec:sigmaproofs} Outline sigma protocols we use in the anonymous credential system, create the inverse protocol to prove hidden VRF
    \item \ref{sec:mimc} use the above 3 in a new multishow multiissuer anonymous credential system with sybil resistance
    \item \ref{sec:evaluation} Analysis of the SOTA pairing based anonymous credentials
\end{itemize}



\subsection{Related Work}

\subsubsection{Decentralized Identity (DID)}
enables entities to create and manage digital identities without relying on a central authority. W3C specifications for DID and Verifiable Credentials define standards for globally unique, publicly verifiable credentials, allowing a user to prove claims (information) about their identity attributes. DID typically uses Distributed Ledgers and public key cryptography to establish a "web of trust" and maintain revocation registries. 

The DID model consists of 
\begin{enumerate}
    \item \textbf{Holders} Identities with Decentralized Identifiers (DID's) who manage their own keys, and credentials, and request access to resources
    
    \item \textbf{Issuers} create and sign credentials about identity holders
    
    \item \textbf{Verifiers} validate credentials by checking the presented cryptographic information against the registry

    \item  \textbf{Verifiable Data Registry}, often a DLT, is the root of trust, maintaining DID records, keys, and credential schemas, but doesn't store credential data
    
    \item \textbf{Identity Wallet}: the user interface for storing, managing, and presenting verifiable credentials
\end{enumerate}
 
Citations
- U-Prove, U-Port, Connect.me, Sovrin, PingID, w3c

While the W3C DID specifications outline core functionalities such as cryptographic verification, privacy preservation, selective disclosure, and revocation, it requires a formal security definition and proofs to achieve these properties. Anonymous Credential Systems provide well-established formal security definitions for many properties that DID aims to achieve. Specifically, Correctness, Unforgeability, Anonymity, Sybil Resistance, and Revocation. By building DID systems on top of Anonymous Credential primitives, DID systems can inherit these formal security guarantees. 

\subsubsection{Multi Attribute Anonymous Credentials} 
Anonymous Credentials are a long line of orthogonal work with the goal of providing privacy/anonymity to online interactions, These are now deployed in a number of real-world systems (U-Prove, Idemix, PrivacyPass).  
The line of work has improved with features, efficiency, and expressiveness throughout time. 
Abstractly, they provide private protocols to prove information on committed attributes. 
Pairing-based blind signatures enabled efficient multi-show credentials (CL, PS, BBS+).
Other constructions are based on (chase's MAC's, etc) 
Further work was done to the Anonymous Credential primitive to support delegation, update, and pseudonyms and may also require incorporating other cryptographic primitives to enable revocation, auditing, tracing, and sybil resistance. 

\subsubsection{Anonymous Credential Systems (ACS)} 
Anonymous Credential Systems implement primitives together in ways that preserve privacy and offer additional functionality required by systems. The combination of multiple primtiives to be used together in a privacy preserving way is complex it itself. 

\noindent \textbf{Accountable Privacy}
In a parallel industry, fully private financial systems like zcash, monero, and tornado cash where blockchain users can exploit and misuse the system is a big problem and will prevent governments and organisations to deploy private preserving techniques. Innovations in Identity often follow those in financial systems, (Chaum's e-cash and blind signatures, DAC and ZCash for example) as they share similar motivations and infrastructure, spending a coin anonymously is analogous to using an identity anonymously. Therefore, advancements in the field of Accountable Privacy (UTT, other examples), a series of techniques and protocols that balance the tradeoffs between privacy and accountability in financial systems, can inspire and motivate private identity systems.

\noindent \textbf{Privacy Preserving Decentralized Identity Systems}
CanDID proposed a privacy-preserving decentralized identity system achieving Sybil Resistance, Accountability. 
They defined a system architecture that has been extended in many different directions, such as \cite{wang2023hades, rathee_zebra_2022} optimising for blockchain performance and additional private-accountability features. \cite{crites_syra_2024, rabaninejad_attribute-based_nodate} optimize for non-interactivity and minimal stored state with the CanDID threshold committee

CanDID leaves integrating Decentralized Identity with Anonymous Credentials as open work.

\noindent \textbf{Decentralized Identity with Anonymous Credentials}
The strawman approach to combining Decentralized Identity with Anonymous Credentials replaces the existing credential, usually in the form of a signature over attributes, signed by an identity provider and verifiable with their public key, with a blind signature over attributes, which introduces the accountable privacy problems such as how to issue and verify a credential to an anonymous user, and how to retain accountability of an anonymous user, such are the real-world identity system requirements. 
Compatibility for a decentralized architecture requires decentralized cryptography which has propelled the use of threshold cryptography in anonymous credential schemes and other settings e.g. (Coconut, Threshold BBS+, ...). 


\newpage

\subsection{Contributions}

We present a privacy-preserving decentralized identity system for multi-issuer environments. Our system combines anonymous credential primitives with decentralized identity architecture, achieving security and privacy properties that are challenging to realize when naively combining these building blocks. Our main contributions are:

\begin{enumerate}
    
    \item  A privacy-preserving identity system that enables secure credential chaining and complex anonymous identity verification across multiple issuers.

    \item A novel zero-knowledge building block that enables private proofs of VRF derivations from committed messages.
    
    \item  A complete system implementation using PS Signatures over commitments that achieves sybil resistance and revocation while enabling multi-issuer credential chaining - validated through concrete implementations, benchmarks, and formal security analysis.

\end{enumerate}

\subsection{Gap Analysis}

Digital identity is undergoing a fundamental transformation, evolving across three frontiers: decentralization, mandatory institutional adoption, and the emergence of attestation services.    
Identity systems are evolving from trusted, single-issuer models where a user authenticates with a single authority toward a decentralized paradigm where users publicly verify any multitude of credentials, manage multiple credentials for diverse issuers with their digital wallets.

\noindent As traditional organizations increasingly adopt decentralized identity capabilities and while it's also being mandated in the EU, they seek solutions that minimize changes to their existing infrastructure while enabling new DID capabilities and maintaining regulatory compliance. Beyond traditional organisations, a new frontier of credential issuance is emerging through automated attestation services like TLS Notary, Chainlink's DECO, Brave Browser's distefano, and Sui Labs zkLogin which enable verifiable data to become a credential. This transformation, while powerful, introduces challenges to identity systems run by governments and trusted organisations  who require sybil resistance protecation and revocation while maintaining privacy in a system where traditional infrastructure assumptions such as ease of revocation no longer hold.

\noindent \textbf{Core Challenges} Evolving from single-issuer to multi-issuer, multi-credential environments introduces several challenges. While existing solutions support private identity systems with anonymity, sybil resistance and revocation for single issuers. The introduction of multiple credentials and their sources transforms solved problems into new challenges. A decentralized system for the frontier of credentials must maintain anonymity across credential presentations, implement cross credential sybil resistance and efficient revocation checks without centralized trust.

\noindent Additionally, composing privacy-preserving primitives together to achieve the properties we require introduces complexity. While individual primitives for anonymous credentials, Sybil resistance, and revocation are well understood in isolation, the integration highlights the trilemma of accountable privacy systems - the tension between privacy, accountability, and functionality. The core challenge lies in designing efficient zero knowledge proof systems that combine these primitives in protocols that maintain the security and privacy properties of our system with practical efficiency.

\noindent Thirdly arises when users verify attributes from multiple credentials. Secure credential composition is required, while allowing flexible zero knowledge proof attribute attestations and selective disclosure. Lastly, users with multiple credentials require to privately prove their credentials are not revoked, introducing a scaling challenge - enabling efficient zero-knowledge batch proofs of non-membership while maintaining privacy and practical verification times. 




\subsection{Technical Challenges}

Building a privacy-preserving decentralized identity system requires balancing competing requirements: adhereing to strong security and privacy properties while retaining accountability measures and providing efficient verification of complex identity statements. While individual cryptographic primitives exist for many of these properties in isolation, combining them while maintaining security and efficiency introduces technical challenges, we identity three fundamental challenges below: 

\todonote{Rewrite this - start with rerand sigs over commitments, then extending that for multi-issuer, multi-cred, then using that for identity system}

\begin{enumerate}

    \item \textbf{Efficient Rerandomizable Signatures over Commitments} A key technical challenge was designing a signature scheme that efficiently supports both rerandomization and zero-knowledge proofs over-committed attributes. While existing schemes like BBS+, CL, and standard PS provide these properties, we use a customized PS signature with the lowest overhead in the randomization step. %what I want to say here is that after the randomization step, we are given a commitment in G1 which is easy and efficient to work with, rather than some other construction which needs custom proofs and new security proofs for each system built with it. 
    Unlike BBS+ and CL04, we maintain compatibility with standard Pedersen Commitments, enabling efficient proofs from standard techniques in the literature.
    

    \item \textbf{Sybil-Resistant Context Credential Construction} Designing an efficient mechanism to link context credentials to a master credential while preserving privacy, our solution uses a novel building block that combines a VRF with committed attributes - the user's Master Credential contains a commitment with their VRF key and generates a context credential nullifier with a VRF parameterized by the key and input the context string. 
    The complexity lies in efficiently proving in zero knowledge this nullifier was correctly derived from the committed key present in a valid, unrevoked master credential. This construction enables strong sybil resistance while maintaining unlinkability between presentations.

    \item \textbf{Efficient Multi-Credential Proofs and Revocation} enabling efficient proofs over multiple credentials while ensuring practical revocation. Our construction leverages Sigma protocols and Pedersen commitments, which, although they scale linearly with the credential attributes, they are extremely efficient in practice and support the most expressive statements. We integrate existing efficient revocation mechanisms that support batch non-membership proofs, allowing multiple credentials to be efficiently verified simultaneously while maintaining anonymity through zero-knowledge proof protocols. 

\end{enumerate}


\subsubsection{Comparison}


\begin{table}
\begin{center}
\caption{Comparison of our construction over previous work.}
\label{tab:comparison}
\begin{tabular}{l|cccccc}
Features    									& Multi Issuer & Sybil Resistance  & Revocation & Efficient Cred. Chaining$\footnotemark[1]$ & M-ABC$\footnotemark[2]$   & Anonymity$\footnotemark[3]$   \\
\hline

CanDID \cite{maram2021candid}     				& \ding{51}     & \ding{51} 	& \ding{51}  &  \ding{55}     & \ding{55}                     & \ding{55}		\\
SyRA \cite{crites_syra_2024}     				& \ding{55}     & \ding{51}    	& \ding{55}  &  \ding{55}     & \ding{55}                     & \ding{51}		\\
S3ID \cite{rabaninejad_attribute-based_nodate}  & \ding{51}     & \ding{51}    	& \ding{55}  &  \ding{51}     & \ding{55}\footnotemark[4]     & \ding{51}		\\
Our Work  										& \ding{51}     & \ding{51}    	& \ding{51}  &  \ding{51}     & \ding{51}                     & \ding{51}		\\
\end{tabular}
\end{center}

\vspace{1em}
\footnotesize
$\footnotemark[1]$ Credential Chaining is a user presenting multiple credentials to be verified together for a complex identity statement.

\footnotesize
$\footnotemark[2]$ M-ABC is a Multi-Show Attribute Based Credential, allowing a user to satisfy rich, attribute-based identity statements 

\footnotesize
$\footnotemark[3]$ Anonymity is defined in the Anonymous Credential model, no verifier and issuer (collaborating together) may learn more about the user or their credentials other than what the user discloses and what their credentials verify. Multiple credential verifications are unlinkable.

\footnotesize
$\footnotemark[4]$ While possible in S3ID, they mention 

\footnotesize
$\footnotemark[5]$ Multi-issuer means supporting credentials from different authorities that can be cryptographically linked while preserving privacy
\end{table}

\todonote{S3ID is inefficient for attribute-based verification, this table doesn't show that}















% % % % % % % % % % 
% 
% PRELIMINARIES
% 
% % % % % % % % % % 



\section{Preliminaries}\label{sec:preliminaries}
\subsection{Notation}
Let $\N$ is the set of positive integers $\{1,2,3,\ldots\}$. If $x$ is a string, then $|x|$ is its length, if $S$ is a set, $|S|$ denotes its size. If $\lambda \in \N$, then $\secparam$ denotes the string of $\lambda$ ones. If $n$ is an integer, then $[n] = \{1, \ldots,n\}.$ If $S$ is a set, then $s \sample S$ denotes the operation of picking an element $s$ of $S$ uniformly at random. $\$$ denotes randomized algorithm output. We use $z \gets A()$ and $z = A()$ interchangably for deterministic assignment where $z$ is the output of a deterministic algorithm $A$ and $z \gets A(x,y,\ldots)$ is the output of a deterministic algorithm with inputs $x,y,\ldots$ when the set, sum, or product has a single index. 
The notation $\vect{x}$ is used to denote the vector $(x_0, \ldots,x_n)$ or $(x_1, \ldots, x_n)$ where $n$ and choice of $0, 1$ will be clear from the context.

% notation from Algebraic MAC's
The notation $\{x_i\}_1^n, \sum_1^n x_i, \prod_1^n x_i$ are shorthand for $\{x_i\}_{i=1}^n, \sum_{i=1}^n x_i$ and $\prod_{i=1}^n x_i$ respectively. 

% maybe need to rewrite
We write $A(x,y,\ldots : \oracle_1, \oracle_2, \ldots)$ as an algorithm taking $(x,y,\ldots)$ as input with access to oracles $(\oracle_1, \oracle_2, \ldots)$ and $z \sample A(x,y,\ldots : \oracle_1, \oracle_2, \ldots)$ as the assignment of the output of $A$ to $z$. We denote the adversary algorithm as $\AdvA$

We write commitments using 1-base indexing. $\cm_m[1]$ represents the message at the first position of the $\cm_m$ commitment, that is, in a commitment $\cm_m = CM.Com([s,k,\ldots];r)$, algebraically, the commitment is $g_1^sg_2^k\ldots h^r$ where $s$ is the first position.


Use this to update mine
\cite{hutchison_get_2010} has good preliminaries
% We let {0, 1}∗ and {0, 1}t denote the set of binary strings of arbitrary length and length t respectively, and let ε denote the empty string. If A is an algorithm, we denote the action of obtaining x by invoking A on inputs y1, . . . , yn by x ← A(y1, . . . , yn), where the probability distribution on x is determined by the internal coin tosses of A.
% We denote an interactive protocol P as P = (P0, P1). Executing the protocol on input in0 and in1, resulting in the respective output out0 and out1, we write as 〈out0; out1〉 ← 〈P0(in0); P1(in1)〉. If arr is an array or list we let arr[i] denote the ith element in the array/list.

$\Z_p^*, \G_1^*$ - the star (*) represents the exclusion of trivial elements. That is, $\Z_p^*$ excludes 0, focusing on invertible (coprime with $p$) elements under multiplication mod $p$ where $|\Z_p^*| = p-1$ and sampling $y \sample \Z_p^*$ selects an integer from $[1, p-1]$ uniformly. $\Z_p$ is the additive group mod $p$, size = $|\Z_p| = p$, sampling $\y \sample \Z_p$ samples uniformly from $[0, p-1]$

$\G_1^*$ excludes the elliptic curve identity element $\{\mathcal{O}\}$ required for discrete log operations as any elliptic curve operation with the identity element results in the identity element. 

For a probabilistic algorithm $A$, we write $x \leftarrow A(y_1,\ldots,y_n)$ to denote sampling $x$ according to the distribution induced by $A$'s random coins on inputs $y_1,\ldots,y_n$. 

For an interactive protocol $P = (P_0, P_1)$ with inputs $in_0, in_1$ and outputs $out_0, out_1$, we write $\langle out_0; out_1 \rangle \leftarrow \langle P_0(in_0); P_1(in_1) \rangle$ to denote protocol execution.

For an array $\mathsf{arr}$, we denote its $i$th element by $\mathsf{arr}[i]$.


\begin{definition}[Bilinear map]
Let $\G_1$, $\G_2$ and $\G_T$ be cyclic groups of prime order $p$, where $\G_1$ and $\G_2$ are additive and $\G_T$ is multiplicative. Let $g$ and $\tilde{g}$ be generators of $\G_1$ and $\G_2$, respectively. We call $e: \G_1 \times \G_2 \rightarrow \G_T$ a bilinear map or pairing if it is efficiently computable and the following holds:
\begin{itemize}
    \item \textbf{Bilinearity:} $e(g^a, \tilde{g}^b) = e(g, \tilde{g})^{ab} = e(g^b, \tilde{g}^a)$ $\forall a,b \in \mathbb{Z}_p$.
    \item \textbf{Non-degeneracy:} $e(g, \tilde{g}) \neq 1_{\G_T}$, i.e., $e(g, \tilde{g})$ generates $\G_T$.
\end{itemize}

\noindent If $\G_1 = \G_2$, then $e$ is symmetric (Type-1) and asymmetric (Type-2 or 3) otherwise. For Type-2 pairings, there is an efficiently computable isomorphism $\Psi: \G_2 \rightarrow \G_1$ but none from $\G_1 \rightarrow \G_2$; for Type-3 pairings, no efficiently computable isomorphisms between $\G_1$ and $\G_2$ are known. In practice, we use Type-3 pairings as they provide the best balance between security and efficiency at standard security levels.
\end{definition}


\begin{definition}[Bilinear Group Generator]
A bilinear group generator $\mathsf{BGGen}$ is a probabilistic polynomial-time algorithm that on input security parameter $1^\lambda$, outputs a tuple $\mathsf{BG} = (p, \G_1, \G_2, \G_T, e, g, \tilde{g})$ where:
\begin{itemize}
    \item $p$ is a prime of bit-length $\lambda$
    \item $(\G_1, \G_2, \G_T)$ are cyclic groups of order $p$
    \item $g$ and $\tilde{g}$ are generators of $\G_1$ and $\G_2$ respectively
    \item $e: \G_1 \times \G_2 \rightarrow \G_T$ is a non-degenerate bilinear map
\end{itemize}
\end{definition}

\begin{definition}[Discrete Logarithm in Bilinear Groups]
For a bilinear group generator $\BGGen$, we say the discrete logarithm assumption holds if for all PPT adversaries $\mathcal{A}$, there exists a negligible function $\negl$ such that:
$$\Pr\left[\begin{array}{l}
    \BG = (p, \G_1, \G_2, \G_T, e, g, \tilde{g}) \sample \BGGen(1^\lambda) \\
    a \sample \Z_p \\
    a' \sample \mathcal{A}(\BG, g^a)
\end{array} : a' = a\right] \leq \negl$$
The assumption is analogously defined for $\G_2$ using $\tilde{g}^a$.
\end{definition}



\begin{definition}[LRSW Assumption in Bilinear Groups]
For any PPT adversary $\mathcal{A}$, we say the LRSW assumption holds if there exists a negligible function $\negl$ such that:
$$\Pr\left[\begin{array}{l}
    \BG = (p, \G_1, \G_2, \G_T, e, g, \tilde{g}) \sample \BGGen(1^\lambda) \\
    x,y \sample \Z_p, X \gets g^x, \tilde{Y} \gets \tilde{g}^y \\
    (m^*, A, B, C) \sample \mathcal{A}^{\mathcal{O}_{x,y}}(\BG, X, \tilde{Y})
\end{array} : \begin{array}{l}
    m^* \notin Q \quad \land \quad \exists r \in \Z_p :\\
    A = g^r \land B = A^y \land C = A^{x+m^*xy}
\end{array}\right] \leq \negl(\lambda)$$
where $Q$ is the set of queries made to $\mathcal{O}_{x,y}$ with access to $x,y$ is defined by:
\[
\text{Oracle }\mathcal{O}_{x,y}(m): \text{ Samples } r \sample \Z_p, \text{ Returns } (g^r, (g^r)^y, (g^r)^{x+mxy})
\]
\end{definition}


\begin{definition}[PS-LRSW Assumption in Bilinear Groups]
For any PPT adversary $\mathcal{A}$, we say the PS-LRSW assumption holds if there exists a negligible function $\negl$ such that:
$$\Pr\left[\begin{array}{l}
    \BG = (p, \G_1, \G_2, \G_T, e, g, \tilde{g}) \sample \BGGen(1^\lambda) \\
    x,y \sample \Z_p, X \gets g^x, Y \gets g^y \\
    \tilde{X} \gets \tilde{g}^x, \tilde{Y} \gets \tilde{g}^y \\
    (m^*, P_1, P_2) \sample \mathcal{A}^{\mathcal{O}_{x,y}}(\BG, X, Y, \tilde{X}, \tilde{Y})
\end{array} : \begin{array}{l}
    m^* \notin Q \land P_1 \neq 1_{\G_1} \land \\
    e(P_1, \tilde{X} \cdot \tilde{Y}^{m^*}) = e(P_2, \tilde{g})
\end{array}\right] \leq \negl$$
where $Q$ is the set of queries made to $\mathcal{O}_{x,y}$ with access to $x,y$ is defined by:
\[
\text{Oracle }\mathcal{O}_{x,y}(m): \text{ Samples } h \sample \G_1, \text{ Returns the pair }P = (h, h^{x+my})
\]
\end{definition}



\begin{definition}[Type-3 PS-LRSW Assumption]
For any PPT adversary $\mathcal{A}$, we say the Type-3 PS-LRSW assumption holds in the generic bilinear group model if there exists a negligible function $\negl$ such that:
$$\Pr\left[\begin{array}{l}
    \BG = (p, \G_1, \G_2, \G_T, e, g, \tilde{g}) \sample \BGGen(1^\lambda) \\
    x,y \sample \Z_p, X \gets g^x, \tilde{Y} \gets \tilde{g}^y \\
    (m^*, P_1, P_2) \sample \mathcal{A}^{\mathcal{O}_{x,y}}(\BG, X, \tilde{Y})
\end{array} : \begin{array}{l}
    m^* \notin Q \land P_1 \neq 1_{\G_1} \land \\
    e(P_1, \tilde{X} \cdot \tilde{Y}^{m^*}) = e(P_2, \tilde{g})
\end{array}\right] \leq \negl$$
where $Q$ is the set of queries made to $\mathcal{O}_{x,y}$ with access to $x,y$ is defined by:
\[
\text{Oracle }\mathcal{O}_{x,y}(m): \text{ Samples } h \sample \G_1, \text{ Returns the pair } P = (h, h^{x+my})
\]

\noindent Furthermore, in the generic group model after $q$ oracle queries and $q_G$ group-oracle queries, the probability of success is bounded by $\mathcal{O}((q + q_G)^2/p)$.
\end{definition}



\begin{definition}[XDDH/SXDH Assumption in Bilinear Groups]
For any PPT adversary $\mathcal{A}$, we say the XDDH assumption holds in $\G_i$ ($i \in \{1,2\}$) if there exists a negligible function $\negl$ such that:
$$\left|\Pr\left[\begin{array}{l}
    \BG = (p, \G_1, \G_2, \G_T, e, g, \tilde{g}) \sample \BGGen(1^\lambda) \\
    a, b \sample \Z_p, c \gets ab \bmod p \\
    d \sample \mathcal{A}(\BG, g_i^a, g_i^b, g_i^c)
\end{array}\right] - 
\Pr\left[\begin{array}{l}
    \BG = (p, \G_1, \G_2, \G_T, e, g, \tilde{g}) \sample \BGGen(1^\lambda) \\
    a, b, r \sample \Z_p \\
    d \sample \mathcal{A}(\BG, g_i^a, g_i^b, g_i^r)
\end{array}\right]\right| \leq \negl$$
where $g_i$ is the generator of $\G_i$. The SXDH assumption holds if XDDH holds in both $\G_1$ and $\G_2$.
\end{definition}




\begin{definition}[Symmetric Discrete Logarithm Assumption (SDLP)]\label{sdlp}
For any PPT adversary $\mathcal{A}$, we say the SDLP assumption holds if there exists a negligible function $\negl$ such that:
$$\Pr\left[\begin{array}{l}
    \BG = (p, \G_1, \G_2, \G_T, e, g, \tilde{g}) \sample \BGGen(1^\lambda) \\
    x \sample \Z_p \\
    x' \sample \mathcal{A}(\BG, g^x, \tilde{g}^x)
\end{array} : x = x'\right] \leq \negl$$
where validity of input can be verified by checking $e(g, \tilde{g}^x) = e(g^x, \tilde{g})$.
\end{definition}



Assumptions from here - as discussed by UTT paper commitment instantiation
The binding property holds under the SDL assumption of \cite{hutchison_get_2010}
which follows from 1-SDH of \cite{boneh_short_2008}. (See Section I for details.) 






\subsection{Digital Signatures}

\begin{definition}[Signature Scheme]
A signature scheme $\mathsf{Sig}$ is a tuple of probabilistic polynomial-time algorithms $(\mathsf{KeyGen}, \mathsf{Sign}, \mathsf{Verify})$ where:

\begin{itemize}
    \item $\mathsf{KeyGen}(1^\lambda) \rightarrow (\mathsf{sk}, \mathsf{pk})$: is a probabilistic algorithm that takes as input a security parameter $\lambda$ and outputs a secret signing key $\mathsf{sk}$ and a public verification key $\mathsf{pk}$. The message space $\mathcal{M}$ is implicitly defined by $\mathsf{pk}$.
    
    \item $\mathsf{Sign}(\mathsf{sk}, m; r) \rightarrow \sigma$: is a probabilistic algorithm that takes as input the secret key $\mathsf{sk}$, a message $m \in \mathcal{M}$, and random coins $r$ sampled from the randomness space $\mathcal{R}$. It outputs a signature $\sigma$.
    
    \item $\mathsf{Verify}(\mathsf{pk}, m, \sigma) \rightarrow b$: is a deterministic algorithm that takes as input the public key $\mathsf{pk}$, a message $m \in \mathcal{M}$, and a signature $\sigma$. It outputs a bit $b \in \{0,1\}$, where 1 indicates acceptance and 0 indicates rejection.
\end{itemize}

The scheme must satisfy the following correctness property:
For all $\lambda \in \mathbb{N}$, all $(\mathsf{sk}, \mathsf{pk}) \leftarrow \mathsf{KeyGen}(1^\lambda)$, all messages $m \in \mathcal{M}$, and all random coins $r \in \mathcal{R}$:

$$\Pr[\mathsf{Verify}(\mathsf{pk}, m, \mathsf{Sign}(\mathsf{sk}, m; r)) = 1] = 1$$

\end{definition}

\begin{definition}[Correctness]
A signature scheme $(\mathsf{KeyGen}, \mathsf{Sign}, \mathsf{Verify})$ is correct if for all $k \in \mathbb{N}$, all key pairs $(\mathsf{sk}, \mathsf{pk}) \in [\mathsf{KeyGen}(1^k)]$ and all $m \in \mathcal{M}$ we have:

$$\Pr[\mathsf{Verify}(m, \mathsf{Sign}(m, \mathsf{sk}), \mathsf{pk}) = 1] = 1.$$
\end{definition}

\begin{definition}[EUF-CMA Security]
A signature scheme $(\mathsf{KeyGen}, \mathsf{Sign}, \mathsf{Verify})$ is existentially unforgeable under adaptive chosen-message attacks if for all PPT algorithms $\mathcal{A}$, there exists a negligible function $\negl$ such that:
$$\Pr\left[\begin{array}{l}
    (\mathsf{sk}, \mathsf{pk}) \sample \mathsf{KeyGen}(1^\lambda) \\
    (m^*, \sigma^*) \sample \mathcal{A}^{\mathcal{O}_{\mathsf{sk}}}(\mathsf{pk})
\end{array} : \begin{array}{l}
    m^* \notin Q \land \\
    \mathsf{Verify}(m^*, \sigma^*, \mathsf{pk}) = 1
\end{array}\right] \leq \negl$$
where $Q$ is the set of queries made to $\mathcal{O}_{\mathsf{sk}}$ with access to $\mathsf{sk}$ is defined by:
\[
\text{Oracle }\mathcal{O}_{\mathsf{sk}}(m): \text{ Returns } \sigma \gets \mathsf{Sign}(m, \mathsf{sk})
\]
\end{definition}





% % % % % % % % % % 
% 
% END PRELIMINARIES
% 
% % % % % % % % % % 


























% % % % % % % % % % 
% 
% Randomizable Vector Commitments
% 
% % % % % % % % % % 


\newpage
\section{Symmetric Rerandomizable Vector Commitments}\label{sec:commitment}
We now introduce a specialized Pedersen commitment scheme from \cite{tomescu2022utt} and prove tight security as the building block for our anonymous credential system. Our construction extends the classical Pedersen Commitment scheme with three properties that are required for our multi-issuer, multi-credential setting construction:
\begin{enumerate}
    \item \textbf{Position Binding: } we need to commit to a vector of attributes $\{m_1, \ldots, m_n\}$ while ensuring the individual positions within the commitment remain binding. Position binding is useful when proving relations about specific committed attributes across multiple credentials. 
    
    \item \textbf{Symmetric across bilinear groups: } in order to support our pairing-based signatures and efficient zero-knowledge proofs, we require commitments to be represented and verified in both $\G_1, \G_2$ curve groups. 
    
    \item \textbf{Rerandomization: } we need the ability to rerandomize commitments while preserving their structure which supports unlinkability in credential presentations
\end{enumerate}

\noindent Furthermore, our scheme often leverages Pedersen Commitments homomorphic properties, allowing us to combine multiple commitments with group operations. This enables us to bind credential attributes and hide secrets while maintaining privacy. 

\subsubsection{Definition}

\begin{definition}[Rerandomizable Vector Commitment scheme] 
    A rerandomizable vector commitment scheme $\mathsf{RVC}$ is a tuple $(\mathsf{Setup}, \mathsf{Commit}, \mathsf{Open}, \mathsf{Rerand})$ of PPT algorithms where:
    
    \begin{itemize}
        \item $\mathsf{Setup}(1^\lambda, 1^n) \to \mathsf{ck}$ probabilistic algorithm that takes as input the security parameter $\lambda$ and vector length $n$ both in unary. It outputs the commitment key $\mathsf{ck}$ of length $n$
        
        \item $\mathsf{Commit}(\mathsf{ck}, \vect{m}) \to (\cm, r)$: probabilistic algorithm takes as input the commitment key $\mathsf{ck}$ and message vector $\vect{m} \in \mathcal{M}^n$ . Outputs the commitment $\cm$ and opening key $r$

        \item $\mathsf{Open}(\mathsf{ck, cm}, \vec{m}, r) \to \bit$: deterministic algorithm, takes as input the commitment key $\mathsf{ck}$, commitment $\mathsf{cm}$, messages $\vec{m}$ and randomness $r$, outputs 1 if success, 0 for failure

        \item $\mathsf{Rerand}(\mathsf{ck, cm}) \to (cm', r')$: probabilistic algorithm, takes as input the commitment key $\mathsf{ck}$, commitment $\mathsf{cm}$ outputs randomized commitment $\cm'$ and new randomness $r'$. 
        
    \end{itemize}
\end{definition}

\noindent A rerandomizable vector commitment scheme is secure if it's correct, hiding, binding, position binding, rerandomizable, and symmetric group correct. We use standard definitions for correctness, hiding, and binding.


\begin{definition}[Correctness] A rerandomizable vector commitment scheme $\mathsf{RVC}$ is correct if for all $n \in \N$ and all $\vec{m} \in \mathcal{M}^n$:
        \[
        \Pr
            \left [
                \begin{array}{l}
                    \mathsf{ck} \gets \mathsf{Setup}(1^\lambda, 1^n) \\
                    (\cm, r) \gets \mathsf{Commit}(\mathsf{ck}, \vec{m}) \\
                \end{array}
                : 1 \gets \mathsf{Open}(\mathsf{ck}, \cm, \vec{m}, r)
            \right ] = 1
    \]
\end{definition}


\begin{definition}[Perfect Hiding] A rerandomizable vector commitment scheme $\mathsf{RVC}$ is perfectly hiding if for all (unbounded) adversaries $\AdvA$ and all message vectors $\vec{m}_0, \vec{m}_1$ of equal length:
\[
    \Pr
        \left [
            \begin{array}{l}
                \mathsf{ck} \gets \mathsf{Setup}(1^\lambda, 1^n) \\
                (\vec{m}_0, \vec{m}_1) \gets \mathcal{A}(\mathsf{ck}) \\
                b \sample \bit \\
                (\cm_b, r_b) \gets \mathsf{Commit}(\mathsf{ck}, \vec{m}_b) \\
                b' \gets \AdvA(\mathsf{ck}, \cm_b) \\
            \end{array}
            : b' = b
        \right ]
        = \frac{1}{2}
\]
\end{definition}


\begin{definition}[Binding] A rerandomizable vector commitment scheme $\mathsf{RVC}$ is binding if for all $\PPT$ adversaries $\AdvA$ and all message vectors $\vec{m}_0, \vec{m}_1$ of equal length, there is a negligible function $\negl$ such that:
    \[
        \Pr
        \left [
            \begin{array}{l}
            \mathsf{ck} \gets \mathsf{Setup}(1^\lambda, 1^n) \\
            (\vec{m}_0, \vec{m}_1, r_0, r_1) \gets \AdvA(\mathsf{ck}) \\
            \cm_0 \gets \mathcal{A}(\mathsf{CM.Com}(\ck, \vec{m}_0, r_0)) \\
            b_0 \gets \mathsf{Open}(\mathsf{ck}, \cm, \vec{m}_0, r_0) \\
            b_1 \gets \mathsf{Open}(\mathsf{ck}, \cm, \vec{m}_1, r_1) \\
            \end{array}
            \quad : \quad  b_0 = b_1 = 1 \quad \land \quad  \vec{m}_0 \neq  \vec{m}_1
        \right ] \leq \negl
    \]
Informally, No adversary $\AdvA$ should be able to open a commitment to two different messages, even when allowed to use different randomness values. This captures the "unforgeability" aspect of commitments. 
\end{definition}


\begin{definition}[Position Binding]
A rerandomizable vector commitment scheme $\mathsf{RVC}$ is position binding if for all $\PPT$ adversaries $\AdvA$ and where $\vec{m}_0, \vec{m}_1$ are vectors that differ only at position $i$, there is a negligible function $\negl$ such that:
\[
    \Pr
    \left[
        \begin{array}{l}
        \mathsf{ck} \sample \mathsf{Setup}(1^\lambda, 1^n) \\
        (\cm, i, \vec{m}_0, \vec{m}_1, r_0, r_1) \sample \mathcal{A}(\mathsf{ck}) \\
        \mathsf{Open}(\ck, \cm, \vec{m}_0, r_0, i) = 1 \\
        \mathsf{Open}(\ck, \cm, \vec{m}_1, r_1, i) = 1 \\
        \end{array}
        : \begin{array}{l}
            \vec{m}_0 \neq \vec{m}_1 \quad \wedge\\
            \vec{m}_0[j] = \vec{m}_1[j] \; \forall \; j \neq i \\
          \end{array}
    \right] \leq \negl
\]
Informally, this states that an adversary $\AdvA$ should not be able to open a commitment $\cm$ to index $i$ unless both commitments use the same message, even when the commitments only differ by position $i$
\end{definition}





\begin{definition}[Symmetric Group Correctness]
A rerandomizable vector commitment scheme $\mathsf{RVC}$ satisfies symmetric group correctness if for all $n \in \mathbb{N}$ and all $\vec{m} \in \mathcal{M}^n$:
  \[
        \Pr\left[
        \begin{array}{l}
            \mathsf{ck} \sample \mathsf{Setup}(1^\lambda, 1^n) \\
            (\cm, \widehat{\cm}, r) \sample \mathsf{Commit}(\mathsf{ck}, \vec{m})
        \end{array}
        : e(\cm, \widehat{g}) = e(g, \widehat{cm})
        \right] = 1
    \]
    \[
        \Pr\left[
        \begin{array}{l}
            (\cm', \widehat{\cm'}, r') \sample \mathsf{Rerand}(\mathsf{ck}, \cm, \widehat{\cm}, r)
        \end{array}
        : e(\cm', \widehat{g}) = e(g, \widehat{\cm'})
        \right] = 1
    \]
\noindent where $g, \widehat{g}$ are the generators specified in $\mathsf{ck}$ for $\G_1, \G_2$ respectively.
\end{definition}




\begin{definition}[Additive Homomorphism]
A rerandomizable vector commitment scheme $\mathsf{RVC}$ is additively homomorphic if for all $\vec{m}_1, \vec{m}_2 \in \mathcal{M}^n$ and randomness $r_1, r_2 \in \Z_p$:
\[
    \Pr\left[
    \begin{array}{l}
        \mathsf{ck} \sample \mathsf{Setup}(1^\lambda, 1^n) \\
        (\cm_1, r_1) \sample \mathsf{Commit}(\mathsf{ck}, \vec{m}_1) \\
        (\cm_2, r_2) \sample \mathsf{Commit}(\mathsf{ck}, \vec{m}_2)
    \end{array}
    : \cm_1 \cdot \cm_2 = \mathsf{Commit}(\mathsf{ck}, \vec{m}_1 + \vec{m}_2, r_1 + r_2)
    \right] = 1
\]

\noindent Furthermore, for symmetric group correctness, the homomorphism must hold across groups:
\[
    e(\cm_1 \cdot \cm_2, \widehat{g}) = e(g, \widehat{\cm_1} \cdot \widehat{\cm_2})
\]
\end{definition}

% The homomorphic operation is the standard component-wise addition over Zp, and therefore one can add a value to a single entry without changing the other entries (by adding zeroes in all other locations). From UTT


\subsection{Construction}
We instantiate a dual-group Pedersen Vector Commitment scheme with groups $\G_1, \G_2$ to enable efficient verification within our signature construction. For commitments $\cm \in \G_1, \widetilde{\cm} \in \G_2$, we verify consistency via the pairing relation $e(\cm, \tilde{g}) = e(g, \widetilde{\cm})$.

Let $\G_1, \G_2$ be cyclic groups of prime order $p$ with an efficient Type-3 pairing $e: \G_1 \times \G_2 \to \G_T$. For message vector $\vec{m} = (m_1, \ldots, m_\ell) \in \Z_p^\ell$, our rerandomizable commitment scheme consists of the following algorithms:

\begin{itemize}
    \item $\mathsf{CM.Setup}(\secparam, \ell) \to \ck$:
    Sample generators $(g, \tilde{g}) \sample \G_1 \times \G_2$
    For $i \in [1,\ell]$: Sample $y_i \sample \Z_p$, compute $(g_i, \tilde{g}_i) \gets (g^{y_i}, \tilde{g}^{y_i})$
    Return $\ck \gets (g, (g_1,\ldots,g_\ell), \tilde{g}, (\tilde{g}_1,\ldots,\tilde{g}_\ell))$
    
    \item $\mathsf{CM.Com}(\ck, \vec{m}) \to (\cm, \widetilde{\cm}, r)$:
    Parse $\ck$ as $(g, (g_1,\ldots,g_\ell), \tilde{g}, (\tilde{g}_1,\ldots,\tilde{g}_\ell))$
    Sample $r \sample \Z_p$
    Compute $\cm \gets g^r \prod_{i=1}^\ell g_i^{m_i}$ and $\widetilde{\cm} \gets \tilde{g}^r \prod_{i=1}^\ell \tilde{g}_i^{m_i}$
    Return $(\cm, \widetilde{\cm}, r)$
    
    \item $\mathsf{CM.Rerand}(\ck, \cm, \widetilde{\cm}, r_\Delta) \to (\cm', \widetilde{\cm'})$:
    Parse $\ck$ as $(g, \cdot, \tilde{g}, \cdot)$
    Compute $\cm' \gets \cm \cdot g^{r_\Delta}$ and $\widetilde{\cm'} \gets \widetilde{\cm} \cdot \tilde{g}^{r_\Delta}$
    Return $(\cm', \widetilde{\cm'})$

    \item $\mathsf{CM.Open}$
\end{itemize}

\paragraph{Homomorphic Properties}
The scheme inherits the additive homomorphic properties of Pedersen commitments:

\begin{itemize}
    \item \textbf{Rerandomization:} For commitment $\cm = g^r\prod_{i=1}^\ell g_i^{m_i}$ and fresh randomness $r_\Delta \sample \Z_p$, the rerandomized commitment $\cm' = \cm \cdot g^{r_\Delta} = g^{r+r_\Delta}\prod_{i=1}^\ell g_i^{m_i}$ preserves the message vector while updating the randomness from $r$ to $r + r_\Delta$. By the DDH assumption in $\G_1$, $\cm'$ is computationally indistinguishable from $\cm$.
    
    \item \textbf{Two-Party Protocol:} For joint randomness generation:
    \begin{enumerate}
        \item User samples $s_1, r \sample \Z_p$ and commits: $\cm_1 \gets g^r g_1^{s_1}$
        \item Authority samples $s_2 \sample \Z_p$ and computes: $\cm_2 \gets \cm_1 \cdot g_1^{s_2} = g^r g_1^{s_1 + s_2}$
        \item Authority returns $(\cm_2, s_2)$, establishing shared secret $s_1 + s_2$
    \end{enumerate}
    
    Security holds bidirectionally:
    \begin{itemize}
        \item \textbf{Unforgeability:} Computational binding under DL prevents malicious users from changing $s_1$ post-commitment
        \item \textbf{Anonymity:} Perfect hiding of $\cm_1$ ensures zero knowledge of $s_1$ against malicious issuers
    \end{itemize}
\end{itemize}

\subsection{Security of our Construction}



% 
% 
% 
% 
% Proof in the AGM
% 
% 



\begin{theorem}
    In the Algebraic Group Model, if the Symmetric Discrete Logarithm Problem (SDLP) is hard in the bilinear group $\mathbb{G}$, then our RVC scheme satisfies position binding. Specifically, for any algebraic PPT adversary $\mathcal{A}$ against position binding, there exists a PPT reduction $\mathcal{B}$ against SDLP such that:
    \[
        \mathsf{Adv}^{\mathsf{pos\text{-}bind}}_{\mathcal{A},\mathsf{RVC}}(\lambda) \leq \ell \cdot \mathsf{Adv}^{\mathsf{SDLP}}_{\mathcal{B},\mathbb{G}}(\lambda)
    \]
    where $\ell$ is the vector length.
\end{theorem}

\begin{proof}
We prove via reduction in the AGM. Given an algebraic PPT adversary $\mathcal{A}$ that breaks position binding with non-negligible probability $\epsilon$, we construct a PPT algorithm $\mathcal{B}$ that solves SDLP with probability $\epsilon/\ell$. For clarity, we illustrate with $\ell = 3$; the proof generalizes naturally.

Algorithm $\mathcal{B}$ works as follows:
\begin{enumerate}
    \item \textbf{Setup}: On input SDLP instance $(g^x, \tilde{g}^x) \in \mathbb{G}_1 \times \mathbb{G}_2$, $\mathcal{B}$ proceeds to:
    \begin{enumerate}
        \item Sample $i^* \sample [1,\ell]$ uniformly at random
        \item For position $i^*$: set $(g_{i^*}, \tilde{g}_{i^*}) \gets (g^x, \tilde{g}^x)$
        \item For positions $j \neq i^*$: sample $y_j \sample \mathbb{Z}_p$, set $(g_j, \tilde{g}_j) \gets (g^{y_j}, \tilde{g}^{y_j})$
        \item Give $\mathsf{ck} = ((g_1, g_2, g_3), (\tilde{g}_1, \tilde{g}_2, \tilde{g}_3))$ to $\mathcal{A}$
    \end{enumerate}
    
    \item \textbf{Position Binding Break}: Since $\mathcal{A}$ is algebraic, when it outputs $(\mathsf{cm}, i, \vec{m}_0, \vec{m}_1, r_0, r_1)$, it also provides the representation of $\mathsf{cm}$ in terms of the generators:
    \begin{itemize}
        \item $\mathsf{cm} \in \mathbb{G}_1$ with its algebraic representation
        \item $i \in [1,\ell]$ is the position where binding breaks
        \item $\vec{m}_0, \vec{m}_1 \in \mathbb{Z}_p^\ell$ differ only at position $i$
        \item $r_0, r_1 \in \mathbb{Z}_p$ are opening randomness values
    \end{itemize}
    
    \item \textbf{Extracting SDLP}: If $i \neq i^*$, abort. Otherwise:
    \begin{enumerate}
        \item By the algebraic property of $\mathcal{A}$, we have explicit representations of the commitment openings:
        \[
            g^{r_0}g_1^{m_{0,1}}g_2^{x \cdot m_{0,2}}g_3^{m_{0,3}} = g^{r_1}g_1^{m_{1,1}}g_2^{x \cdot m_{1,2}}g_3^{m_{1,3}}
        \]
        
        \item Since these representations are explicit in the AGM, we can directly compare exponents:
        \[
            r_0 + y_1m_{0,1} + xm_{0,2} + y_3m_{0,3} = r_1 + y_1m_{1,1} + xm_{1,2} + y_3m_{1,3}
        \]
        
        \item Since $\vec{m}_0$ and $\vec{m}_1$ differ only at position $i^*=2$, we have $m_{0,1}=m_{1,1}$ and $m_{0,3}=m_{1,3}$. Terms cancel:
        \[
            r_0 + xm_{0,2} = r_1 + xm_{1,2}
        \]
        
        \item Solve for $x$:
        \[
            x \equiv \frac{r_1-r_0}{m_{0,2}-m_{1,2}} \pmod{p}
        \]
        Note: Division is well-defined as $m_{0,2} \neq m_{1,2}$ by assumption.
    \end{enumerate}
\end{enumerate}

The reduction succeeds whenever $i = i^*$ and $\mathcal{A}$ succeeds, which occurs with probability $\epsilon/\ell$. This is non-negligible when $\epsilon$ is non-negligible, contradicting the SDLP assumption.
\end{proof}


\paragraph{Analysis:}
We analyze the reduction's properties in detail:
\begin{itemize}
    \item \textbf{Perfect Simulation:} The commitment key distribution is identical to the real scheme:
        \begin{itemize}
            \item At position $i^*$: $(g_{i^*}, \tilde{g}_{i^*}) = (g^x, \tilde{g}^x)$ is uniformly distributed in $\G_1 \times \G_2$ by the SDLP instance properties
            \item At positions $j \neq i^*$: $(g_j, \tilde{g}_j) = (g^{y_j}, \tilde{g}^{y_j})$ is uniform due to $y_j \sample \Z_p$
            \item Therefore, from $\mathcal{A}$'s view, $\mathsf{ck}$ is distributed identically to the real scheme
        \end{itemize}
    
    \item \textbf{Extraction Success:} $\mathcal{B}$ successfully extracts the SDLP solution when:
        \begin{itemize}
            \item $\mathcal{A}$ outputs a valid position binding break (occurs with probability $\epsilon$)
            \item The guessed position matches: $i = i^*$ (occurs with probability $1/\ell$)
            \item The extraction equation is solvable: $m_{0,i^*} \neq m_{1,i^*}$ (guaranteed by definition of position binding break)
        \end{itemize}
    
    \item \textbf{Advantage Analysis:} Combining these probabilities:
        \begin{itemize}
            \item Events are independent as $i^*$ is chosen before $\mathcal{A}$'s execution
            \item $\mathsf{Pr}[\mathcal{B} \text{ succeeds}] = \epsilon \cdot \frac{1}{\ell}$
            \item Therefore: $\mathsf{Adv}^{\mathsf{SDLP}}_{\mathcal{B},\G}(\lambda) \geq \frac{1}{\ell} \cdot \mathsf{Adv}^{\mathsf{pos\text{-}bind}}_{\mathcal{A},\mathsf{RVC}}(\lambda)$
        \end{itemize}
\end{itemize}

Thus, if $\mathcal{A}$ breaks position binding with non-negligible probability $\epsilon$, then $\mathcal{B}$ solves SDLP with non-negligible probability $\epsilon/\ell$, contradicting the SDLP hardness assumption in $\G$.





% % % % % % % % % % 
% 
% END Randomizable Vector Commitments
% 
% % % % % % % % % % 















% % % % % % % % % % 
% 
% PS Signature
% 
% % % % % % % % % % 
\newpage
\section{Rerandomizable Signature over Commitments}\label{sec:pssignature}
\subsubsection{Definition}
\begin{definition}[Rerandomizable Signature over Commitments]
    A rerandomizable signature scheme over commitments $\mathsf{RS}$ is a tuple $(\mathsf{KeyGen}, \mathsf{Sign}, \mathsf{Rerand}, \mathsf{Ver}, \mathsf{VerKey})$ of PPT algorithms where:
        \begin{itemize}
            \item $\mathsf{RS.KeyGen(pp, ck)} \to \mathsf{(sk, pk = (pp, vk, ck))}$ is a probabilistic algorithm that takes in the public parameters $\mathsf{pp}$ and commitment key $\mathsf{ck}$, outputs a signing key $\sk$, a public verification key $\vk$ and outputs $\mathsf{(sk, pk = (pp, vk, ck))}$

            \item $\mathsf{RS.Sign}(\mathsf{sk, cm};u ) \to \sigma$: probabilistic algorithm takes the signing key $\sk$, commitment $\cm$ from the commitment space $\mathcal{C}$ and random coins $u$ sampled from random space of the signature scheme. Output $\sigma$

            \item $\mathsf{RS.Rerand}(\pk, \sigma, r_\Delta, u_\Delta) \rightarrow \sigma'$ is a deterministic algorithm that enables signature rerandomization. Takes a public key $\pk = (\mathsf{ck,vk})$, a signature $\sigma$, and randomization elements $r_\Delta, u_\Delta$, as input, outputs a new signature $\sigma'$. 

            \item $\mathsf{RS.Ver}(\mathsf{pk = (pp, vk, ck), cm}, \sigma) \rightarrow \bit$: is a deterministic algorithm, takes as input the public key $\mathsf{pk}$, $\cm \in \mathcal{C}$ and signature $\sigma$, outputs 1 for successful verification, otherwise 0. 

            \item $\mathsf{RS.VerKey}(\mathsf{sk, pk = (pp, vk, ck)})$ 
        \end{itemize}
\end{definition}


\begin{definition}[$\mathsf{RS}$ Correctness] 
A rerandomizable signature scheme over commitments is correct if for all security parameters $\secparam$, for all $\ell > 1$, all bilinear groups $\mathsf{BG} = (p, \G_1, \G_2, \G_T, e, g, \tilde{g}) \in [\mathsf{BGGen}(\secparam)]$, all key pairs $(\sk, \pk) \in [\mathsf{KeyGen}(\mathsf{BG, 1^{\ell}})]$, all messages $m \in \mathcal{M}$, all commitments $\cm \in \mathcal{C}$, all commitment keys $\mathsf{ck} \in [\mathsf{CM.KeyGen}(\secparam)]$, and all randomness $r, u, r_\Delta, u_\Delta \in \Z_p$ we have:
    \begin{align*}
        &\mathsf{RS.VerKey}(\sk, \pk) = 1 \qquad \wedge \\
        &\Pr \left[ \mathsf{RS.Ver}(\pk, \left(\mathsf{RS.Sign}(\mathsf{sk}, \mathsf{CM.Com}(\mathsf{ck}, m, r), u)\right), m) = 1 \right] =1 \qquad \wedge \\
        &\Pr \left[ \mathsf{RS.Ver}(\pk, \mathsf{RS.Rerand}(\pk,\left(\mathsf{RS.Sign}(\mathsf{sk}, \mathsf{CM.Com}(\mathsf{ck}, m, r), u)\right),r_\Delta, u_\Delta), m) = 1 \right] =1 \qquad \wedge \\
        &\Pr \left[ \mathsf{RS.Ver}(\pk, \left(\mathsf{RS.Sign}(\mathsf{sk}, \mathsf{CM.Com}(\mathsf{ck}, m, r+r_\Delta), u+u_\Delta)\right), m) = 1 \right] = 1\\
    \end{align*}
\end{definition}



\begin{definition}$[\mathsf{RS}$ EUF-CCA]
A rerandomizable signature scheme over commitments is existentially unforgeable under adaptive chosen-commitment attacks if for all PPT adversaries $\mathcal{A}$, there exists a negligible function $\negl$ such that:
    \begin{align*}
        &\Pr\left[
            \begin{array}{l}
                \mathsf{BG} \gets \mathsf{BGGen}(1^{\secparam}), \\
                \mathsf{ck} \gets \mathsf{CM.KeyGen}(\mathsf{BG}), \\
                (\sk, \pk) \gets \mathsf{KeyGen}(\mathsf{BG}), \\
                (m^*, \cm^*, \sigma^*) \gets \mathcal{A}^{\mathsf{Sign}(\sk, \cdot)}(\pk) \\
                \end{array}
                \quad : \quad
                \begin{array}{l}
                \cm^* = \mathsf{CM.Com}(\mathsf{ck}, m^*, r^*) \land \\
                \mathsf{RS.Ver}(\pk, \sigma^*, m^*) = 1 \land \\
                \cm^* \notin Q_{\cm}
            \end{array}
        \right] \leq \negl
    \end{align*}
where $Q_{\cm}$ is the set of all commitments queried to the signing oracle
\end{definition}


\sam{need to do this for the anonymous credential section}
\begin{definition}[$\mathsf{RS}$ Signature Adaptation Under Malicious Keys]
A rerandomizable signature scheme $\mathsf{RS}$ satisfies \emph{signature adaptation under malicious keys} if for all tuples $(\pk, \cm, \sigma, r)$ where:
\begin{itemize}
    \item $\cm \in \mathcal{C}$ is a valid commitment,
    \item $\sigma$ is a valid signature under $\pk$ (i.e., $\mathsf{RS.Ver}(\pk, \cm, \sigma) = 1$),
    \item $r \in \Z_p^*$,
\end{itemize}
the distribution of $\mathsf{RS.Rerand}(\pk, \sigma, \mu)$ is identical to $\mathsf{RS.Sign}(\sk, \mathsf{CM.Rerand}(\ck, \cm, r))$, even when $\pk$ is adversarially generated.
\end{definition}




\subsubsection{Construction}
We assume the existence of a commitment key $\ck$ from $\mathsf{CM.Setup}$ as input into our rerandomizable signature scheme $\mathsf{RS}$. We copy the algorithm below for convenience.
\begin{itemize}
    \item $\mathsf{CM.Setup}(\secparam, \ell, (y_i, \ldots, y_{\ell} \in \Z_p^{\ell})) \to \ck:$  
    Sample $(g, \tilde{g}) \sample \G_1 \times \G_2$, For $i \in [1,\ell]$: Compute $g_i = g^{y_i}$ and $\tilde{g}_i = \tilde{g}^{y_i}$. Return $\ck \gets (g, (g_1,\ldots,g_\ell), \tilde{g}, (\tilde{g}_1,\ldots,\tilde{g}_\ell))$
    
    \item $\mathsf{RS.KeyGen}(\secparam, \ck) \to (\sk, \vk):$ 
        Retrieve $(g, \cdot, \tilde{g}, \cdot)$ from $\mathsf{ck}$,
        Sample $x \sample \Z_p$,
        Set $(\sk, \vk) \gets (g^x, \tilde{g}^x)$, return $(\sk, \vk))$
        % Return $(\mathsf{sk} = (x,g), \mathsf{pk} = (\mathsf{pp}, \mathsf{vk}, \mathsf{ck}))$
    
    \item $\mathsf{RS.Sign}(\mathsf{sk}, \mathsf{cm}; u) \to \sigma:$ 
        Let $h \gets g^u$
        Return $\sigma \gets (h, (\sk \cdot \mathsf{cm})^u)$
    
    \item $\mathsf{RS.Rerand}(\sigma, r_\Delta, u_\Delta) \to \sigma':$
        Parse $\sigma$ as $(\sigma_1, \sigma_2)$
        Set $\sigma_1' \gets \sigma_1^{u_\Delta}$
        Set $\sigma_2' \gets (\sigma_2 \cdot \sigma_1^{r_\Delta})^{u_\Delta}$
        Return $\sigma' \gets (\sigma_1', \sigma_2')$
    
    \item $\mathsf{RS.Ver}(\vk, \cm, \sigma) \to \bit:$
        Parse $\sigma$ as $(\sigma_1, \sigma_2)$, The prover $\Prover$ runs a Proof of Knowledge protocol with the following relation 
    \[
        \mathcal{R} \gets \mathsf{PoK}\{(m_1,\ldots,m_\ell, u \cdot u_\Delta, r \cdot r_\Delta): 
    \]
    \[
         e(\sigma_2', \tilde{g}) = e(\sigma_1', \vk)\cdot e(\sigma_1', \widehat{\cm}') \quad \wedge \quad
        e(\cm', \tilde{g}) = e(g, \widetilde{\cm}') \quad \wedge \quad
        \cm' = g^{r \cdot r_\Delta} \prod_{i=1}^\ell g_i^{m_i}
        \}
    \]

        \item $\mathsf{RS.VerKey}(\sk, \vk, \ck) \to \bit$
\end{itemize}


\subsubsection{Security of our Construction}
\begin{theorem}
    RS is correct
\end{theorem}
\begin{proof}
    First we demonstrate the provers rerandomized signature verifies with the verification key $\vk$ and the rerandomized commitment. Essentially, we need the following pairing to hold
    \[
          e(\sigma_2', \tilde{g}) = e(\sigma_1', \vk \cdot \widetilde{\cm'})
    \]

    We manipulate the bilinearity properties of the pairing groups to verify the initial pairing.
    
    \begin{align*}
        e(\sigma_2', \tilde{g}) &= e((\sk \cdot \cm)^{u \cdot u\Delta}\cdot h^{u_\Delta \cdot r_\Delta}, \tilde{g}) \\
        &= e(h^{x \cdot u_\Delta}\cdot \cm^{u \cdot u_\Delta} \cdot h^{u_\Delta \cdot r_\Delta}, \tilde{g}) \\
        &= e(h^{x \cdot u_\Delta}, \tilde{g}) \cdot e(\cm^{u \cdot u_\Delta}, \tilde{g}) \cdot e(h^{ u_\Delta \cdot r_\Delta}, \tilde{g}) \\
        &= e(h^{u_\Delta}, \tilde{g}^x) \cdot e(\cm, \tilde{g})^{u \cdot u_\Delta} \cdot e(h^{ u_\Delta}, \tilde{g})^{r_\Delta} \\
        &= e(\sigma_1', \vk) \cdot e(g^{u \cdot u_\Delta}, \widetilde{\cm}) \cdot e(\sigma_1', \tilde{g})^{r_\Delta} \\
        &= e(\sigma_1', \vk) \cdot e(\sigma_1', \widetilde{\cm}) \cdot e(\sigma_1', \tilde{g}^{r_\Delta}) \\
        &= e(\sigma_1', \vk \cdot \widetilde{\cm} \cdot \tilde{g}^{r_\Delta}) \\
        &= e(\sigma_1', \vk \cdot \widetilde{\cm'}) \\
    \end{align*}

    Secondly, we need to verify knowledge of messages within the commitment. The Prover used $\widetilde{\cm'} \in \G_2$ during verification and this would be the natural method to for a sigma style proof of knowledge protocol, proving knowledge of the attributes of the commitment with $\G_2$ bases. However, due to the properties of the symmetric bilinear commitment \ref{sdlp}, we can prove the equality of $\cm' \in \G_1$ and $\widetilde{\cm'} \in \G_2$ to reduce $\G_2$ computation on both the prover and verifier during verification. 
    Thus the prover computes 
    \[
        e(\cm', \tilde{g}) = e(g, \widetilde{\cm}')
    \]
    Then runs a sigma protocol to prove
    \[
    \cm' = g^{r \cdot r_\Delta} \prod_{i=1}^\ell g_i^{m_i}
    \]

\end{proof}






\begin{theorem}[EUF-CCA Security]
Assume the PS-LRSW assumption holds and the Pedersen commitment is computationally binding. Then, in the Algebraic Group Model, our rerandomizable signature scheme is existentially unforgeable under adaptive chosen-commitment attacks. For any algebraic PPT adversary $\mathcal{A}$, there exist PPT reductions $\mathcal{B}_0, \mathcal{B}_1$ such that:
\[
\Adv^{\mathsf{euf\mbox{-}cca}}_{\mathsf{RS},\mathcal{A}}(\lambda) \leq \Adv^{\mathsf{PS\mbox{-}LRSW}}_{\mathcal{B}_0}(\lambda) + \Adv^{\mathsf{Binding}}_{\mathcal{B}_1}(\lambda) + \frac{q_v + q_s}{p},
\]
where $q_v$ (verification) and $q_s$ (signing) are query counts.
\end{theorem}

\begin{proof}
We construct two reductions handling different forgery types. Let $\mathcal{A}$ be an adversary with advantage $\epsilon$.

\paragraph{1. Setup}
Given PS-LRSW challenge over bilinear groups $(g, \tilde{g}, X=g^x, \tilde{X}=\tilde{g}^x, Y=g^y, \tilde{Y}=\tilde{g}^y)$:
\begin{enumerate}
    \item \textbf{Commitment Setup:} For 2-slot Pedersen:
    \begin{itemize}
        \item Choose $\alpha_1, \alpha_2, \beta_1, \beta_2 \sample \Z_p$
        \item Set $g_1 = Y^{\alpha_1}g^{\beta_1}$, $\tilde{g}_1 = \tilde{Y}^{\alpha_1}\tilde{g}^{\beta_1}$ 
        \item Set $g_2 = Y^{\alpha_2}g^{\beta_2}$, $\tilde{g}_2 = \tilde{Y}^{\alpha_2}\tilde{g}^{\beta_2}$
    \end{itemize}
    \item \textbf{Public Key:} $\pk = (\tilde{X}, g_1, \tilde{g}_1, g_2, \tilde{g}_2)$
    \item Send $\pk$ to $\mathcal{A}$. Distribution matches real scheme as $\alpha_i, \beta_i$ are random.
\end{enumerate}


\paragraph{2. Oracle Simulation} \textbf{Signing Oracle:}
For query $(m_1, m_2, r)$:
\begin{itemize}
    \item \textbf{Case $\mathcal{B}_0$ (PS Reduction):}
    \begin{enumerate}
        \item Compute $m = \alpha_1m_1 + \alpha_2m_2$
        \item Query PS-LRSW oracle for $(h, h^{x + my})$
        \item Return $\sigma = (h, h^{x + my} \cdot h^{\beta_1m_1 + \beta_2m_2 + r})$
    \end{enumerate}
    \item \textbf{Case $\mathcal{B}_1$ (Binding Reduction):}
    \begin{enumerate}
        \item Compute $\mathsf{cm} = g_1^{m_1}g_2^{m_2}g^r$
        \item Choose $u \sample \Z_p$, return $\sigma = (g^u, (X \cdot \mathsf{cm})^u)$
    \end{enumerate}
\end{itemize}

\noindent \textbf{Verification Oracle:}

\begin{itemize}
    \item Parse $\sigma = (\sigma_1, \sigma_2)$
    \item Check $e(\sigma_2, \tilde{g}) = e(\sigma_1, \tilde{X} \cdot \widetilde{\mathsf{cm}})$ where $\widetilde{\mathsf{cm}} = \tilde{g}_1^{m_1}\tilde{g}_2^{m_2}\tilde{g}^r$
    \item Use AGM to extract exponents from $\sigma_1, \sigma_2$ if needed
\end{itemize}


\paragraph{3. Forgery Extraction}

When $\mathcal{A}$ outputs forgery $(m_1^*, m_2^*, r^*, \sigma^* = (\sigma_1^*, \sigma_2^*))$:

\noindent \textbf{Case 1: New Message Combination}
If $m^* = \alpha_1m_1^* + \alpha_2m_2^*$ is new:
\begin{itemize}
    \item $\mathcal{B}_0$ computes:
    \[
    (U, B/U^{\beta_1m_1^* + \beta_2m_2^* + r^*}) = (g^u, X^uY^{m^*u})
    \]
    \item This breaks PS-LRSW as $m^*$ wasn't queried. Thus:
    \[
    \epsilon_0 \geq \Pr[\text{New } m^*] - \frac{q_s}{p}
    \]
\end{itemize}

\noindent \textbf{Case 2: Commitment Collision}
If $m^*$ exists in prior query $(m_1, m_2) \neq (m_1^*, m_2^*)$:
\begin{itemize}
    \item $\mathcal{B}_1$ finds collision:
    \[
    g_1^{m_1}g_2^{m_2} = g_1^{m_1^*}g_2^{m_2^*}
    \]
    \item Solving gives DLOG relation for $\alpha_i, \beta_i$, breaking binding:
    \[
    \epsilon_1 \geq \Pr[\text{Collision}] - \frac{1}{p}
    \]
\end{itemize}

\noindent \paragraph{4. Analysis}

\begin{itemize}
    \item Total advantage partitions as $\epsilon \leq \epsilon_0 + \epsilon_1 + \frac{q_v + q_s + 1}{p}$
    \item The $\frac{1}{p}$ term accounts for coefficient collisions in setup
    \item Verification queries add $\frac{q_v}{p}$ error probability and
\end{itemize}
\[
\Adv^{\mathsf{euf\mbox{-}cca}}_{\mathcal{A}} \leq \Adv^{\mathsf{PS\mbox{-}LRSW}}_{\mathcal{B}_0} + \Adv^{\mathsf{Binding}}_{\mathcal{B}_1} + \frac{q_v + q_s}{p}
\]
\end{proof}








% % % % % % % % % % 
% 
% END PS Signature
% 
% % % % % % % % % % 



































% % % % % % % % % % 
% 
% MIMC-ABC Construction
% 
% % % % % % % % % % 




\cleardoublepage

\section{Multi Issuer Multi Credential Anonymous Credentials (MIMC-ABC)}\label{sec:mimc}

We base our Multi Issuer, Multi Credential Multi-show Attribute based Anonymous Credentials off the model in \cite{fuchsbauer_structure-preserving_2019}

\subsection{Syntax}
\begin{definition}[MIMC-ABC System] A Multi-Issuer Multi-Credential Attribute based Anonymous Credential system consists of the following $\PPT$ algorithms:
    \begin{itemize}
    \item $\mathsf{Setup}(\secparam) \to (\ppar)$ Takes security parameter $\lambda$ in unary, outputs public parameters $\ppar$.

    \item $\mathsf{OrgKeygen}(\ppar, n) \to (\osk, \opk)$: is a probabilistic algorithm that takes public parameters $\ppar$ and $n$ the upper bound of credential attributes. Outputs organisations keypair $(\osk, \opk)$
    
    \item $\mathsf{UserCommit}(\opk, \vec{m}) \rightarrow (\cm, r)$ is a probabilistic algorithm that takes as input the organization's public key $\opk$ and a vector of messages $\vec{m}$. It outputs a commitment $\cm$ and opening value $r$. The algorithm can be used to generate both master credential commitments $\cm_{\mathsf{m}}$ and context credential commitments $\cm_{\mathsf{ctx}}$.

    \item $(\mathsf{ObtainMaster}(\opk, \cm_{\mathsf{m}}, r, aux), \mathsf{IssueMaster}(osk, \cm_{\mathsf{m}}, aux)) \rightarrow (\mathsf{cred_m}, \bot)$ is an interactive protocol between a user and issuing organization. The user runs $\mathsf{ObtainMaster}$ with organization public key $\opk$, commitment $\cm_{\mathsf{m}}$, opening value $r$, and auxiliary information $aux$. The organization runs $\mathsf{IssueMaster}$ with issuing secret key $osk$, commitment $\cm_{\mathsf{m}}$, and auxiliary information $aux$. The protocol outputs a master credential $\mathsf{cred_m}$ to the user and $\bot$ to the issuer.


    \item $(\mathsf{ObtainContext}(\opk_m, \cm_{\mathsf{ctx}},\mathsf{cred_m}, r, aux), \mathsf{IssueContext}(\opk_m, \mathsf{cred_m}, \osk_{\mathsf{ctx}}, \cm_{\mathsf{ctx}}, aux)) \rightarrow (\mathsf{cred_{ctx}}, \bot)$ is an interactive protocol between a user and issuing organization. The user runs $\mathsf{ObtainContext}$ with master credential verification key $\opk_m$, context commitment $\cm_{\mathsf{ctx}}$, opening value $r$, master credential $\mathsf{cred_m}$, and auxiliary information $aux$. The organization runs $\mathsf{IssueContext}$ with master credential verification key $\opk_m$, master credential $\mathsf{cred_m}$, context issuing key $\osk_{\mathsf{ctx}}$, commitment $\cm_{\mathsf{ctx}}$, and auxiliary information $aux$. The protocol outputs a context credential $\mathsf{cred_{ctx}}$ to the user and $\bot$ to the issuer.

    \item $(\mathsf{Show}(\{\cm_i, r_i, \mathsf{cred}_i\}_{i=1}^n, \phi), \mathsf{Verify}(\{\mathsf{cred}'_i, \opk_i\}_{i=1}^n, \phi, \pi)) \rightarrow \{0,1\}$ is an interactive protocol between a user and verifier. The user runs $\mathsf{Show}$ with $n$ commitment-opening pairs $(\cm_i, r_i)$, their corresponding credentials $\mathsf{cred}_i$, and a predicate $\phi$. The verifier runs $\mathsf{Verify}$ with $n$ rerandomized credentials $\mathsf{cred}'_i$, their associated organization public keys $\opk_i$, the predicate $\phi$, and proof $\pi$. The protocol outputs 1 if verification succeeds, 0 otherwise.
\end{itemize}
\end{definition}



\subsection{Security Model}
We build upon the security model for Multi-Show ABCs from \cite{fuchsbauer_structure-preserving_2019} which is based on earlier work for group signatures \cite{hutchison_foundations_2005}. We extend it by supporting multiple organizations (issuers) with malicious keys for malicious issuer in anonymity, and support malicious users with credentials from multiple organizations. We add a Credential Binding property to enforce multi-credential, multi-issuer security.

\subsubsection{Security Properties}
% sec. property defines which party is malicious
Our Multi Issuer, Multi Credential Anonymous Credential system satisfies the following security and privacy properties:
\begin{enumerate}
    \item \textbf{Correctness: } a showing of a valid set of credentials and their corresponding commitments always verifies if the credentials are issued honestly and with respect to their corresponding issuer public keys. 
    
    \item \textbf{Unforgeability}: A malicious user can't show/verify attributes for credentials they don't own, can't mix credentials from different users, can't present a valid multi-credential proof without controlling all constituent credentials, can't replay a credential show from a different honest user. 
    
    \item \textbf{Anonymity:} A malicious verifier or organization can't identify the user or learn about the user more than the public information presented in the protocol, and that the credential satisfies the verification statement. The malicious verifier can't link multiple showings of the same credential, and for any set of credentials $\{Cred_1,\dots,Cred_n\}$ satisfying a predicate $\phi$, the adversary cannot distinguish whether they belong to the same or different users.

    \item \textbf{Credential Binding}: A malicious user cannot produce valid proofs linking credentials unless they were legitimately issued to the same user identifier. Specifically, an adversary cannot: combine credentials from different users into a valid multi-credential proof, even if each credential is individually valid. Can't create a valid linking proof without knowing the user secret for all constituent credentials, and can't forge proofs that falsely demonstrate credential ownership consistency

\end{enumerate}

\subsection{Model and Definitions}
We begin by presenting a model for privacy-preserving credential systems that supports multiple issuers and credential composition, extending the anonymous credential framework pioneered by \cite{hutchison_signature_2004}, extended in group signatures \cite{hutchison_foundations_2005} and modelled in an Attribute Based Anonymous Credential System \cite{fuchsbauer_structure-preserving_2019}.

\subsection{Global Variables}
At the beginning of each experiment, the following state is maintained:

\noindent \textbf{System Parameters:} For each issuer $i$, either the experiment computes an issuer keypair $(\mathsf{osk}_i, \mathsf{opk}_i)$ or the adversary outputs $\mathsf{opk}_i$. In the anonymity game, there is a challenge bit $b$, which the adversary must guess.

\noindent \textbf{User Management:} The system maintains:
\begin{itemize}
\item Sets $\mathsf{HU}$ and $\mathsf{CU}$ of honest and corrupted users
% \item Lists $\mathsf{UPK}$, $\mathsf{USK}$ tracking user keypairs
\item Lists $\mathsf{CRED}$, $\mathsf{COM}$, $\mathsf{OPEN}$, $\mathsf{OWNR}$ recording credentials, their commitments, their openings, and ownership
\end{itemize}

\noindent \textbf{Challenge State:} For the anonymity game, sets $\mathcal{J}_{\mathsf{LoR}}$ and $\mathcal{I}_{\mathsf{LoR}}$ track credential tuples and corresponding users during challenge phases.

\noindent  Our model extends the ABC system from \cite{fuchsbauer_structure-preserving_2019} in two ways:
\begin{enumerate}
    \item \textit{Multi-Issuer Support:} Users can obtain and compose credentials from different issuers while maintaining privacy across contexts
    \item \textit{Credential Composition:} Users can prove statements about multiple credentials while preserving unlinkability both within and across showings
\end{enumerate}


\noindent \textbf{The Oracles.} The security properties are defined via experiments where an adversary $\mathcal{A}$ interacts with the following oracles:

\noindent $\mathcal{O}_{\mathsf{HU}}(i)$ - By calling this honest user oracle with identity $i \in \mathbb{N}$, $\mathcal{A}$ can add $i$ to the set $\mathsf{HU}$ of honest users. The oracle generates $(\cm[i], r[i]) \sample \mathsf{UserCommit}(\mathsf{opk}, \vec{m})$, adds $i$ to $\mathsf{HU}$, and returns $\cm[i]$.

\noindent $\mathcal{O}_{\mathsf{CU}}(i, \cm)$ - By calling this corrupt user oracle with identity $i$ and optional commitment $\cm$, $\mathcal{A}$ can either register a new corrupt user (if $i \notin \mathsf{HU}$) or corrupt an honest user (if $i \in \mathsf{HU}$). In the latter case, $\mathcal{A}$ receives $\{(\cm_j[i], r_j[i])\}_{j \in \{\mathsf{m}, \mathsf{ctx}\}}$ and all credentials, where $(\cm_{\mathsf{m}}[i], r_{\mathsf{m}}[i])$ denotes the master credential commitment pair and $(\cm_{\mathsf{ctx}}[i], r_{\mathsf{ctx}}[i])$ denotes the context credential commitment pair.


\noindent $\mathcal{O}_{\mathsf{ObtIss}}(i, \vec{m}, aux)$ - This oracle represents the honest user execution of the Obtain-Issue protocol between an honest user and honest organization. By calling this obtain-issue oracle with identity $i$, message vector $\vec{m}$, and auxiliary information $aux$, $\mathcal{A}$ initiates an honest credential issuance. If $i \notin \mathsf{HU}$, returns $\bot$. Otherwise, computes $(\cm, r) \sample \mathsf{UserCommit}(\opk, \vec{m})$ and runs:
\[
(\mathsf{cred}, \top) \sample (\mathsf{Obtain}(\opk, \cm, r, aux), \mathsf{Issue}(\osk, \cm, aux))
\]
If $\mathsf{cred} = \bot$, returns $\bot$. Else appends $(i, \mathsf{cred}, \cm)$ to $(\mathsf{OWNR}, \mathsf{CRED}, \mathsf{COM})$.



\noindent $\mathcal{O}_{\mathsf{Obtain}}(i, \cm)$ - Models a malicious issuer interacting with an honest user $i \in \mathsf{HU}$. Takes a commitment $\cm$. If $i \notin \mathsf{HU}$, returns $\bot$. Runs:
\[
(\mathsf{cred}, \cdot) \sample (\mathsf{Obtain}(\opk, \cm, r[i], aux), \cdot)
\]
where Issue is executed by $\mathcal{A}$. On success, appends $(i, \mathsf{cred}, \cm)$ to $(\mathsf{OWNR}, \mathsf{CRED}, \mathsf{COM})$.




\noindent $\mathcal{O}_{\mathsf{Issue}}(i, \cm)$ - Models a malicious user interacting with an honest issuer. Takes identity $i$ and commitment $\cm$. If $i \notin \mathsf{CU}$, returns $\bot$. Runs:
\[
(\cdot, I) \sample (\cdot, \mathsf{Issue}(\osk, \cm, aux))
\]
where Obtain is executed by $\mathcal{A}$. If $I = \bot$, returns $\bot$. Else appends $(i, \bot, \cm)$ to $(\mathsf{OWNR}, \mathsf{CRED}, \mathsf{COM})$.


\noindent $\mathcal{O}_{\mathsf{Show}}(\{\mathsf{cred}_j\}_{j=1}^n, \phi)$ - Models credential verification with malicious verifier. Takes a set of credentials $\{\mathsf{cred}_j\}_{j=1}^n$ and predicate $\phi$. For each credential $j$, let $i_j \gets \mathsf{OWNR}[\mathsf{cred}_j]$. If any $i_j \notin \mathsf{HU}$, returns $\bot$. Runs:
\[
(S, \cdot) \sample (\mathsf{Show}(\{\cm_j[i_j], r_j[i_j], \mathsf{cred}_j\}_{j=1}^n, \phi), \cdot)
\]
where $\mathsf{Verify}$ is executed by $\mathcal{A}$.



\noindent $\mathcal{O}_{\mathsf{LoR}}(\mathsf{Creds}_0, \mathsf{Creds}_1, \phi)$ - This challenge oracle models anonymity through indistinguishability between two credential sets. Each $\mathsf{Creds}_b = (\mathsf{cred}_{b,1},\ldots,\mathsf{cred}_{b,n})$ represents an $n$-tuple of credentials. For each tuple:

\begin{enumerate}
    \item Let $i_b \gets \mathsf{OWNR}[\mathsf{cred}_{b,1}]$ be the owner.
    \item Verify $\forall j \in [n]: \mathsf{OWNR}[\mathsf{cred}_{b,j}] = i_b$ (binding)
    \item  Verify $i_b \in \mathsf{HU}$ (honest user)
    \item Let $\cm_{b,j} \gets \mathsf{COM}[\mathsf{cred}_{b,j}]$ be the commitments
\end{enumerate}

If $\mathcal{J}_{\mathsf{LoR}} \neq \emptyset$ and $\mathcal{J}_{\mathsf{LoR}} \neq \{\mathsf{Creds}_0, \mathsf{Creds}_1\}$, returns $\bot$. Otherwise:

\begin{enumerate}
    \item Set $\mathcal{J}_{\mathsf{LoR}} \gets \{\mathsf{Creds}_0, \mathsf{Creds}_1\}$
    \item Run: $(S, \cdot) \sample (\mathsf{Show}(\{\cm_{b,j}, r_{b,j}, \mathsf{cred}_{b,j}\}_{j=1}^n, \phi), \cdot)$
\end{enumerate}

where $b$ is the challenge bit and $\phi: \mathsf{COM}^n \rightarrow \{0,1\}$ validates statements over committed attributes.

Informally, the Left-or-Right oracle $\mathcal{O}_{\mathsf{LoR}}$ models unlinkability, $\mathcal{A}$ submits two credeential sets $\mathsf{Creds}_{b} \in \bit$, executes $\mathsf{Show}$ using $\mathsf{Creds_b}$ and their commitments. As in EUF-CMA, $\mathcal{A}'s$ goal is to choose which set was used, capturing the intuition that multiple showings of the same credentials should be unlinkable. The oracle maintains $\mathcal{J}_{\mathsf{LoR}}$ for consistency across challenge queries.


\subsection{MIMC-ABC Correctness}
A Multi-Issuer Multi-Credential Anonymous Credential system is correct if honestly generated credentials verify successfully both individually and in composition. Specifically:

\begin{enumerate}
    \item Individual Credential Validity: Both master and context credentials verify independently under their respective issuer public keys when shown with their original commitments
    \item Hierarchical Composition: Context credentials properly bind to their master credentials while maintaining verifiability under the respective issuer keys
    \item Multi-Credential Statements: Any valid predicate $\phi$ over committed attributes from multiple credentials verifies successfully when the credentials are honestly generated and belong to the same user
\end{enumerate}

\noindent More formally:

\begin{definition}[MIMC-ABC Correctness]
A Multi-Issuer Multi-Credential Anonymous Credential system (MIMC-ABC) is correct if for all security parameters $\lambda \in \mathbb{N}$, all polynomially-bounded $n \in \mathbb{N}$, all valid predicates $\phi$, and all attribute vectors $\{\vec{m}_i\}_{i \in [n]}$ of valid lengths, the following probability is 1:
\[
        \Pr
            \left [
            \begin{array}{l}
                \ppar \sample \mathsf{Setup}(1^\lambda),\\
        \{(\mathsf{osk}_i, \mathsf{opk}_i) \sample \mathsf{OrgKeygen}(\ppar)\}_{i \in [n]},\\
        \{(\mathsf{cm}_i, r_i) \sample \mathsf{UserCommit}(\mathsf{opk}_i, \vec{m}_i)\}_{i \in [n]},\\
        \{(\mathsf{cred}_i, \bot) \sample (\mathsf{ObtainMaster}(\mathsf{opk}_i, \mathsf{cm}_i, r_i, aux),\\
        \quad\mathsf{IssueMaster}(\mathsf{osk}_i, \mathsf{cm}_i, aux))\}_{i \in [n]} \\
         \{(\mathsf{cred}_i, \bot) \sample (\mathsf{ObtainContext}(\mathsf{cred_m}, \mathsf{opk}_i, \mathsf{cm}_i, r_i, aux),\\
        \quad\mathsf{IssueContext}(\mathsf{osk}_i, \mathsf{opk_m}, \mathsf{cm}_i, aux))\}_{i \in [n]}
            \end{array}
                : 
                \begin{array}{l}
                   (\mathsf{Show}(\{\mathsf{cm}_i, r_i, \mathsf{cred}_i\}_{i \in [n]}, \phi),\\
                    \quad\mathsf{Verify}(\{\mathsf{cred}'_i, \mathsf{opk}_i\}_{i \in [n]}, \phi, \pi)) = 1
                \end{array}
                \right ]
             = 1
\]
\
\end{definition}

















\newpage
\subsection{Unforgeability}
Unforgeability is formalized as a game between a challenger and an adversary $\mathcal{A}$, where $\mathcal{A}$ can interact with honest users and issuers through oracles modeling real-world capabilities. The adversary succeeds if it produces a valid proof that violates one of five forgery conditions. 
\begin{definition}[MIMC-ABC Unforgeability]
A MIMC-ABC system is unforgeable if for all $\PPT$ adversaries $\mathcal{A}$, the following experiment outputs 1 with negligible probability:
\[
\Pr[\mathsf{Exp}^{\mathsf{unf}}_{\mathsf{MIMC\mbox{-}ABC},\mathcal{A}}(\lambda) = 1] \leq \negl
\]
\end{definition}

\noindent $\mathsf{Exp}^{\mathsf{unf}}_{\mathsf{MIMC\mbox{-}ABC},\mathcal{A}}(\lambda)$ proceeds as follows:

\begin{enumerate}
    \item \textbf{Setup}: $\ppar \sample \mathsf{Setup}(1^\lambda)$, for each issuer $i \in [n]$: $(osk_i, opk_i) \sample \mathsf{OrgKeyGen}(\ppar)$.  
        \begin{itemize}
            \item $\ppar \sample \mathsf{Setup}(1^\lambda)$
            \item For each issuer $i \in [n]$: $(osk_i, opk_i) \sample \mathsf{OrgKeyGen}(\ppar)$
            \item Initialize $\mathsf{HU}, \mathsf{CU}, \mathsf{CRED}, \mathsf{COM}, \mathsf{OWNR} \gets \emptyset$
        \end{itemize}
    \item \textbf{Adversarial Interaction}: $\mathcal{A}$ receives $\{\opk_i\}_{i \in [n]}$ and adaptively queries:
\begin{itemize}
    \item $\mathcal{O}_{\mathsf{HU}}(i) \rightarrow \cm[i]$: Add honest user $i$
    \item $\mathcal{O}_{\mathsf{CU}}(i, \cm) \rightarrow \{\cm[i], r[i], \mathsf{cred}[i]\}$: Corrupt user $i$
    \item $\mathcal{O}_{\mathsf{ObtIss}}(i, \vec{m}) \rightarrow \mathsf{cred}$: Obtain credential for honest user $i$
    \item $\mathcal{O}_{\mathsf{Obtain}}(\cm) \rightarrow \top/\bot$: Obtain credential as malicious user
    \item $\mathcal{O}_{\mathsf{Show}}(\{\mathsf{cred}_j\}, \phi) \rightarrow \pi$: Observe honest showings
\end{itemize}
    \item \textbf{Forgery (Validity Condition)}: $\mathcal{A}$ outputs $(\pi^*, \phi^*, \{\mathsf{cred}_i\}_{i=1}^k)$.  

    \item \textbf{Win} if:
    \begin{itemize}
        \item \textbf{Type 1 (Credential Forgery)}: 
        $\exists j \in [k]$ where $\mathsf{cred}_j^*$ satisfies either:
        \begin{enumerate}
            \item $\mathsf{cred}_j^* \notin \mathsf{CRED}$ (never issued)
            \item $\mathsf{OWNR}[\mathsf{cred}_j^*] \in \mathsf{HU} \setminus \mathsf{CU}$ (belongs to uncorrupted honest user)
        \end{enumerate}

        \item \textbf{Type 2 (Proof-Statement Inconsistency)}: 
        $\mathsf{Verify}(\{\mathsf{cred}_i^*, \opk_i\}_{i=1}^k, \phi^*, \pi^*) = 1$ but either:
        \begin{enumerate}
            \item The committed attributes don't satisfy $\phi^*$: 
            For the commitments $\{\cm_i^*\}_{i=1}^k$ corresponding to $\{\mathsf{cred}_i^*\}_{i=1}^k$,
            $\forall \{\vec{m}_i, r_i\}_{i=1}^k$ such that $\cm_i^* = \mathsf{UserCommit}(\opk_i, \vec{m}_i; r_i)$,
            we have $\phi^*(\{\vec{m}_i\}_{i=1}^k) = 0$
            
            \item The proof claims a false relationship: 
            The commitments $\{\cm_i^*\}_{i=1}^k$ contain valid attributes $\{\vec{m}_i\}_{i=1}^k$, but
            $\pi^*$ proves a statement about these attributes that doesn't hold
        \end{enumerate}

\end{enumerate}





















\newpage
\subsection{Anonymity} 

\begin{definition}[MIMC-ABC Anonymity]
A MIMC-ABC system provides anonymity if for all PPT adversaries $\mathcal{A}$,
\[
\adv^{\mathsf{anon}}_{\mathcal{A}}(\lambda) := \left|\Pr[\mathsf{Exp}^{\mathsf{anon}\mbox{-}1}_{\mathcal{A}}(\lambda)=1] - \Pr[\mathsf{Exp}^{\mathsf{anon}\mbox{-}0}_{\mathcal{A}}(\lambda)=1]\right| \leq \negl
\]
where the experiment $\mathsf{Exp}^{\mathsf{anon}\mbox{-}b}_{\mathcal{A}}(\lambda)$ proceeds as:
\end{definition}

\begin{enumerate}
    \item \textbf{Setup Phase:}
    \begin{itemize}
        \item $\ppar \sample \mathsf{Setup}(1^\lambda)$
        \item $(st, \{opk_i\}_{i \in [n]}) \sample \mathcal{A}(\ppar)$ Adversary generates (potentially malicious) keys
        \item Initialize $\mathsf{HU}, \mathsf{CU}, \mathsf{CRED}, \mathsf{COM}, \mathsf{OWNR} \gets \emptyset$
        \item $\mathcal{J}_{\mathsf{LoR}}, \mathcal{I}_{\mathsf{LoR}} \gets \emptyset$ 
        \item Sample challenge bit $b \sample \{0,1\}$
    \end{itemize}

    \item \textbf{Query Phase:} $\mathcal{A}(st)$ adaptively accesses:
    \begin{itemize}
        \item $\mathcal{O}_{\mathsf{HU}}(i) \rightarrow \cm[i]$ Add honest user $i$, register $\cm[i]$
        
        \item $\mathcal{O}_{\mathsf{CU}}(i)$: Corrupt user $i$ (learn secrets; invalidates future $\mathcal{O}{\mathsf{LoR}}$ queries on $i$).  
        
        \item $\mathcal{O}_{\mathsf{Obtain}}(i, \cm)$: Observe Honest user $i$ obtaining credential on $\cm$ from $\mathcal{A}$ (malicious issuer).
        
        \item $\mathcal{O}_{\mathsf{Show}}(\{\mathsf{cred}_j\}, \phi)$: Observe honest showings $\{\mathsf{cred}_j\}$. 
        
        \item $\mathcal{O}_{\mathsf{LoR}}(\mathsf{Creds}_0, \mathsf{Creds}_1, \phi) \rightarrow \pi$: Challenge oracle, detailed below.
    \end{itemize}
\sam{this needs reworking, its not clear}
    \item \textbf{Challenge Handling for $\mathcal{O}_{\mathsf{LoR}}$}:
    \begin{enumerate}
        \item Parse $\mathsf{Creds}_b = (\mathsf{cred}_{b,1},\ldots,\mathsf{cred}_{b,n})$ 
        \item Check $\forall j: \mathsf{OWNR}[\mathsf{cred}_{0,j}] = i_0 \land \mathsf{OWNR}[\mathsf{cred}_{1,j}] = i_1$ 
        \item Require $i_0,i_1 \in \mathsf{HU}$
        \item Verify $\phi(\{\mathsf{cred}_{0,j}\}) = \phi(\{\mathsf{cred}_{1,j}\}) = 1$ 
        \item If $\mathcal{J}_{\mathsf{LoR}} \neq \emptyset \land (\mathsf{Creds}_0, \mathsf{Creds}_1) \notin \mathcal{J}_{\mathsf{LoR}}$: abort 
        \item $\pi_b \gets \mathsf{Show}(\mathsf{Creds}_b, \phi)$ using bit $b$
        \item Update $\mathcal{J}_{\mathsf{LoR}} \gets \mathcal{J}_{\mathsf{LoR}} \cup \{(\mathsf{Creds}_0,\mathsf{Creds}_1)\}$
        \item Return $\pi_b$
    \end{enumerate}

    \item \textbf{Win Condition}: $\mathcal{A}$ outputs $b'$.
    Experiment returns 1 if:
    \begin{enumerate}
        \item $b' = b$ 
        \item No trivial wins: $\mathcal{J}_{\mathsf{LoR}} \neq \emptyset$ 
        \item No credential leakage: $\forall (\mathsf{Creds}_0,\mathsf{Creds}_1) \in \mathcal{J}_{\mathsf{LoR}}$, neither $i_0$ nor $i_1$ were corrupted
       \end{enumerate}
\end{enumerate}


\begin{remark}
This extends \cite{fuchsbauer_structure-preserving_2019}'s anonymity game by:
\begin{itemize}
    \item Tracking credential ownership across multiple issuers
    \item Formalizing multi-credential linkage through $\mathcal{J}_{\mathsf{LoR}}$
\end{itemize}
\end{remark}

























\newpage
\subsection{Credential Binding}
\begin{definition}[MIMC-ABC Credential Binding]
A MIMC-ABC system provides credential binding if for all PPT adversaries $\mathcal{A}$,
\[
\mathsf{Adv}^{\mathsf{bind}}_{\mathcal{A}}(\lambda) := \Pr[\mathsf{Exp}^{\mathsf{bind}}_{\mathsf{MIMC\mbox{-}ABC},\mathcal{A}}(\lambda)=1] \leq \negl
\]
where the experiment $\mathsf{Exp}^{\mathsf{bind}}_{\mathsf{MIMC\mbox{-}ABC},\mathcal{A}}(\lambda)$ proceeds as:
\end{definition}

\noindent $\mathsf{Exp}^{\mathsf{bind}}_{\mathsf{MIMC\mbox{-}ABC},\mathcal{A}}(\lambda)$:

\begin{enumerate}
    \item \textbf{Setup}:
    \begin{itemize}
        \item $\ppar \sample \mathsf{Setup}(1^\lambda)$ 
        \item For each issuer $i \in [n]$: $(\osk_i, \opk_i) \sample \mathsf{OrgKeyGen}(\ppar)$
        \item Initialize $\mathsf{HU}, \mathsf{CU}, \mathsf{CRED}, \mathsf{COM}, \mathsf{OWNR} \gets \emptyset$
    \end{itemize}
    
    \item \textbf{Adversarial Interaction}: $\mathcal{A}$ receives $\{\opk_i\}_{i \in [n]}$ and queries:
    \begin{itemize}
        \item $\mathcal{O}_{\mathsf{HU}}(i) \rightarrow \cm[i]$: Add honest user
        \item $\mathcal{O}_{\mathsf{CU}}(i, \cm)$: Corrupt user (reveals secrets)
        \item $\mathcal{O}_{\mathsf{ObtIss}}(i, \vec{m})$: Obtain honest credentials
        \item $\mathcal{O}_{\mathsf{Obtain}}(i, \cm)$: Interact with malicious issuer
        \item $\mathcal{O}_{\mathsf{Issue}}(\cm)$: Issue to malicious user
        \item $\mathcal{O}_{\mathsf{Show}}(\{\mathsf{cred}_j\}, \phi)$: Observe showings
    \end{itemize}
    
    \item \textbf{Forgery}: $\mathcal{A}$ outputs $(\pi^*, \phi^*, \{\mathsf{cred}_j^*\}_{j=1}^k)$
    
    \item \textbf{Win} if:
    \begin{enumerate}
        \item $\mathsf{Verify}(\{\mathsf{cred}_j^*, \opk_j\}_{j=1}^k, \phi^*, \pi^*) = 1$
        \item $\exists j_1,j_2 \in [k]$ with $\mathsf{OWNR}[\mathsf{cred}_{j_1}^*] \neq \mathsf{OWNR}[\mathsf{cred}_{j_2}^*]$ 
        \item $\forall j \in [k]: \mathsf{cred}_j^* \in \mathsf{CRED} \land \mathsf{OWNR}[\mathsf{cred}_j^*] \in \mathsf{HU} \setminus \mathsf{CU}$
    \end{enumerate}
\end{enumerate}

\begin{remark}
This binding property enforces credential ownership consistency:
\begin{itemize}
    \item Prevents "credential mixing" attacks across users
    \item Maintains integrity of multi-credential proofs
    \item Complements unforgeability by addressing cross-user composition
\end{itemize}
\end{remark}
























\newpage
\subsection{MIMC-ABC Construction}\label{sec:mimcabc-construction}
\subsubsection{Intuition of our Construction}

Our construction builds a new anonymous credential building block for multi-issuer, multi-credential systems. The key insight is combining three well-known cryptographic primitives using clever modifications that achieves privacy, efficiency, and practical deployment requirements.

\paragraph{Randomized Signature over Commitments}
    % \item \textbf{Modified Rerandomizable Pointcheval-Sanders Signatures:} 
    % Our construction builds on Pointcheval-Sanders signatures which provide constant-sized signatures and efficient verification via bilinear pairings. We employ the modification in \cite{tomescu2022utt}, rather than randomizing just the signature, then proving knowledge of messages with respect to the randomized signature, we first randomize the commitment with $u_\Delta$, then randomize the signature with the commitment randomness $u_\Delta$ and new randomness $r_\Delta$.
    
    % The modification removes the need to run zero-knowledge protocols on the randomized signature, which are bespoke for this scheme and often needed in anonymous credentials e.g. \cite{sako_short_2016, hutchison_signature_2004}. Instead, ours outputs a verified randomized Pedersen commitment to be used in standardized zero-knowledge proof protocols \cite{stephan_krenn_proposal_nodate}, which are widely used with security reducing to the original PS signature under the q-SDH assumption. Furthermore, our modification avoids sigma protocols with computation in $\G_2$ significantly reducing overhead. 
    
    % \item \textbf{Commitment Scheme: } 
    % We employ a dual Pedersen Commitment, inspired by \cite{tomescu2022utt} that maintains commitments in both $\G_1$ and $\G_2$ of our bilinear group, which is needed to support the modification mentioned above. We leverage key properties of Pedersen Commitments throughout our system
    % \begin{enumerate}
    %     \item Perfect hiding supports statistical zero knowledge 
    %     \item Computational binding under the discrete log assumption supports unforgeability of signatures
    %     \item Position binding adds functionality to our zero knowledge proof protocols, specifically for proving attributes at the same position of a message vector are equal
    %     \item Homomorphic properties support complex interactive protocols as in Figures \ref{fig:master-cred-issuance}
    % \end{enumerate}

\paragraph{$\Sigma$-protocols}
Our construction liberally employs $\Sigma$-protocols for proving statements about committed attributes. 
\begin{itemize}
    \item $\Pi^{\mathcal{R}_{\mathsf{com}}}$ represents the Pedersen Commitment opening proof of relation $\mathcal{R}_{\mathsf{com}}$  \ref{pok-com}
    \item $\Pi^{\mathcal{R}_{\mathsf{and}}}$ \ref{pok-and}
    \item $\Pi^{\mathcal{R}_{\mathsf{linear}}}$ \ref{pok-linear}
    \item $\Pi^{\mathcal{R}_{\mathsf{zero}}}$ \ref{pok-zero}
    \item $\Pi^{\mathcal{R}_{\mathsf{two-party}}}$ \ref{pok-2party}
    \item $\Pi^{\mathcal{R}_{\mathsf{non-zero}}}$ \ref{pok-nonzero}
    \item $\Pi^{\mathcal{R}_{\mathsf{equality}}}$ \ref{pok-eq}
    \item $\Pi^{\mathcal{R}_{\mathsf{sok}}}$ \ref{pok-ps}
    \item $\Pi^{\mathcal{R}_{\mathsf{vrf}}}$ \ref{pok-vrf}
\end{itemize}


\subsubsection{Example} Consider an employers recruitment scenario where they wish to verify personal information, $\phi$ requires proving three credentials as in Figure \ref{fig:three-creds} :
\begin{enumerate}
    \item Possession of a valid master credential
    \item Possession of a driver's license
    \item An Australian University degree (revealing the degree name)
\end{enumerate}

\begin{figure}
        \begin{pchstack}[boxed, center, space=4em]
            \begin{pcvstack}
                \procedure[space=auto]{Master Credential}{%
                s: 12345, \\
                k: 89898, \\
                ctx: "master", \\
                exp: 01/01/2030, \\
                \ldots \\
                }
            \end{pcvstack}
            \pcvspace
            \begin{pcvstack}
                \procedure[space=auto]{Driver License}{%
                s: 12345, \\
                \delta: VRF(k, "dmv"), \\
                ctx: "dmv", \\
                exp: 02/02/2027, \\
                \ldots \\
                }
            \end{pcvstack}
            \pcvspace
            \begin{pcvstack}
                \procedure[space=auto]{University Degree}{%
                s: 12345, \\
                \delta: VRF(k, "usyd{-}bcompsc"), \\
                ctx: "usyd{-}bcompsc", \\
                issued: 06/06/2020, \\
                \ldots \\
                }
            \end{pcvstack}
        \end{pchstack}
    \caption{Three Example Credentials}
    \label{fig:three-creds}
\end{figure}

\noindent A user with three valid credentials first rerandomizes their signatures and commitments:
\begin{align*}
    \cm_i' \gets& \mathsf{Com.Rerand}(\cm_i, \Delta_{r_i}) \text{ for } i \in [1,3] \\
    \sigma_i' \gets& \mathsf{PS.Rerand}(\sigma_i, \Delta_{r_i}, \Delta_{u_i} \text{ for } i \in [1,3])
\end{align*}
The rerandomized credentials and commitments $\cm_i', \sigma_i'$ are now indistinguishable from their original issuance.  
Next, the user and verifier interact in a two-party protocol where the user first verifies the randomized signatures and their commitments, 
\[
\mathsf{PS.Verify}(\sigma_i',\cm_i',pk_i') = 1 \quad \forall i \in [3]
\]

\noindent Let $\mathcal{R}$ be a relation for public input $(\sigma_m', \sigma_d', \sigma_u', pk_m, pk_d, pk_u, \cm_m', \cm_d', \cm_u')$ where:

$\mathcal{R}$ = {$(s, k, r_m, r_d, r_u, \delta_d, u_\Delta, \mathsf{ctx}_m, \mathsf{ctx}_d, \mathsf{ctx}_u, \mathsf{exp}_m, \mathsf{exp}_d, \mathsf{issued}_u)$:
\begin{align*}
    \cm_m &= \mathsf{CM.Com}([s, k, \mathsf{ctx}_m, \mathsf{exp}_m]; r_m) \; \wedge \; \mathsf{exp}_m > \mathsf{today} \; \wedge \mathsf{ctx}_m = \text{"master"} \; \wedge\\
    \cm_d &= \mathsf{CM.Com}([s, \delta_d, \mathsf{ctx}_d, \mathsf{exp}_d]; r_d) \; \wedge \; \mathsf{exp}_d > \mathsf{today} \; \wedge \mathsf{ctx}_d = \text{"dmv"} \; \wedge\\
    \cm_u &= \mathsf{CM.Com}([s, u_\Delta, \mathsf{ctx}_u, \mathsf{issued}_u]; r_u) \; \wedge \; \mathsf{ctx}_u \in \mathcal{D} \; \wedge\\
    s &= \cm_m[0] = \cm_d[0] = \cm_u[0]
\end{align*}





\subsubsection{Outline}
Our credential system operates over attribute space $\Z_p$ with arbitrary string attributes mapped to field elements by a collision-resistant hash function $H: \bit^* \to \Z_p$. A credential for user $i$ consists of a 
commitment $\cm_i \gets \mathsf{CM.Commit}([attr_1,\ldots,attr_n]; r)$ to $n$ attributes with randomness $r \sample \Z_p^*$, a Pointcheval-Sanders signature $\sigma \gets \mathsf{PS.Sign}(\cm_i, \mathsf{osk})$ on the commitment, verifiable by $\mathsf{PS.Verify}(\sigma, \cm_i, \mathsf{opk}) = 1$

\subsubsection{Freshness}
To prevent replay attacks in credential show/verify protocols, we employ an interactive challenge-response mechanism as per Sigma protocols \textbf{Cite Sigma Protocols}. During showing, the verifier provides a random challenge that must be incorporated in the zero-knowledge proofs, ensuring uniqueness of each showing. Interaction could be removed using the Fiat-Shamir transform \textbf{Cite Fiat Shamir}, this would require verifiers to maintain a list of used proofs introducing overhead and potential security concerns in a multi-verifier/distributed setting.

\newpage
\subsubsection{Malicious Organization Keys.}
For our PS signature-based ABC system, we define an NP-relation $\mathcal{R}_O$ capturing well-formed organization keys:
$$ ((pk, pp_{cm}), (sk, r)) \in \mathcal{R}_O \iff \mathsf{PS.VKey}(sk, pk) = 1 \land pp_{cm} = \mathsf{Setup}(1^\lambda; r) $$

During credential issuance, the organization must provide a zero-knowledge proof of knowledge 
$\pi \gets \mathsf{ZKPoK}\{(sk,r): ((pk, pp_{cm}), (sk,r)) \in \mathcal{R}_O\}$. 
This ensures:
\begin{itemize}
    \item The organization knows its PS signing key $sk$
    \item The commitment parameters $pp_{cm}$ are properly generated with known randomness $r$
\end{itemize}

























adf

\newpage
\subsection{Master Credential Issuance}
The master credential issuance protocol enables a user to obtain their root credential from the Master Credential Oracle $\MCO$ while preserving the privacy of their VRF key $k$ and ensuring accountability. The protocol combines verifiable encryption, Verifiable Random Function, Zero Knowledge Proofs, and Rerandomizable PS Signatures over commitments to achieve Sybil Resistance, Revocation, and Anonymity.

\begin{figure}
    \begin{center}
    \begin{tabular}{l@{\hspace{12em}}c@{\hspace{12em}}l}
    \multicolumn{3}{l}{$\underline{Setup(1^{\lambda}, 1^n)}$:} \\[0.5em]
    \multicolumn{3}{l}{System: $(\G_1, \G_2, \G_T, e, g, \tilg ) \gets BG.Gen(\secparam, p), \; ck_m \gets CM.Setup(BG, \secparam, n)$} \\[1em]
    \multicolumn{3}{l}{Credential Oracle: $(SK_m, PK_m) \gets PS.KeyGen(ck_m)$} \\[1em]
    \multicolumn{3}{l}{System setup User List $\mathcal{U}$} \\[1em]
    \underline{User($s$)} && \underline{MCO($SK_M$)} \\[0.5em]
    \multicolumn{3}{l}{$k_1 \gets \Z_p$, \; $\cm_1 \gets \mathsf{CM.Com}([0,k_1,0,0],r)$}\\[1em]
    \multicolumn{3}{l}{$\Pi_1 \gets ZKPoK.Prove_{Zeros}(C_1)(k_1, r)$} \\[1em]
    & $\xrightarrow{C_1, \Pi_1}$ & \\[1em]
    \multicolumn{3}{r}{If $ZKPoK.Verify_{Zeros}(\Pi_1, C_1) = 0, $ return $ \bot$} \\[1em]
    \multicolumn{3}{r}{$k_2 \gets \Z_p, \; C_2 \gets Com([s, k_2, "master", attrs], 0)$} \\[1em]
    \multicolumn{3}{r}{$C_m \gets C_1 \cdot C_2 = Com([s,k_1+k_2,"master", attrs], r)$} \\[1em]
    & $\xleftarrow{C_2, C_m, s, k_2}$ & \\[1em]
    \multicolumn{3}{l}{$k \gets k_1 + k_2$} \\[1em]
    \multicolumn{3}{l}{$\Pi_2 \gets ZKPoK.Prove_{addition}(C_1, C_2, C_m)(k_1, k_2, k, r)$} \\[1em]
    & $\xrightarrow{C_1, C_2, C_m, \Pi_2, \Pi_3, \tau}$ &\\[1em]
    \multicolumn{3}{r}{If $ZKPOK.Verify_{addition}(\Pi_2, C_1, C_2, C_m) = 0, \;$ return $\bot$} \\[0.5em]
    \multicolumn{3}{r}{$\sigma_m \gets PS.Sign(SK_M, C_1)$} \\[0.5em]
    \multicolumn{3}{r}{Store Data Record MCO $(C_m, \sigma_m, \tau, \Pi_2, \Pi_3, C_1, C_2, k_2)$ } \\[1em]
    & $\xleftarrow{\sigma_m}$ & \\[1em]
    \multicolumn{3}{l}{If $PS.Verify(PK_A, \sigma_m, C_m) = 1$, Store $Cred_m(\sigma_m, C_m)$} \\[1em]
    \end{tabular}
    \end{center}
    \caption{Master Credential Issuance}
    \label{fig:master-cred-issuance}
\end{figure}


\paragraph{Informal Security Analysis}

The two-party process between the user and master credential oracle ensures sybil resistance of unique identifier $s$; the oracle has access to the user information and checks duplicate issuance within their own identity system. 
During VRF key issuance, the anonymity of the master credential is preserved via the secrecy of the VRF key $k$. During the two-party computation, the user's share $k_1$ remains hidden to $\MCO$ via the hiding property of the commitment $C_1$, and malicious commitment usage is prevented by the soundness property of $\Pi_1$. 

\noindent The user combines  $k_1 + k_2$ to form their VRF key, $\Pi_2$ proves $k_1$ is correctly derived from $C_1$, $k_2$ is derived from $C_2$ and $k$ combines $k_1 + k_2$, $\MCO$'s input to $k$ prevents forgery attempts on the key $k$. The hiding property of the commitments and zero-knowledge property of the proofs ensures correct protocol adherence while maintaining private computation. Revocation is enabled by encryption of the VRF key $k$ with the public key of the Auditor $PK_A$. $\Pi_3$ proves that $\tau$ is an encryption of the committed key $k$. $\tau$ is stored with the credential oracle maintaining privacy during normal operation. Finally, the protocol prevents replay attacks by using interactive zero-knowledge proofs requiring a challenge from the verifier, fresh commitment randomness, and $\MCO$'s input of their share of the VRF key $k_2$ preventing existing transcript reuse.



    % \item \textbf{Unforgeability}: A malicious user can't show/verify attributes for credentials they don't own, can't mix credentials from different users, can't present a valid multi-credential proof without controlling all constituent credentials, can't replay a credential show from a different honest user. 
    
    % \item \textbf{Anonymity:} A malicious verifier or organization can't identify the user or learn about the user more than the public information presented in the protocol, and that the credential satisfies the verification statement. The malicious verifier can't link multiple showings of the same credential, and for any set of credentials $\{Cred_1,\dots,Cred_n\}$ satisfying a predicate $\phi$, the adversary cannot distinguish whether they belong to the same or different users.

Unforgeable
- user has to do 2 party protocol to generate key k, means user can't forge it
- also user needs to prove zeros in the commitment, so they can't forge their attribute values
- they need to prove 

Anonymous
- users prf key k is anonymous
- 






Notes on security reduction
Because we changed from UPK, USK, The simulator needs to 
- Generate user identities (satisfied by CM.Com)
- Extract user secrets when needed (possible through r)
- Link users across queries (achieved through cm)










































\newpage
\subsection{Context Credential Issuance}
Context Credential Issuance enables a user to obtain a context-specific credential while proving ownership of a valid master credential. The user first constructs a commitment to their context credential attributes, including their identity $s$ and a deterministic nullifier derived from their VRF key $k$ and the credential context $ctx$. Through zero-knowledge proofs, the user demonstrates their master credential is valid and unrevoked, and proves the context commitment is well-formed with the same identity $s$. The nullifier $\tau$ = $VRF(k,ctx)$ prevents multiple credentials for the same context while maintaining privacy. Upon successful verification, the Context Credential Oracle signs the commitment and records the nullifier.
\begin{figure}
        \begin{center}
        \begin{tabular}{l@{\hspace{12em}}c@{\hspace{12em}}l}
        \multicolumn{3}{l}{$\underline{Setup(1^{\lambda}, 1^n)}$:} \\[0.5em]
        \multicolumn{3}{l}{System: $(\G_1, \G_2, e, g, \tilg ) \gets BG.Gen(\secparam, p), \; ck_c \gets CM.Setup(BG, \secparam, n)$} \\[1em]
        \multicolumn{3}{l}{Credential Oracle: $(SK_c, PK_c) \gets PS.KeyGen(ck_c)$} \\[1em]
        \underline{User($Cred_m, s, k$)} && \underline{CCO($SK_c$)} \\[0.5em]
        \multicolumn{3}{l}{$\delta \gets VRF(k, ctx)$} \\[1em]
        \multicolumn{3}{l}{$r* \sample Z_p, \; C_c \gets Com([s,\delta,ctx,attrs],r*)$} \\[1em]
        \multicolumn{3}{l}{$\Pi_4 \gets ZKPoK.Prove_{selective-disclosure}(C_c,\delta,ctx,attrs)(s, r*)$} \\[1em]
        \multicolumn{3}{l}{$r' \sample \Z_p, Cred_{m}' \gets Cred.Rerand(Cred_{m}, r')$} \\[1em]
        \multicolumn{3}{l}{$\Pi_5 \gets ZKSoK.Prove(Cred_m')(s,k,master,attrs,r')$} \\[1em]
        \multicolumn{3}{l}{Parse $Cred_m'$ as $C_m', \sigma_m'$} \\[1em]
        \multicolumn{3}{l}{$\Pi_6 \gets ZKPoK.Prove_{reciprocal}(C_m', C_c,ctx)(s,k,r',r*)$}  \\[1em]
        \multicolumn{3}{l}{$\Pi_7 \gets ZKPoK.Prove_{equality}(C_m', C_c)(s, r)$} \\[1em]
        & $\xrightarrow{Cred_m', C_c, \Pi_4, \Pi_5, \Pi_6, \Pi_7}$ & \\[1em]
        \multicolumn{3}{r}{If} \\[1em]
        \multicolumn{3}{r}{$ZKPok.Verify_{selective-disclosure}(\Pi_4, C_c)(\delta, ctx, attrs)$ = 1 $\; \wedge$} \\[1em]
        \multicolumn{3}{r}{$ZKSoK.Verify(\Pi_5, Cred_m')$ = 1 $\; \wedge$} \\[1em]
        \multicolumn{3}{r}{$ZKPoK.Verify_{reciprocal}(\Pi_6, C_m', C_c, ctx)$ = 1 $\; \wedge$} \\[1em]
        \multicolumn{3}{r}{$ZKPoK.Verify_{equality}(\Pi_7, C_m', C_c)$ = 1 $\; \wedge$} \\[1em]
        \multicolumn{3}{r}{$\sigma_c \gets PS.Sign(SK_c, C_c)$} \\[1em]
        \multicolumn{3}{r}{Store Data Record CCO $(C_c, \sigma_c, \delta, \Pi_4, \Pi_5, \Pi_6, \Pi_7 )$} \\[1em]
        & $\xleftarrow{\sigma_c}$& \\[1em]
        \multicolumn{3}{l}{If $PS.Verify(PK_c,\sigma_c, C_c) = 1$, Store $Cred_c(\sigma_c, C_c)$} \\[1em]
        \end{tabular}
        \end{center}
    \caption{Context Credential Issuance}
    \label{fig:context-cred-issuance}
\end{figure}



\subsubsection{Informal Security Analysis}
Sybil Resistance: The deterministic nullifier $\delta \gets VRF(k,ctx)$ binds each context credential to a unique (user, context) pair, preventing multiple credentials for the same context. The reciprocal proof $\Pi_6$ ensures correct nullifier derivation from the master key $k$. 
Credential Binding: Context Credentials are bound to master credentials through shared identity $s$ and $\Pi_7$. The selective disclosure proof $\Pi_4$ ensures correct commitment structure without revealing private values. 
Privacy: The protocol only reveals $ctx$ and $attrs$ to CCO to allow identity verification while hiding $s$. The Master Credential $Cred_m$ remains unlinkable by being  rerandomized and proven in zero knowledge it verifies with the Master Credential Oracles public key.






\subsubsection{Verification}
A user $user$ wants to prove to any relying party $rely$ they have a valid credential that satisfies a verification statement $\phi$.
The protocol takes as input $(rcd, ccd, \phi, rpk, acc, n)$ and outputs success or failure.
$rely$ starts by sending $(\phi, n, acc)$ to $user$ where $\phi$ is a statement that specifies the requirements for a successful verification and $acc$ is the current accumulator value of revoked nullifiers.
$user$ starts by randomizing their credentials $rcd' = psrerand(rcd)$ and $ccd' = psrerand(ccd)$ and verifies $psverify_{ck_{rcd}}(rcd')$ and $psverify_{ck_{ccd}}(ccd')$. $user$ generate their nullifiers $nullif_{pid} \gets PRF_s(pid)$ and $nullif_{ctx} \gets PRF_s(ctxid)$ and obtains non-membership witnesses $wpid$, $wctx$ for nullifiers against $acc$.
$user$ generates a zero-knowledge proof $\pi$ showing 1) their credentials are valid, 2) they're not expired $(expiry > current_time)$, 3) their nullifiers are correctly formed from $s$, 4) their nullifiers are not in $acc$ using witnesses $wpid, wctx$, 5) the credential attributes satisfy $\phi$, 6) proof freshness using $n$.
$user$ sends $(\pi, attrs_{\phi})$ to $rely$, $rely$ verifies $\pi$ against $acc$ and validates $attrs_{\phi}$ satisfies $\phi$. Returns accept if all checks pass, reject otherwise.








\newpage
\section{Security Analysis Framework}

\subsection{Forgery Classifications}
3 categories of forgeries

\begin{enumerate}
    \item \textbf{Classic Credential Forgery}
    \begin{itemize}
        \item Adversary forges a credential that was never issued
        \item Reduces to PS-LRSW assumption
        \item Similar to standard EUF-CMA security for signatures
    \end{itemize}
    
    \item \textbf{Credential Binding Break}
    \begin{itemize}
        \item Adversary combines valid credentials from different users
        \item Reduces to position binding of Pedersen commitments under SDLP
        \item Analogous to binding breaks in commitment schemes
    \end{itemize}
    
    \item \textbf{Context/Linking Forgery}
    \begin{itemize}
        \item Adversary creates false relationships between credentials
        \item Reduces to VRF uniqueness property
        \item Moved to separate Credential Binding security property
    \end{itemize}
\end{enumerate}

\subsection{Credential Structure}
Our system employs two types of credentials with distinct commitment structures:

\subsubsection{Master Credential}
\begin{equation*}
    cm_m = \text{Com}([id, k, \text{"master"}, attrs]; r)
\end{equation*}
where:
\begin{itemize}
    \item $id$: unique identifier
    \item $k$: VRF key
    \item $\text{"master"}$: fixed context string
    \item $attrs$: additional attributes
    \item $r$: commitment randomness
\end{itemize}

\subsubsection{Context Credential}
\begin{equation*}
    cm_c = \text{Com}([id, \text{VRF}(k, ctx), ctx, attrs]; r)
\end{equation*}
where:
\begin{itemize}
    \item $id$: same identifier as master credential
    \item $\text{VRF}(k, ctx)$: deterministic nullifier
    \item $ctx$: context-specific identifier
    \item $attrs$: context-specific attributes
    \item $r$: fresh commitment randomness
\end{itemize}

\subsection{Next Steps}
To proceed with security proofs, we should:
\begin{enumerate}
    \item Formalize the unforgeability game definition
    \item Detail the Credential Binding security property
    \item Construct reductions for each forgery type
    \item Analyze the tightness of our reductions
\end{enumerate}






\subsection{Progress Summary}

We've established three key components of our security analysis:

\begin{enumerate}
   \item \textbf{Security Framework}
   \begin{itemize}
       \item Taxonomized forgery types following Camenisch-Lysyanskaya's methodology
       \item Identified distinct credential structures and their properties
       \item Outlined reduction strategy following Pointcheval-Sanders
   \end{itemize}

   \item \textbf{PS-LRSW Understanding}
   \begin{itemize}
       \item Challenger provides $(g, X=g^x, Y=g^y)$
       \item Oracle $\mathcal{O}(m)$ returns $(h, h^{x+my})$ for random $h$
       \item Challenge requires forgery $(m^*, P_1^*, P_2^*)$ where:
           \begin{itemize}
               \item $m^*$ never queried
               \item $P_1^* \neq 1$
               \item $e(P_1^*, X\cdot\tilde{Y}^{m^*}) = e(P_2^*, g_2)$
           \end{itemize}
   \end{itemize}

   \item \textbf{Reduction Structure} (single-issuer case)
   \begin{itemize}
       \item Embedding challenge elements in commitment bases
       \item Oracle simulation strategy outlined
       \item Forgery extraction mechanism identified
   \end{itemize}
\end{enumerate}

\subsection{Next Technical Steps}
To complete our Type 1 unforgeability proof:

\begin{enumerate}
   \item Detail oracle simulation for credential issuance
   \item Specify forgery extraction mechanism
   \item Extend to multi-issuer setting
   \item Analyze reduction tightness
\end{enumerate}

Would you like to proceed with detailing the oracle simulation phase of our reduction?







































% % % % % % % % % % 
% 
% END MIMC-ABC Construction
% 
% % % % % % % % % % 





\newpage




% % % % % % % % % % 
% 
% Sigma Protocols
% 
% 
% % % % % % % % % % 
\section{Zero-Knowledge Proofs}

Zero-Knowledge Proofs (ZKPs) enable a prover $\Prover$ to demonstrate the validity of a statement $x$ while keeping the corresponding witness $w$ secret. In the context of anonymous credentials, ZKPs allow a user to prove possession of a credential, verify the validity of its attributes, and comply with related policies, all while revealing none or only minimal sensitive underlying data.

Efficient Zero-Knowledge Proofs are a fundamental building block of anonymous credential systems. We show that by leveraging the modularity and composability of ZKPs, we construct a suite of protocols that form the backbone of our credential system and intertwine with the security properties of our other components to achieve the fundamental properties of Anonymous Credentials - Correctness, Unforgeability, and Anonymity.

We organize our discussion in three parts
\begin{enumerate}
    \item We first introduce the fundamental concepts of zero-knowledge proofs and the core protocols, including interactive proof systems, proofs of knowledge, and $\Sigma$-protocols.
    \item Next, we extend the discussion to more complex protocols such as compound statements and pairing-based constructs that are commonly used in anonymous credential systems.
    \item Finally, we present our original contribution: a novel proof of multiplicative inverse. We demonstrate how this protocol is used to prove the correct evaluation of a Verifiable Random Function (VRF) created from secret messages in two distinct commitments, and we provide a detailed analysis comparing its efficiency and performance to previous and alternate work.
\end{enumerate}
In the following section, we will leverage these constructions with our rerandomizable signature over commitments to build a multi-issuer, multi-credential anonymous credential system with sybil resistance.
















\subsection{Interactive Proof Systems, the Prover $\Prover$ and Verifier $\Verifier$}

An interactive proof system for a language $L$ consists of two probabilistic interactive Turing machines $(\Prover, \Verifier)$, where $\Prover$ is the prover and $\Verifier$ is the verifier. In the context of Anonymous Credentials, $\Prover$ represents a user holding a credential issued by an Issuer, whereas $\Verifier$ represents any public system tasked with verifying the user's identity and attributes.

The interactive proof system must satisfy the following properties:
\begin{itemize}
    \item \textbf{Completeness}: For all $x \in L$, if both parties follow the protocol honestly, then the verifier accepts with overwhelming probability:
    \[
        \Pr[(\Prover,\Verifier)(x) = 1] \geq 1 - \epsilon(|x|),
    \]
    where $\epsilon(|x|)$ is a negligible function. This property guarantees that honest interactions will almost always lead to acceptance.
    
    \item \textbf{Soundness}: For all $x \notin L$ and any (potentially malicious) prover $\Prover^*$, the probability that $\Verifier$ accepts is negligible:
    \[
        \Pr[(\Prover^*,\Verifier)(x) = 1] \leq \delta(|x|),
    \]
    where $\delta(|x|)$ is a negligible function. This ensures that any attempt by a dishonest prover to convince the verifier of a false statement will be unsuccessful except with negligible probability.
\end{itemize}


\subsection{Proofs of Knowledge, the Extractor $\mathcal{E}$, and Signatures of Knowledge}

In many cryptographic settings, including anonymous credential systems, it is not sufficient to simply prove that a statement is valid; one must also ensure that the prover genuinely possesses the underlying secret. This requirement is critical for enforcing non-transferability of credentials and for enabling constructs like signatures of knowledge, where the user not only signs a statement but demonstrates knowledge of a hidden secret key or witness.

A proof of knowledge introduces an extractor $\mathcal{E}$, a theoretical algorithm that—given the ability to rewind a prover $\Prover^*$ that convinces the verifier with non-negligible probability—can efficiently extract the corresponding witness $w$. Formally, for any prover $\Prover^*$,
\[
\Pr\big[\mathcal{E}^{\Prover^*}(x) = w : (x,w) \in R\big] \geq \Pr\big[(\Prover^*,\Verifier)(x) = 1\big] - \nu(|x|),
\]
where $\nu(|x|)$ is negligible and $R$ is the underlying relation.

This property is essential when constructing a signature of knowledge, where the signer must prove, in zero-knowledge, that they possess the secret value corresponding to their public credential. The extractor's role here guarantees that any valid proof (or signature) could only have been produced by someone who actually knows the secret witness. In other words, an adversary cannot forge a valid signature-of-knowledge without having genuine knowledge of the secret, which is crucial for preventing credential sharing or transfer. 


\subsection{Zero-Knowledge and the Simulation $\mathcal{S}$ Paradigm}
Zero-knowledge strengthens interactive proofs through the simulation paradigm. The key insight is that if a simulator $\mathcal{S}$ can produce transcripts indistinguishable from real protocol interactions without access to the witness, then the protocol reveals no knowledge beyond the statement's validity. 

Formally, for all probabilistic polynomial-time verifiers $\Verifier^*$, there exists a probabilistic polynomial-time simulator $\mathcal{S}$ such that for all $x \in L$:
\[ 
\{\text{VIEW}_{\Verifier^*}(\Prover,\Verifier^*)(x)\} \approx_c \{\mathcal{S}(x)\} 
\]
\noindent where VIEW represents the verifier's view of the real protocol interaction and $\approx_c$ denotes computational indistinguishability.

\noindent Informally, the simulator paradigm provides a powerful proof technique for demonstrating zero-knowledge. If an efficient algorithm (the simulator) can generate protocol transcripts without access to any witness (the secret), and these transcripts are computationally indistinguishable from real protocol executions, that is, they look the same, then the verifier must not be able to learn anything meaningful about the witness during actual protocol runs. This is because anything the verifier could compute from a real interaction could equally well be computed from the simulated transcripts. The simulator effectively demonstrates that the verifier's view of the protocol can be reconstructed without any knowledge of the secret witness, a concept first introduced by Goldwasser, Micali, and Rackoff in their seminal 1985 paper.



\subsection{Zero-Knowledge and the Simulation Paradigm}

Zero-knowledge proofs ensure that no additional information is leaked during the proof process beyond the validity of the statement being proven. The central idea behind this guarantee is captured by the simulation paradigm. In this paradigm, one demonstrates that for any efficient (i.e., probabilistic polynomial-time) verifier, there exists a simulator $\mathcal{S}$ that can produce transcripts of interactions that are computationally indistinguishable from those produced in an actual honest execution of the protocol.

\noindent Formally, for every probabilistic polynomial-time verifier $\Verifier^*$ and for every statement $x \in L$, there exists a probabilistic polynomial-time simulator $\mathcal{S}$ such that the verifier's view generated during its interaction with the honest prover $\Prover$,
\[
\{\text{VIEW}_{\Verifier^*}(\Prover, \Verifier^*)(x)\},
\]
is computationally indistinguishable from the output of the simulator,
\[
\{\mathcal{S}(x)\}.
\]
We denote this equivalence by:
\[
\{\text{VIEW}_{\Verifier^*}(\Prover, \Verifier^*)(x)\} \approx_c \{\mathcal{S}(x)\}.
\]

\noindent The fundamental implication of this property is that, since the simulator can produce convincing transcripts without access to any witness, the verifier gains no additional knowledge about the secret; the simulator demonstrates that every piece of information the verifier observes could have been generated independently, hence ensuring the zero-knowledge property.





\subsection{$\Sigma$-Protocol Template}
A $\Sigma$-protocol follows a specific three-move structure, Commit, Challenge, Response:

\begin{protocol}{$\Sigma$-Protocol Template}{prot-sigma-template}
\textbf{Common Input:} Statement $x$\\
\textbf{Prover Input:} Witness $w$ such that $(x,w) \in R$
    \begin{enumerate}
        \item \textbf{Commitment:} $\mathcal{P}$ computes first message $a$ (the commitment) and sends it to $\mathcal{V}$
        \item \textbf{Challenge:} $\mathcal{V}$ sends a random $t$-bit challenge $e$
        \item \textbf{Response:} $\mathcal{P}$ computes response $z$ and sends it to $\mathcal{V}$
        \item $\mathcal{V}$ accepts if verification predicate $\phi(x,a,e,z)=1$
    \end{enumerate}
\end{protocol}


\subsection{$\Sigma$-Protocol Framework}
A $\Sigma$-protocol for relation $R$ is a three-move public-coin protocol between a prover $\mathcal{P}$ and verifier $\mathcal{V}$ that follows our template structure while satisfying three properties

\begin{definition}[$\Sigma$-Protocol]
A protocol $\pi$ is a $\Sigma$-protocol for relation $R$ if it is a three-move public-coin protocol and satisfies:
\begin{itemize}
    \item \textbf{Completeness:} If $\mathcal{P}$ and $\mathcal{V}$ follow the protocol on common input $x$ and private input $w$ to $\mathcal{P}$ where $(x,w) \in R$, then $\mathcal{V}$ always accepts.
    
    \item \textbf{Special Soundness:} There exists a polynomial-time extractor $\mathcal{E}$ that, given any $x$ and any pair of accepting transcripts $(a,e,z)$ and $(a,e',z')$ where $e \neq e'$, outputs $w$ such that $(x,w) \in R$.
    
    \item \textbf{Special Honest-Verifier Zero-Knowledge:} There exists a polynomial-time simulator $\mathcal{S}$ that, on input $x$ and challenge $e$, outputs a transcript $(a,e,z)$ with the same probability distribution as transcripts between honest $\mathcal{P}(x,w)$ and $\mathcal{V}(x,e)$.
\end{itemize}
\end{definition}


\noindent Special soundness requires extraction from any pair of accepting transcripts with the same first message, which is stronger than standard knowledge extraction. Similarly, special HVZK requires simulation for any given challenge, not just a random one.


\subsection{Schnorr's Zero Knowledge Proof of Knowledge}
The canonical example of a $\Sigma$-protocol is Schnorr's identification scheme which demonstrates proof of knowledge of a discrete logarithm, where a prover convinces a verifier they know $w$ such that $h = g^w$ without revealing $w$.

\noindent For a cyclic group $\mathbb{G}$ of prime order $q$ with generator $g$, the relation is formally defined as:
\[
    \mathcal{R}_{\mathsf{DL}} = \{(h,w) \in \mathbb{G} \times \mathbb{Z}_q : h = g^w\}
\]

\noindent $\mathcal{R}_{\mathsf{DL}}$ captures the statement $x$, that $h$ is the public key derived from secret key $w$.

\begin{protocol}{Schnorr's Protocol}{schnorr}\label{prot:schnorr}
\textbf{Common Input:} Group element $h \in \mathbb{G}$\\
\textbf{Prover Input:} $w \in \mathbb{Z}_q$ such that $h = g^w$
\begin{enumerate}
    \item \textbf{Commitment:} $\Prover$ samples $r \sample \Z_q$, computes $a = g^r$
    \item \textbf{Challenge:} $\Verifier$ samples challenge $e \sample \{0,1\}^t$ where $2^t < q$
    \item \textbf{Response:} $\Prover$ computes $z = r + ew \mod q$
    \item Verification: $\Verifier$ accepts if $g^z = a \cdot h^e$
\end{enumerate}
\end{protocol}

\noindent We show this satisfies $\Sigma$-protocol the 3 properties

\begin{itemize}
    \item \textbf{Completeness:} If $\mathcal{P}$ and $\mathcal{V}$ follow the protocol on common input $x$ and private input $w$ to $\mathcal{P}$ where $(x,w) \in R$, then $\mathcal{V}$ always accepts.
    
    \item \textbf{Special Soundness:} Given transcripts $(a,e,z)$ and $(a,e',z')$ where $e \neq e'$, one can efficiently extract $w = \frac{(z-z')}{(e-e')} \mod q$
    
    \item \textbf{Special Honest-Verifier Zero-Knowledge:} For any fixed challenge $e$, there exists a simulator $\mathcal{S}$ that can efficiently simulate accepting transcripts by sampling $z \sample \Z_q$ and computing $a = g^z h^{-e}$

    
\end{itemize}


\subsubsection{Notation}

\subsection{Relations and Languages}
We begin by defining the fundamental notion of a relation and its associated language. For a relation $\mathcal{R}$, we define its language $L_\mathcal{R}$ as:
\[
    L_\mathcal{R} = \{x \mid \exists w : (x,w) \in \mathcal{R}\}
\]
where $x$ represents the statement to be proven and $w$ represents the witness.

\subsection{Basic Cryptographic Relations}
The discrete logarithm relation, which forms the basis for many of our constructions, is defined as:
\[
    \mathcal{R}_{\mathsf{DL}} = \{((g,h),w) \in (\mathbb{G} \times \mathbb{G}) \times \mathbb{Z}_q : h = g^w\}
\]
where $g$ is explicitly included as part of the statement. In practice, when $g$ is a fixed system parameter, we often use the simplified notation:
\[
    \mathcal{R}_{\mathsf{DL}} = \{(h,w): h = g^w\}
\]

For Pedersen commitments, where both the commitment and its opening are part of the proof, we define:
\[
    \mathcal{R}_{\mathsf{com}} = \{(\cm,(m,r)) : \cm = g^m h^r\}
\]

When proving relations between multiple commitments, we extend this notation. For example, proving equality of committed values:
\[
    \mathcal{R}_{\mathsf{eq}} = \{(\cm_1, \cm_2),(m,r_1,r_2)) : 
    \cm_1 = g^m h^{r_1} \land \cm_2 = g^m h^{r_2}\}
\]


\subsection{Relations and Languages}

A central concept in constructing zero-knowledge protocols is that of a relation and its corresponding language. In cryptographic proofs, a relation $\mathcal{R}$ is defined as a subset of pairs $(x, w)$ where $x$ is a statement and $w$ is the associated witness such that a predetermined predicate $\phi$ is satisfied. The language associated with $\mathcal{R}$, denoted $L_\mathcal{R}$, is defined as:
\[
L_\mathcal{R} = \{ x \mid \exists w \text{ such that } (x, w) \in \mathcal{R} \}.
\]
This abstraction enables us to capture the notion of “proof of a statement” as a proof of membership in a language.

For example, consider the discrete logarithm relation, which is a key building block in many protocols:
\[
\mathcal{R}_{\mathsf{DL}} = \{ (h, w) \in \mathbb{G} \times \mathbb{Z}_q : h = g^w \}.
\]
Here, $x = h$ is the public statement and $w$ is the discrete logarithm relative to the generator $g$.

Similarly, for commitment schemes, notably the Pedersen commitment, the relation is captured as:
\[
\mathcal{R}_{\mathsf{com}} = \{ (\cm, (m, r)) : \cm = g^m h^r \}.
\]
In this context, the language consists of all valid commitments, and the corresponding witness includes both the message $m$ and the randomness $r$.


















% ==============================================================================
% SubSection Outline: Advanced Proof Protocols for Anonymous Credentials
% ==============================================================================

% Overall Strategy:
% -----------------
% The goal of this section is to illustrate how basic building blocks of zero-knowledge 
% proofs are composed and tailored to the demands of anonymous credential systems. In 
% particular, we focus on protocols and constructs that prove knowledge of commitment 
% openings, linear relations among exponents, and consistency of identical attributes 
% across multiple credentials. This section serves as the bridge between foundational 
% concepts and our novel contributions.



% We propose the following structure:

\section{Advanced Proof Protocols}

% Introduction:
% Briefly outline the section's objective, emphasizing the need to show how complex 
% proofs are constructed by combining simpler proofs of knowledge. Note how these are 
% essential for the security and non-transferability properties in anonymous credentials.


Advanced proof protocols are extensions of basic proof protocols

Proof protocols are combined with the properties of other building blocks to enable 

Correctness
Unforgeability
Anonymity



\begin{enumerate}
    \item Proof of Knowledge (PoK) for the opening of commitments.
    \item PoK demonstrating linear relations (e.g., that the sum of certain exponents equals a separate exponent).
    \item PoK of Zero values.
    \item Signatures of Knowledge that seamlessly integrate both signing and proof of knowledge.
    \item Multiple commitments and equality proofs for exponents, crucial for proving consistent userid across various credentials.
\end{enumerate}
Following this, we will build upon these foundational constructs to introduce our novel contribution: a proof of multiplicative inverse that further enhances the efficiency and expressiveness of verifiable random functions derived from multiple commitments.

Our work underscores that the confluence of these individual security properties forms the backbone of secure anonymous credential systems, enabling a rich set of functionalities while ensuring stringent privacy guarantees.


\subsection{Protocol Categories and Their Roles}


\subsection{Structure and Flow}
% - Begin with the simplest constructs (e.g., PoK opening) before moving to protocols that compose these 
%   basic proofs.
% - For each protocol, adopt a consistent format:
%     • \textbf{Protocol Description}: A high-level overview of its purpose and use-case.
%     • \textbf{Formal Definition and Relation}: The mathematical relation underlying the proof.
%     • \textbf{Protocol Steps}: A succinct set of steps (or pseudo-code) outlining the interaction.
%     • \textbf{Security Properties}: A brief discussion on key security aspects such as completeness, soundness, 
%       and zero-knowledge characteristics.
%
% - Conclude the section with a summary that underscores how these building blocks naturally lead to the more 
%   sophisticated protocols to be introduced in our contribution section.

% Integration with Next Section (Our Contribution):
% - At the end of this section, briefly mention that the following section will build on these foundations 
%   to introduce our novel proof of multiplicative inverse, which further enhances the efficiency and expressiveness 
%   in designing verifiable random functions from multiple commitments.

% This structured approach ensures that readers appreciate both the individual properties of each protocol 
% and their combinatorial power in constructing secure anonymous credential systems.












%   1. A brief description of the protocol's purpose in the context of anonymous credentials.
%   2. A formal definition of the underlying relation and language (if applicable).
%   3. An outline of the protocol steps (to be detailed in later subsections).



%     • \textbf{Protocol Description}: A high-level overview of its purpose and use-case.
%     • \textbf{Formal Definition and Relation}: The mathematical relation underlying the proof.
%     • \textbf{Protocol Steps}: A succinct set of steps (or pseudo-code) outlining the interaction.
%     • \textbf{Security Properties}: A brief discussion on key security aspects such as completeness, soundness, 
%       and zero-knowledge characteristics.




\newpage
\subsection{Proof of Knowledge for Pedersen Commitment Opening}\label{pok-com}

In anonymous credential systems, to verify a credential, rather than sending the messages in plainsight, a prover demonstrates knowledge of the opening of a Pedersen commitment without revealing the message or randomness. 
\[
    \cm = g^m h^r \text{   and often denoted in shorthand   } \mathsf{CM.Com}([m];r)
\]
where \(g, h \in \mathbb{G}\) (a cyclic group of prime order \(q\)), \(m\) is the message, and \(r\) is the randomness. The corresponding relation is
\[
    \mathcal{R}_{\mathsf{com}} = \{ (\cm,(m,r)) \;|\; \cm = g^m h^r \}.
\]

\begin{protocol}{Pedersen Commitment Opening}{ped-open}
\textbf{Common Input:} Commitment \(\cm\) and public parameters \(g,h \in \mathbb{G}\)\\
\textbf{Prover Input:} Witness \((m,r)\) such that \(\cm = g^m h^r\)
\begin{enumerate}
    \item \textbf{Commitment:} Prover samples \(\alpha, \rho \sample \Z_q\), computes 
    \[
      T \gets g^{\alpha}h^{\rho},
    \]
    and sends \(T\) to the verifier.
    \item \textbf{Challenge:} Verifier samples a challenge \(c \sample \Z_q\) and sends it to the prover.
    \item \textbf{Response:} Prover computes 
    \[
      s \gets \alpha + c\,m \quad \text{and} \quad u \gets \rho + c\,r,
    \]
    and sends \((s,u)\) to the verifier.
    \item \textbf{Verification:} Verifier checks if 
    \[
      g^s h^u \stackrel{?}{=} T \cdot \cm^c.
    \]
\end{enumerate}
\end{protocol}

\paragraph{Security Properties:}
This \(\Sigma\)-protocol template satisfies:
\begin{itemize}
    \item \textbf{Completeness:} Honest execution leads the verifier to accept.
    
    \item \textbf{Special Soundness and the Extractor:}      Assume that an adversarial prover produces two accepting transcripts for the same commitment \(T\) but with distinct challenges \(c\) and \(c'\):
    \[
    (T, c, s, u) \quad \text{and} \quad (T, c', s', u'),
    \]
    with \(c \neq c'\). The extractor \(\mathcal{E}\) operates by rewinding the prover to the point immediately after sending \(T\) and then issuing two different challenges \(c\) and \(c'\). Given that in an honest execution the responses satisfy
    \[
    s = \alpha + c\,m \quad \text{and} \quad u = \rho + c\,r,
    \]
    we have from the two transcripts:
    \[
    s - s' = (c - c')\,m \quad \text{and} \quad u - u' = (c - c')\,r.
    \]
    Thus, the extractor computes the witness as:
    \[
    m = \frac{s - s'}{c - c'} \quad \text{and} \quad r = \frac{u - u'}{c - c'}.
    \]
    This demonstrates that any prover capable of producing two valid responses for different challenges must, in fact, know the correct opening \((m, r)\) of the commitment, thereby ensuring the protocol’s special soundness.


    
    \item \textbf{Honest-Verifier Zero-Knowledge:} We proceed with the simulator construction as follows:

    Let $\mathcal{S}$ be a simulator that, given the public input \(\cm\) and a challenge \(c \in \Z_q\), produces a transcript indistinguishable from one generated in an honest run of the protocol. The simulator works as follows:
    \begin{enumerate}
        \item \textbf{Random Response Generation:}  
        \(\mathcal{S}\) uniformly samples \(s, u \sample \Z_q\). These will serve as the simulated responses.
        
        \item \textbf{Commitment Computation:}  
        \(\mathcal{S}\) computes the simulated commitment message by setting
        \[
            T \gets g^s h^u \cdot \cm^{-c}.
        \]
        This computation ensures that during verification,
        \[
            T \cdot \cm^c = g^s h^u,
        \]
        thus satisfying the verifier’s check.
        
        \item \textbf{Transcript Output:}  
        The simulator outputs the transcript \((T, c, s, u)\).
    \end{enumerate}

\paragraph{Justification:}  
In a real protocol execution, the prover computes \(T = g^{\alpha} h^{\rho}\) with \(\alpha\) and \(\rho\) chosen uniformly at random, and then calculates \(s = \alpha + c\,m\) and \(u = \rho + c\,r\). Since \(\alpha\) and \(\rho\) are uniformly random in \(\Z_q\), it follows that \(s\) and \(u\) are uniformly distributed in \(\Z_q\) as well. In the simulation, by sampling \(s\) and \(u\) uniformly at random, and then setting 
\[
    T \gets g^s h^u \cdot \cm^{-c},
\]
the simulator produces a transcript with the same distribution as in an honest execution. This construction satisfies the special honest-verifier zero-knowledge property, as the transcript \((T, c, s, u)\) is computationally indistinguishable from transcripts generated during real interactions.
\end{itemize}





\subsection{AND proofs for protocol composition}\label{pok-and}

In many applications, such as anonymous credential systems, it is required to prove in zero-knowledge that a prover knows witnesses for two separate statements. Assume we have two relations: 
\[
  \mathcal{R}_1 = \{(x_1,w_1) \mid \text{$x_1$ is a valid instance with witness } w_1\}
\]
and
\[
  \mathcal{R}_2 = \{(x_2,w_2) \mid \text{$x_2$ is a valid instance with witness } w_2\}.
\]
For each relation, a $\Sigma$-protocol exists. For instance, the Pedersen commitment opening protocol is a $\Sigma$-protocol for the relation
\[
  \mathcal{R}_{\mathsf{com}} = \{(\cm,(m,r)) \mid \cm = g^m h^r\}.
\]
Our goal is now to construct an AND proof that convinces a verifier that the prover knows witnesses $w_1$ and $w_2$ such that $(x_1,w_1) \in \mathcal{R}_1$ \emph{and} $(x_2,w_2) \in \mathcal{R}_2$.








\begin{protocol}{AND proofs with Pedersen Commitment Openings}{dped-open}
\textbf{Common Input:} Commitments \(\cm_1,\cm_2\) and public parameters \(g,h \in \mathbb{G}\)\\[1mm]
\textbf{Prover Input:} Witnesses \((m_1,r_1)\) and \((m_2,r_2)\) such that 
\[
  \cm_1 = g^{m_1}h^{r_1} \quad \text{and} \quad \cm_2 = g^{m_2}h^{r_2}.
\]
\begin{enumerate}
    \item \textbf{Commitment:} 
    Prover samples \(\alpha_1,\rho_1, \alpha_2,\rho_2  \sample \Z_q\), computes 
        \[
          T_1 \gets g^{\alpha_1}h^{\rho_1} \text{ for } \cm_1 \quad \wedge \quad T_2 \gets g^{\alpha_2}h^{\rho_2} \text{ for } \cm_2
        \]
    
    sends $T_1,T_2)$ to $\Verifier$
    
    \item \textbf{Challenge:} $\Verifier$ samples a challenge \(c \sample \Z_q\) and sends it to the $\Prover$.
    \item \textbf{Response:} 
    \begin{enumerate}
        \item Prover computes 
        \[
          s_1 \gets \alpha_1 + c\,m_1,\quad u_1 \gets \rho_1 + c\,r_1, \text{for } \cm_1
        \]
        \[
          s_2 \gets \alpha_2 + c\,m_2,\quad u_2 \gets \rho_2 + c\,r_2, \text{for } \cm_2
        \]
        \item Prover sends the responses \((s_1,u_1)\) and \((s_2,u_2)\) to the verifier.
    \end{enumerate}
    \item \textbf{Verification:} Verifier accepts if both equations hold
    \[
    g^{s_1} h^{u_1} \stackrel{?}{=} T_1 \cdot \cm_1^c \quad \wedge \quad g^{s_2} h^{u_2} \stackrel{?}{=} T_2 \cdot \cm_2^c
    \]
\end{enumerate}
\end{protocol}

This AND proof protocol leverages the security properties of the individual $\Sigma$-protocols. By using a common challenge $c$ for both subprotocols, the overall protocol maintains:
\begin{itemize}
  \item \textbf{Completeness,} since honest executions produce valid transcripts;
  \item \textbf{Special Soundness,} as the extraction of both witnesses is possible from two transcripts with differing challenges; and
  \item \textbf{Honest-Verifier Zero-Knowledge,} because a simulator can generate indistinguishable transcripts.
\end{itemize}
This construction can be extended to other Boolean combinations (such as OR proofs) and alternative cryptographic relations, ensuring robust and modular design in advanced cryptographic protocols.








\newpage
\subsection{Proof of Knowledge for Linear Relations}\label{pok-linear}

In anonymous credential systems, it is often necessary to prove that committed values satisfy linear relationships (e.g., \(m_3 = m_1 + m_2\)) without revealing the individual messages or randomness. Let \(\cm_1 = g^{m_1}h^{r_1}\), \(\cm_2 = g^{m_2}h^{r_2}\), and \(\cm_3 = g^{m_1 + m_2}h^{r_3}\). The relation is defined as:
\[
\mathcal{R}_{\mathsf{linear}} = \left\{ 
    \big((\cm_1, \cm_2, \cm_3), (m_1, m_2, r_1, r_2, r_3)\big) \; 
    \Big| \; 
    \cm_1 = g^{m_1}h^{r_1} \, \land \, \cm_2 = g^{m_2}h^{r_2} \, \land \, \cm_3 = g^{m_1 + m_2}h^{r_3} 
\right\}.
\]

\begin{protocol}{Linear Relation Proof}{linear-proof}
\textbf{Common Input:} \(\cm_1, \cm_2, \cm_3\) and public parameters \(g, h \in \mathbb{G}\)\\
\textbf{Prover Input:} Witness \((m_1, m_2, r_1, r_2, r_3)\) satisfying \(\mathcal{R}_{\mathsf{linear}}\)
\begin{enumerate}
    \item \textbf{Commitment:} Prover samples \(\alpha_1, \alpha_2 \sample \Z_q\) and \(\rho_1, \rho_2, \rho_3 \sample \Z_q\), then computes:
    \[
    T_1 \gets g^{\alpha_1}h^{\rho_1}, \quad T_2 \gets g^{\alpha_2}h^{\rho_2}, \quad T_3 \gets g^{\alpha_1 + \alpha_2}h^{\rho_3},
    \]
    and sends \(T_1, T_2, T_3\) to the verifier.
    
    \item \textbf{Challenge:} Verifier samples \(c \sample \Z_q\) and sends it to the prover.
    
    \item \textbf{Response:} Prover computes:
    \[
    s_1 \gets \alpha_1 + c\,m_1, \quad s_2 \gets \alpha_2 + c\,m_2, \quad s_3 \gets \alpha_1 + \alpha_2 + c\,(m_1 + m_2),
    \]
    \[
    u_1 \gets \rho_1 + c\,r_1, \quad u_2 \gets \rho_2 + c\,r_2, \quad u_3 \gets \rho_3 + c\,r_3,
    \]
    and sends \((s_1, s_2, s_3, u_1, u_2, u_3)\) to the verifier.
    
    \item \textbf{Verification:} Verifier checks:
    \[
    g^{s_1}h^{u_1} \stackrel{?}{=} T_1 \cdot \cm_1^c, \quad 
    g^{s_2}h^{u_2} \stackrel{?}{=} T_2 \cdot \cm_2^c, \quad 
    g^{s_3}h^{u_3} \stackrel{?}{=} T_3 \cdot \cm_3^c.
    \]
\end{enumerate}
\end{protocol}

\paragraph{Security Properties:}
\begin{itemize}
    \item \textbf{Completeness:} Substituting \(s_i = \alpha_i + c\,m_i\) and \(u_i = \rho_i + c\,r_i\) into the verification equations confirms correctness.
    
    \item \textbf{Special Soundness:} Let \((T_1, T_2, T_3, c, s_1, s_2, s_3, u_1, u_2, u_3)\) and \((T_1, T_2, T_3, c', s_1', s_2', s_3', u_1', u_2', u_3')\) be two transcripts with \(c \neq c'\). The extractor \(\mathcal{E}\) computes:
    \[
    m_1 = \frac{s_1 - s_1'}{c - c'}, \quad m_2 = \frac{s_2 - s_2'}{c - c'}, \quad r_i = \frac{u_i - u_i'}{c - c'} \;\; (i \in \{1,2,3\}),
    \]
    and verifies that \(\cm_3 = g^{m_1 + m_2}h^{r_3}\). This ensures \(m_3 = m_1 + m_2\).
    
    \item \textbf{Honest-Verifier Zero-Knowledge:} A simulator \(\mathcal{S}\), given \(c\), samples \(s_1, s_2, s_3, u_1, u_2, u_3 \sample \Z_q\) and computes:
    \[
    T_1 \gets g^{s_1}h^{u_1}\cm_1^{-c}, \quad T_2 \gets g^{s_2}h^{u_2}\cm_2^{-c}, \quad T_3 \gets g^{s_3}h^{u_3}\cm_3^{-c}.
    \]
    The output transcript \((T_1, T_2, T_3, c, s_1, s_2, s_3, u_1, u_2, u_3)\) is indistinguishable from a real interaction.
\end{itemize}

\paragraph{Justification:}  
The protocol preserves the linear relationship \(m_3 = m_1 + m_2\) by enforcing algebraic consistency across the commitments. The extractor leverages the binding property of Pedersen commitments and the linearity of the exponents to recover the witness. The simulator’s ability to retroactively construct valid transcripts ensures no information about \(m_1, m_2, r_i\) is leaked.











\newpage
\subsection{Proof of Knowledge of Zero Values}\label{pok-zero}

In anonymous credential systems, selective disclosure often requires proving that specific committed values are zero without revealing their positions. Let \(\cm = \prod_{i=1}^n g_i^{m_i} h^r\) be a Pedersen commitment where subset \(J \subseteq [n]\) satisfies \(m_j = 0\) for \(j \in J\). The relation is:
\[
\mathcal{R}_{\mathsf{zero}} = \left\{ (\cm, J), ( \{m_i\}_{i \notin J}, r) \; \Big| \; \cm = \prod_{i=1}^n g_i^{m_i} h^r \land m_j = 0 \ \forall j \in J \right\}.
\]

\begin{protocol}{Zero-Value Proof}{zero-proof}
\textbf{Common Input:} \(\cm\), index set \(J\), and public parameters \(g_1,\ldots,g_n,h \in \mathbb{G}\)\\
\textbf{Prover Input:} Witness \((\{m_i\}_{i \notin J}, r)\) with \(m_j = 0\) for \(j \in J\)
\begin{enumerate}
    \item \textbf{Key Modification:} Prover constructs reduced commitment key \(\ck' = (g_i)_{i \notin J} \cup \{h\}\).
    
    \item \textbf{Equivalence Proof:} Prover shows \(\cm\) can be expressed under \(\ck'\):
    \[
    \cm = \prod_{i \notin J} g_i^{m_i} h^{r}.
    \]
    
    \item \textbf{Standard ZKPoK:} Prover executes a Schnorr-type protocol for \(\ck'\) to demonstrate knowledge of \(\{m_i\}_{i \notin J}\) and \(r\).
\end{enumerate}
\end{protocol}



\subsubsection{Zero-Value Proof Application to Selective Disclosure}\label{pok-disclose}

Consider a Pedersen commitment scheme with generators \(g_1, g_2, h \in \mathbb{G}\) and a commitment to two messages \(m_1, m_2\) with randomness \(r\):
\[
\cm = g_1^{m_1} g_2^{m_2} h^r.
\]
Suppose the prover wishes to disclose \(m_1\) while keeping \(m_2\) and \(r\) private. The protocol proceeds as follows:

\begin{protocol}{Selective Disclosure}{sel-disclosure}
\textbf{Common Input:} \(\cm\), generators \(g_1, g_2, h\)\\
\textbf{Prover Input:} \((m_1, m_2, r)\) such that \(\cm = g_1^{m_1} g_2^{m_2} h^r\)\\
\textbf{Disclosed Value:} \(m_1\)
\begin{enumerate}
    \item \textbf{Disclosure:} Prover sends \(m_1\) to the verifier.
    \item \textbf{Commitment Adjustment:} Verifier computes 
    \[
    \cm' \gets \cm \cdot g_1^{-m_1} = g_2^{m_2} h^r.
    \]
    \item \textbf{Proof of Knowledge:} Prover executes a ZKPoK for the relation:
    \[
    \mathcal{R}_{\mathsf{hidden}} = \left\{ (\cm', (m_2, r)) \;|\; \cm' = g_2^{m_2} h^r \right\}.
    \]
    This is instantiated via a Schnorr-type protocol:
    \begin{enumerate}
        \item Prover samples \(\alpha, \rho \sample \Z_p\), computes \(T \gets g_2^{\alpha} h^{\rho}\), and sends \(T\).
        \item Verifier sends challenge \(c \sample \Z_p\).
        \item Prover computes responses \(s \gets \alpha + c m_2\), \(u \gets \rho + c r\), and sends \((s, u)\).
        \item Verifier checks \(g_2^s h^u \stackrel{?}{=} T \cdot (\cm')^c\).
    \end{enumerate}
\end{enumerate}
\end{protocol}
This can be generalized to multiple hidden and public messages. 






\newpage
\subsection{Two-Party Secret Sharing Protocol}\label{pok-2party}

Building on our Pedersen commitment framework (\S\ref{sec:zkp-commitments}), we present a minimal two-party protocol for establishing shared secrets between a user (prover) and issuer. This construction provides the basis for sybil-resistant credential issuance while maintaining privacy.

% \subsubsection{Protocol Definition}


\begin{protocol}{Two-Party Secret Sharing with Zero Knowledge}{two-party-secret}
\textbf{Parties:} User $\mathcal{U}$, Issuer $\mathcal{I}$\\
\textbf{Public Parameters:} Generators $g_1, g_2, h \in \mathbb{G}$, public identifier $\textsf{id}$\\
\textbf{Goal:} Establish $s = s_1 + s_2$ where $\mathcal{U}$ contributes $s_1$, $\mathcal{I}$ contributes $s_2$

\begin{enumerate}
    \item \textbf{Commitment Phase:}
    \begin{itemize}
        \item $\mathcal{U}$ chooses $s_1 \sample \Z_p$, randomness $r \sample \Z_p$, computes:
        \[
        \cm_1 = \textsf{CM.Com}([0, s_1]; a) = g_1^0 g_2^{s_1} h^r
        \]
        and proves in ZKPoK: 
        \[
        \mathcal{R} = \left\{ (\cm_1, (s_1, r)) \mid \cm_1 = g_1^{m_1}g_2^{s_1} h^r \land m_1 = 0 \land s_1 \neq 0 \right\}
        \]
        
        \item $\mathcal{I}$ verifies $\mathcal{R}$, chooses $s_2 \sample \Z_p$, computes:
        \[
        \cm_2 = \textsf{CM.Com}([\textsf{id}, s_2]; 0) = g_1^{\textsf{id}} g_2^{s_2}
        \]
    \end{itemize}
    
    \item \textbf{Aggregation:} Compute combined commitment:
    \[
    \cm = \cm_1 \cdot \cm_2 = g_1^{\textsf{id}} g_2^{s_1 + s_2} h^r
    \]
    $\mathcal{I}$ returns $\cm, \cm_2, s_2$ to $\mathcal{U}$
    \item \textbf{Verification:} $\mathcal{U}$ verifies:
    \[
    \textsf{CM.Open}(\cm, (\textsf{id}, s); r) = \textsf{CM.Open}(\cm_1 \cdot \cm_2, (\textsf{pid}, s_1 + s_2); r)
    \]
    
    \item \textbf{Reconstruction:} The shared secret is $s = s_1 + s_2$ where $\mathcal{I}$ only knows $s_2$.
    
\end{enumerate}
\end{protocol}



\subsubsection{Security Properties}
\begin{itemize}
    \item \textbf{Hiding:} For $\mathcal{U}$: $\rcm_1$ hides $s_1$ under DDH. For $\mathcal{I}$: $\rcm_2$'s structure binds to $\textsf{pid}$ without randomness.
    
    \item \textbf{Binding:} The ZKPoK on $\rcm_1$ prevents $\mathcal{U}$ from choosing $s_1 = 0$. Linear composition ensures:
    \[
    \Pr[\exists (s_1', a') \neq (s_1, a) : \rcm_1 = g_2^{s_1'} h^{a'}] \leq \textsf{negl}(\lambda)
    \]
    
    \item \textbf{Correctness:} If both parties follow the protocol, $s = s_1 + s_2$ is uniquely determined by:
    \[
    \log_{g_2}(\cm \cdot g_1^{-\textsf{id}} h^{-a}) = s_1 + s_2
    \]
\end{itemize}

\subsubsection{Application to Anonymous Credentials}
This protocol enables:
\begin{itemize}
    \item \textbf{Sybil Resistance:} The $\textsf{pid}$ binding prevents duplicate issuance
    \item \textbf{Selective Disclosure:} Users can prove $s \neq 0$ without revealing $s_1, s_2$
    \item \textbf{Unlinkability:} Multiple credentials with same $s$ remain unlinkable due to independent $a$
\end{itemize}















\subsection{Zero-Knowledge Proof of Non-Zero Secret}\label{pok-nonzero}
\label{subsec:zkp-nonzero}

To enforce \(s_1 \neq 0\) in Protocol ~\ref{prot:two-party-secret}, we extend the ZKPoK framework with an inverse existence argument.

\begin{protocol}{ZKPoK for \(s_1 \neq 0\)}{zkpok-nonzero}
\textbf{Common Input:} \(\rcm_1 = g_2^{s_1}h^a\)\\
\textbf{Prover Input:} \(s_1 \neq 0, a, t = s_1^{-1} \mod p\)
\begin{enumerate}
    \item \textbf{Commitment:}
    \begin{itemize}
        \item Prover samples \(\alpha, \beta, \gamma \sample \Z_p\)
        \item Computes \(T_1 = g_2^\alpha h^\beta\), \(T_2 = g_2^\gamma\)
        \item Sends \((T_1, T_2)\) to verifier
    \end{itemize}
    
    \item \textbf{Challenge:} Verifier sends \(c \sample \Z_p\)
    
    \item \textbf{Response:} Prover computes:
    \[
    z_1 = \alpha + c t, \quad z_2 = \beta + c a t, \quad z_3 = \gamma + c s_1
    \]
    Sends \((z_1, z_2, z_3)\)
    
    \item \textbf{Verification:} Check:
    \[
    g_2^{z_1}h^{z_2} \stackrel{?}{=} T_1 \rcm_1^c \quad \text{and} \quad g_2^{z_3} \stackrel{?}{=} T_2 g_2^c
    \]
\end{enumerate}
\end{protocol}

\subsubsection{Security Analysis}
\begin{itemize}
    \item \textbf{Completeness:} Follows from:
    \[
    g_2^{z_1}h^{z_2} = g_2^{\alpha + c t}h^{\beta + c a t} = T_1(g_2^{s_1}h^a)^{c t} = T_1\rcm_1^c
    \]
    \[
    g_2^{z_3} = g_2^{\gamma + c s_1} = T_2g_2^c
    \]
    
    \item \textbf{Special Soundness:} From two accepting transcripts \((c, z_1, z_2, z_3)\) and \((c', z_1', z_2', z_3')\):
    \[
    t = \frac{z_1 - z_1'}{c - c'}, \quad s_1 = \frac{z_3 - z_3'}{c - c'}, \quad a = \frac{(z_2 - z_2') - t(z_3 - z_3')}{c - c'}
    \]
    The existence of \(t = s_1^{-1}\) proves \(s_1 \neq 0\)
    
    \item \textbf{HVZK:} Simulator \(\mathcal{S}\) on input \(c\):
    \begin{enumerate}
        \item Samples \(z_1, z_2, z_3 \sample \Z_p\)
        \item Computes \(T_1 = g_2^{z_1}h^{z_2}\rcm_1^{-c}\), \(T_2 = g_2^{z_3}g_2^{-c}\)
        \item Outputs \((T_1, T_2, c, z_1, z_2, z_3)\)
    \end{enumerate}
    Indistinguishable due to uniform sampling in \(\Z_p\)
\end{itemize}

\subsubsection{Protocol Integration}
Replace Step 1(a) in Protocol~\ref{prot:two-party-secret} with:
\begin{itemize}
    \item Prove \(\mathcal{R}_1' = \{(\rcm_1, (s_1, a, t)) \mid \rcm_1 = g_2^{s_1}h^a \land s_1 \cdot t \equiv 1 \mod p\}\)
    \item Issuer verifies both commitment structure and inverse relationship
\end{itemize}

\subsubsection{Implications}
\begin{itemize}
    \item \textbf{Sybil Resistance:} Prevents \(s_1 = 0\) trivial solutions
    \item \textbf{Compatibility:} Maintains \(\Sigma\)-protocol structure for composition
\end{itemize}






\subsection{Equality Proofs Across Multiple Commitments}\label{pok-eq}
In many scenarios, $\Prover$ will want to prove that they have a message consistent across their credentials. For example, a consistent user id $\textsf{id}$, the proof will attest that the prover is the owner of all credentials. The protocol is presented as a commitment to a single attribute $m_i$ and randomness $r_i$, however the protocol is generalized to any length message vector and the message being in any position, held secure by the commitments position binding property.

\[
\mathcal{R}_{\mathsf{eq}} = \left\{ 
    \big((\cm_1, \cm_2), (m_1, r_1, r_2)\big) \; 
    \Big| \; 
    \cm_1 = g^{m_1}h^{r_1} \, \land \, \cm_2 = g^{m_1}h^{r_2} 
\right\}.
\]


\begin{protocol}{Equality of Secret Exponents between Commitments}{multi-commit-eq}
\textbf{Common Input:} Commitments $\{\cm_i = g^{m_i}h^{r_i}\}_{i=1}^k$\\
\textbf{Prover Input:} $\{m_i, r_i\}$ with $m_1 = \cdots = m_k = m$\\
\textbf{Relation:} $\mathcal{R}_{\mathsf{eq}} = \left\{(\{\cm_i\}, m, \{r_i\}) \mid \cm_i = g^m h^{r_i}\ \forall i\right\}$

\begin{enumerate}
    \item \textbf{Commitment:}
    \begin{itemize}
        \item For each $i$, prover samples $\alpha_i, \rho_i \sample \Z_p$
        \item Compute $T_i \gets g^{\alpha_i}h^{\rho_i}$, send $\{T_i\}$ to verifier
    \end{itemize}
    
    \item \textbf{Challenge:} Verifier sends $c \sample \Z_p$
    
    \item \textbf{Response:}
    \begin{itemize}
        \item Compute $s \gets \alpha_1 + c m$ and $u_i \gets \rho_i + c r_i$ for all $i$
        \item Send $(s, \{u_i\})$
    \end{itemize}
    
    \item \textbf{Verification:} For each $i$:
    \[
    g^s h^{u_i} \stackrel{?}{=} T_i \cdot \cm_i^c
    \]
\end{enumerate}
\end{protocol}


\paragraph{Security Analysis:}
\begin{itemize}
    \item \textbf{Soundness:} Extractor obtains $m = \frac{s - s'}{c - c'}$ from two transcripts, proving $m_i = m\ \forall i$
    \item \textbf{ZK:} Simulator chooses $s, \{u_i\} \sample \Z_p$, computes $T_i = g^s h^{u_i} \cm_i^{-c}$
\end{itemize}

\paragraph{Integration with Previous Protocols:}
Combine with Protocol~\ref{prot:linear-proof} to prove both equality and linear relationships simultaneously:





\begin{protocol}{Signature of Knowledge for PS Signatures}{sok-ps}
\textbf{Common Input:} $(\vk, \cm, \widetilde{\sigma})$ where $\widetilde{\sigma} = (\widetilde{\sigma_1}, \widetilde{\sigma_2})$\\
\textbf{Prover Input:} $(r, \{m_i\}_{i=1}^\ell)$ such that $\cm = g^r \prod_{i=1}^\ell g_i^{m_i}$

\begin{enumerate}
    \item \textbf{Commitment:} Prover samples $\alpha, \{\beta_i\}_{i=1}^\ell \sample \Z_p$ and computes:
    \[
        T_1 \gets g^\alpha \prod_{i=1}^\ell g_i^{\beta_i}
    \]
    Send $T_1$ to verifier.
    
    \item \textbf{Challenge:} Verifier samples $c \sample \Z_p$ and sends to prover.
    
    \item \textbf{Response:} Prover computes:
    \[
        s_r \gets \alpha + c \cdot r \quad \text{and} \quad s_i \gets \beta_i + c \cdot m_i \text{ for } i \in [1,\ell]
    \]
    Send $(s_r, \{s_i\}_{i=1}^\ell)$ to verifier.
    
    \item \textbf{Verification:} Verifier checks:
    \begin{align*}
        g^{s_r}\prod_{i=1}^\ell g_i^{s_i} &\stackrel{?}{=} T_1 \cdot \cm^c\\
        e(g, \widetilde{\sigma_2}) &\stackrel{?}{=} e(\vk \cdot \cm, \widetilde{\sigma_1})
    \end{align*}
\end{enumerate}
\end{protocol}



\subsection{Signature of Knowledge with Rerandomizable PS Signatures}\label{pok-ps}
Given the rerandomizable signature scheme
\begin{itemize}
    \item $\mathsf{CM.Setup:} \ck \gets (g, (g_1,\ldots,g_\ell), \tilde{g}, (\tilde{g}_1,\ldots,\tilde{g}_\ell))$

    \item $\mathsf{RS.KeyGen:} (\widetilde{\sk}, \vk) \gets (\tilde{g}^x, g^x)$, return $(\widetilde{\sk}, \vk))$
    
    \item $\mathsf{RS.Sign:}$ $\widetilde{\sigma} \in \G_2 \gets (\widetilde{\sigma_1}, \widetilde{\sigma_2}) = (\tilde{h}, (\tilde{\sk} \cdot \widetilde{\cm})^u)$
    
    \item $\mathsf{RS.Ver}(\vk, \cm, \widetilde{\sigma}) \to \bit:$ 
    \[
    e(g, \widetilde{\sigma_2}) = e(\mathsf{vk} \cdot \mathsf{cm},\widetilde{\sigma_1}) \quad \wedge \quad \pi \gets \mathsf{PoK}\{(r , m_1,\ldots,m_\ell): \cm = g^r \prod_{i=1}^\ell g_i^{m_i}
    \]
\end{itemize}

We want to prove the following relation

    \[
    \mathcal{R} = \left\{(\cm, \widetilde{\sigma}), (r, \{m_i\}) \quad \left| \quad
    \begin{aligned}
        e(g, \widetilde{\sigma_2}) = e(\mathsf{vk} \cdot \mathsf{cm},\widetilde{\sigma_1}) \quad \wedge \quad
        \cm = g^r \prod_{i=1}^\ell g_i^{m_i} \\
    \end{aligned}\right.\right\}
    \]



\paragraph{Security Properties:}
This -protocol satisfies:

\begin{itemize}
    \item \textbf{Special Soundness:} 
    Consider two accepting transcripts for the same first message:
    \[
    (T_1, c, s_r, \{s_i\}) \quad \text{and} \quad (T_1, c', s_r', \{s_i'\})
    \]
    with $c \neq c'$. From the verification equations:
    \[
    g^{s_r}\prod_{i=1}^\ell g_i^{s_i} = T_1 \cdot \cm^c \quad \text{and} \quad
    g^{s_r'}\prod_{i=1}^\ell g_i^{s_i'} = T_1 \cdot \cm^{c'}
    \]
    
    Dividing these equations:
    \[
    g^{s_r - s_r'}\prod_{i=1}^\ell g_i^{s_i - s_i'} = \cm^{c-c'}
    \]
    
    Since $s_r = \alpha + cr$ and $s_i = \beta_i + cm_i$, we can extract:
    \[
    r = \frac{s_r - s_r'}{c - c'} \quad \text{and} \quad
    m_i = \frac{s_i - s_i'}{c - c'} \text{ for } i \in [1,\ell]
    \]
    
    \item \textbf{HVZK:} We construct simulator $\mathcal{S}$ as follows:
    \begin{enumerate}
        \item On input $(\cm, c)$, sample $s_r, \{s_i\} \sample \Z_p$
        \item Compute commitment:
        \[
            T_1 \gets g^{s_r}\prod_{i=1}^\ell g_i^{s_i} \cdot \cm^{-c}
        \]
        \item Output $(T_1, c, s_r, \{s_i\})$
    \end{enumerate}
    
    The simulated transcript is perfectly indistinguishable from real transcripts because:
    \begin{itemize}
        \item In real protocol: $s_r = \alpha + cr$ and $s_i = \beta_i + cm_i$ where $\alpha, \beta_i$ are uniform
        \item Thus real responses are uniform in $\Z_p$, matching simulator's distribution
        \item $T_1$ is uniquely determined in both cases by verification equation
    \end{itemize}
\end{itemize}




















































\newpage




\section{Sybil Resistance via VRF with Committed Attributes}
Anonymous Credential systems have the paradoxical problem of requiring user privacy but preventing sybil attacks where users create multiple credentials. Traditional Sybil resistance mechanisms often compromise user anonymity by revealing identifying information or relationships between credentials. Verifiable Random Functions (VRFs) offer a promising solution by enabling the generation of verifiably pseudorandom and deterministic nullifiers from user-specific information, suitable for presentation to an issuer or for revocation lists. Existing VRF-based schemes often rely on computationally intensive bilinear pairings or reveal user attributes, introducing overhead or privacy risks.

\noindent We improve the state of the art by creating a lightweight VRF construction tailored for Anonymous Credential systems with 3 contributions:
\begin{enumerate}
        \item \textbf{Pairing-Free VRF in Prime-Order Groups:} We adapt the Dodis-Yampolskiy VRF structure to function efficiently in standard prime-order groups, achieving provable pseudorandomness under the $q$-Diffie-Hellman Inversion ($q$-DHI) assumption.

        \item \textbf{Zero-Knowledge Proof of Multiplicative Inverse:} We introduce a novel $\Sigma$-protocol that proves the multiplicative inverse relation between committed values $m_1 = k + \textsf{ctx}$ and $m_2 = 1/m_1$, we use it in our scheme to verify the correctness of the VRF nullifier without revealing user secrets. We show it generalizes naturally for similar requirements in $\Sigma$-protocols, especially those needing to prove the q-DHI.

         \item \textbf{Formal Security Guarantees:} We demonstrate sybil resistance reduces to the security of our construction, the unique provability of the vrf and the soundness of our $\Sigma$-protocol.
\end{enumerate}
We first present the preliminaries and foundations of our VRF for committed inputs, the design of our $\Sigma$-protocol, and demonstrate how the integration achieves sybil resistance in anonymous credential systems.


\subsection{Problem}
To understand how we use the VRF within our application, we introduce the application:
Within our anonymous credential system, a user has a Master Credential with a VRF key $k$ and Context Credential with $\textsf{ctx}$, where $\textsf{ctx}$ is the context, such as $\mathcal{H}(\textit{"DriversLicense"})$ where $\mathcal{H}$ is hashes a string to $\Z_p$
\[
\cm_{\textsf{m}} = \mathsf{CM.Com}([k, \ldots]; r) = g_1^{k}\ldots h^r \quad \wedge \quad \cm_{\textsf{c}} = \mathsf{CM.Com}([\textsf{ctx}, \ldots]; r_2) = g_1^{\textsf{ctx}} \ldots h^{r_2}
\]
During Context Credential issuance, a user must prove to the issuer that their context credential hasn't been issued before, that is, the Context Credential issuance must be \emph{Sybil Resistant}. Our goal is to generate a unique, unlinkable nullifier for a specific context containing something in both the Master Credential and the Context Credential to protect the system from Sybil attacks while also retaining user privacy.

We leverage the structure and properties of the Dodis Yampolisky Verifiable Random Function (VRF)
\[
\text{Nullifier } \textsf{N} = g^{1/k + \textsf{ctx}}
\]

The Nullifier takes on the properties of correctness, pseudorandomness, and provable uniqueness from the VRF which we exploit in our protocol.


\subsection{Preliminaries}

\begin{definition}[q-DHI Assumption]
Let $\mathbb{G}$ be a cyclic group of prime order $p$ with generator $g$. The $q$-Diffie-Hellman Inversion ($q$-DHI) assumption \cite{mitsunari_new_2002} states that for any PPT adversary $\mathcal{A}$, there exists a negligible function $\negl$ such that:
\[
\Pr\left[ x \sample \Zp^*, \quad \mathcal{A}(g, g^x, g^{x^2}, \ldots, g^{x^q}) = g^{1/x} \right] \leq \negl 
\]
where the probability is taken over the random choice of $x$ and the random coins of $\mathcal{A}$. Informally, no $\PPT$ adversary can distinguish between $g^{1/\alpha}$ from a random group element.
\end{definition}

\begin{remark}
The $q$-DHI assumption is equivalent to the $(q+1)$-generalized Diffie-Hellman assumption (GDH) as shown by Boneh and Boyen \cite{kanade_efficient_2004}. This equivalence provides a solid theoretical foundation for our VRF construction's security.
\end{remark}




\begin{definition}[Verifiable Random Function in Prime-Order Group]
A Verifiable Random Function (VRF) in prime-order group $\G$ of order $q$ is a tuple of PPT algorithms $(\mathsf{VRF.Gen}, \mathsf{VRF.Eval}, \mathsf{VRF.Vfy})$ with associated message space $\setX$, output space $\setN$, and proof space $\Pi$, defined as:

\begin{itemize}
    \item $\mathsf{VRF.Gen}(1^\lambda) \to (sk, pk):$ Samples secret key $\alpha \sample \Zp^*$, computes public key $pk \gets g^\alpha$, returns $(sk = \alpha, pk)$
    
    \item $\mathsf{VRF.Eval}(sk, x) \to \textsf{N}, \pi:$ Returns output $\textsf{N} \gets g^{1/(x+sk)}$ and $\pi$ verifies the output $\textsf{N}$
    
    \item $\mathsf{VRF.Vfy}(pk, x, \textsf{N}, \pi) \to \bit:$ validates proof $\pi$ that $\textsf{N} = g^{1/(x+sk)}$, outputs 1 for success, 0 for failure
\end{itemize}
\end{definition}

\begin{itemize}
    \item \textbf{Correctness:} For all $(sk, pk) \gets \mathsf{VRF.Gen}(1^\lambda)$ and all $x \in \setX$:
    \[
    \Pr\left[\begin{aligned}
        (y, \pi) &\gets \mathsf{VRF.Eval}(sk, x) \\
        1 &\gets \mathsf{VRF.Vfy}(pk, x, \textsf{N}, \pi)
    \end{aligned}\right] = 1
    \]

    \item \textbf{Unique Provability:} For any $pk$ (possibly malicious) and $x \in \setX$, no $\PPT$ adversary $\AdvA$ can find two distinct pairs of outputs $(\textsf{N}_0, \pi_0) \neq (\textsf{N}_1, \pi_1)$ such that:
    \[
    \mathsf{VRF.Vfy}(pk, x, \textsf{N}_0, \pi_0) = \mathsf{VRF.Vfy}(pk, x, \textsf{N}_1, \pi_1) = 1
    \]

    \item \textbf{Pseudorandomness:} For every PPT adversary $\advA$, there exists negligible function $\negl$ such that:
    \[
    \left|\Pr\left[\mathsf{Exp}_{\mathsf{VRF}}^{\mathsf{PR}}(\AdvA, \lambda) = 1\right] - \frac{1}{2}\right| \leq \negl
    \]
    where the pseudorandomness experiment $\mathsf{Exp}_{\mathsf{VRF}}^{\mathsf{PR}}$ is defined in the standard framework for VRFs.
\end{itemize}


\subsection{Algebraic Analysis of Dodis Yampolskiy VRF}
We first recall the classical Dodis Yampolskiy VRF construction with bilinear pairings, we demonstrate with Type-3 pairings as they are generally used in practice. Let $\G_1, \G_2, \G_T$ be groups of a bilinear map with prime order $p$ where $g_1, g_2$ are generators for $\G_1, \G_2$ respectively and $e$ is an efficient map from $\G_1 \times \G_2 \to \G_T$:

\begin{itemize}
    \item $\mathsf{VRF.Gen}(\secparam)$: Samples $k \sample \Z_p$, set $pk = g^k$ 
    
    \item $\mathsf{VRF.Eval}(k, \textsf{ctx}) \to $(\mathsf{N}, \pi)$: $\pi = e(g_1, g_2)^{1/(k + \textsf{ctx})}$, $\mathsf{N} = g_2^{1/(k + \textsf{ctx})}$ 
    
    \item $\mathsf{VRF.Vfy}(pk, \textsf{ctx}, \mathsf{N}, \pi) \to \bit$: assert $\quad$ $e(g^{\textsf{ctx}} \cdot pk, \mathsf{N})  \stackrel{?}{=} e(g_1, g_2) \quad \wedge \quad \pi  \stackrel{?}{=} e(g_1, \mathsf{N})$
\end{itemize}

$\mathsf{Eval}$ computes the nullifier $\textsf{N}$ and generates a proof $\pi$ to prove that anyone in possession of $pk$ and the input $\textsf{ctx}$ can verify $\textsf{N}$ was computed correctly. $\mathsf{Vfy}$ resembles a signature verification as it binds  the public key $pk$, input $\textsf{ctx}$, and nullifier output together. 

The first pairing binds the public input $pk, \mathsf{ctx}$ with $\mathsf{N}$
\begin{align*}
    e(g_1^\mathsf{ctx} \cdot pk, \mathsf{N})  \quad  \stackrel{?}{=}& \quad  e(g_1, g_2) \\
    e(g_1^\mathsf{ctx}, g_2^{1/(k + \mathsf{ctx})}) \cdot  e(pk, g_2^{1/(k + \mathsf{ctx})}) \quad  \stackrel{?}{=}& \quad  e(g_1, g_2) \\
    e(g_1^\mathsf{ctx}, g_2)^{1/(k + \mathsf{ctx})} \cdot  e(g_1^k, g_2)^{1/(k + \mathsf{ctx})} \quad  \stackrel{?}{=}& \quad  e(g_1, g_2) \\
    e(g_1, g_2)^{\mathsf{ctx}/(k + \mathsf{ctx})} \cdot  e(g_1^k, g_2)^{k/(k + \mathsf{ctx})} \quad  \stackrel{?}{=}& \quad  e(g_1, g_2) \\
    e(g_1, g_2)^{\mathsf{ctx} + k/(k + \mathsf{ctx})}  \quad =& \quad e(g_1, g_2) \\
\end{align*}

\begin{align*}
     \pi  \quad  \stackrel{?}{=}& \quad e(g_1, \mathsf{N}) \\
     e(g_1, g_2)^{1/(k + \textsf{ctx})}  \stackrel{?}{=}& \quad  e(g_1, g_2^{1/(k + \mathsf{ctx})}) \\
     e(g_1, g_2)^{1/(k + \textsf{ctx})}  \stackrel{?}{=}& \quad  e(g_1, g_2)^{1/(k + \textsf{ctx})} \\
\end{align*}

And the second pairing binds the proof $\pi$ to \mathsf{N}$

\subsubsection{Informal Security analysis of Bilinear Pairing VRF}
\begin{itemize}
    \item \textbf{Correctness:} Follows directly from pairing properties. The algebraic structure ensures verification equations hold when computed honestly.
    
    \item \textbf{Unique Provability:} Each nullifier $\mathsf{N} = g_2^{1/(k+\textsf{ctx})}$ is uniquely determined by the pairing equation $e(g_1^{k + \textsf{ctx}}, \mathsf{N}) = e(g_1, g_2)$. A forgery requires solving DLOG to create  $g_2^{1/(k+\textsf{ctx}')} = \mathsf{N}$.
    
    \item \textbf{Pseudorandomness:} Relies on the $q$-DHI assumption in bilinear groups. Given $g_1, g_1^k, g_1^{k^2}, \ldots$, distinguishing $\mathsf{N} = g_2^{1/(k+\textsf{ctx})}$ from random reduces to computing $g_2^{1/k}$ (a $q$-DHI instance).
\end{itemize}



\subsection{VRF with Committed Inputs}
As demonstrated above, the classical Dodis-Yampolskiy VRF uses pairings to verify the relationship between inputs and outputs through the equation: $e(g_1^{\textsf{ctx}} \cdot pk, \mathsf{N}) = e(g_1, g_2)$. Our key insight is that this pairing equation fundamentally verifies a multiplicative relationship. When we expand the left side: $e(g_1^{\textsf{ctx}} \cdot g_1^k, g_2^{1/(k + \textsf{ctx})}) = e(g_1, g_2)$ we are effectively proving that $(k + \textsf{ctx}) \cdot \frac{1}{k + \textsf{ctx}} = 1$. 

This observation suggests an alternative approach: instead of using pairings to verify this relationship, we can prove it directly through a carefully constructed $\Sigma$-protocol. Let:
\begin{itemize}
    \item $m_1 = k + \textsf{ctx}$ (committed in $\cm_1$)
    \item $m_2 = \frac{1}{k + \textsf{ctx}}$ (committed in $\cm_2$)
\end{itemize}

The VRF nullifier is then simply $\mathsf{N} = g^{m_2}$, and verification reduces to proving:
\begin{enumerate}
    \item $m_1$ is correctly formed from committed values $k$ and $\textsf{ctx}$
    \item $m_1 \cdot m_2 = 1$ (multiplicative inverse relation)
    \item $\mathsf{N} = g^{m_2}$ (nullifier structure)
\end{enumerate}

This reformulation eliminates the need for pairings while maintaining the security properties of the original VRF. The challenge now becomes constructing an efficient $\Sigma$-protocol that proves these relationships without revealing the underlying values.



\subsection{Commitment Structure for VRF Verification}
To privately prove the VRF relationship, we commit to both the input relationship and multiplicative inverse:

\begin{itemize}
    \item Primary commitments to inputs:
        \[\cm_k = g^k h^{r_1}, \quad \cm_{\textsf{ctx}} = g^{\textsf{ctx}} h^{r_2}\]
    
    \item Derived commitment to their sum:
        \[\cm_3 = \cm_k^{\textsf{ctx}} h^{r_3}
    
    \item Commitment to the inverse:
        \[\cm_4 = \cm^{m_2} h^{r_4} \text{ where } m_2 = \frac{1}{m_1}\]
\end{itemize}

The algebraic structure of these commitments enables our $\Sigma$-protocol to efficiently prove the multiplicative inverse relationship while maintaining zero-knowledge.


\subsection{$\Sigma$-Protocol Construction}
Given these commitments, we construct a $\Sigma$-protocol that proves the VRF relationship in zero-knowledge. The protocol leverages auxiliary commitments $\cm_3, \cm_4$
to enforce the multiplicative inverse relationship: $\Pi^{\mathcal{R}_{\textsf{VRF}}}$ from 

    \[
        \mathcal{R}_{\mathsf{vrf}} = \left\{ (\cm_k, \cm_{\textsf{ctx}}, \mathsf{N}), (k, \textsf{ctx}, r_1, r_2) \; \Big| \;  \cm_k = g^k h^{r_1} \; \land \;
                \cm_{\textsf{ctx}} = g^{\textsf{ctx}} h^{r_2} \land \textsf{N} = g^{1/(k + \textsf{ctx})} \right\}
    \]



\newpage
\begin{protocol}{VRF Output Verification}{vrf-verify}\label{pok-vrf}
\textbf{Common Input:} Commitments $\cm_1, \cm_2$, group generator $g$, and public parameters $h \in \G$\\
\textbf{Prover Input:} Witness $(m_1, m_2, r_1, r_2, r_3, r_4)$ such that:
\begin{itemize}
    \item $\cm_1 = g^{m_1}h^{r_1}$ and $\cm_2 = g^{m_2}h^{r_2}$
    \item $\cm_3 = \cm_1^{m_2}h^{r_3}$ and $\cm_4 = h^{r_4}$
    \item $m_1 \cdot m_2 = 1$ (multiplicative inverse relation)
\end{itemize}

\begin{enumerate}
    \item \textbf{Commitment:} Prover samples randomness:
    \[
        \alpha_1, \alpha_2, \rho_1, \rho_2, \rho_3, \rho_4 \sample \Z_q
    \]
    Computes:
    \begin{itemize}
        \item $T_1 \gets g^{\alpha_1}h^{\rho_1}$
        \item $T_2 \gets g^{\alpha_2}h^{\rho_2}$
        \item $T_3 \gets \cm_1^{\alpha_2}h^{\rho_3}$
        \item $T_4 \gets h^{\rho_4}$
    \end{itemize}
    Sends $(T_1, T_2, T_3, T_4)$ to verifier.
    
    \item \textbf{Challenge:} Verifier samples $c \sample \Z_q$ and sends to prover.
    
    \item \textbf{Response:} Prover computes:
    \begin{align*}
        s_1 &\gets \alpha_1 + c \cdot m_1 &u_1 &\gets \rho_1 + c \cdot r_1\\
        s_2 &\gets \alpha_2 + c \cdot m_2 &u_2 &\gets \rho_2 + c \cdot r_2\\
        u_3 &\gets \rho_3 + c \cdot r_3 &u_4 &\gets \rho_4 + c \cdot r_4
    \end{align*}
    Sends $(s_1, s_2, u_1, u_2, u_3, u_4)$ to verifier.
    
    \item \textbf{Verification:} Verifier checks:
    \begin{enumerate}[label=(\roman*)]
        \item $g^{s_1}h^{u_1} \stackrel{?}{=} T_1 \cdot \cm_1^c$
        \item $g^{s_2}h^{u_2} \stackrel{?}{=} T_2 \cdot \cm_2^c$
        \item $\cm_1^{s_2}h^{u_3} \stackrel{?}{=} T_3 \cdot \cm_3^c$
        \item $h^{u_4} \stackrel{?}{=} T_4 \cdot \cm_4^c$
        \item $\frac{\cm_3}{\cm_4} \stackrel{?}{=} g$
    \end{enumerate}
\end{enumerate}
\end{protocol}

\paragraph{Security Analysis:}
The protocol satisfies the following security properties:

\begin{itemize}
    \item \textbf{Completeness:} For honest prover and verifier, all verification equations hold algebraically:
    \begin{align*}
        g^{s_1}h^{u_1} &= g^{\alpha_1 + cm_1}h^{\rho_1 + cr_1} = T_1 \cdot \cm_1^c\\
        g^{s_2}h^{u_2} &= g^{\alpha_2 + cm_2}h^{\rho_2 + cr_2} = T_2 \cdot \cm_2^c\\
        \cm_1^{s_2}h^{u_3} &= \cm_1^{\alpha_2 + cm_2}h^{\rho_3 + cr_3} = T_3 \cdot \cm_3^c\\
        h^{u_4} &= h^{\rho_4 + cr_4} = T_4 \cdot \cm_4^c
    \end{align*}
    
    \item \textbf{Special Soundness:} Given two accepting transcripts $(T_1, T_2, T_3, T_4, c, s_1, s_2, u_1, u_2, u_3, u_4)$ and $(T_1, T_2, T_3, T_4, c', s_1', s_2', u_1', u_2', u_3', u_4')$ with $c \neq c'$, the extractor $\mathcal{E}$ works as follows:
    \begin{align*}
        m_1 &= \frac{s_1 - s_1'}{c - c'} &r_1 &= \frac{u_1 - u_1'}{c - c'}\\
        m_2 &= \frac{s_2 - s_2'}{c - c'} &r_2 &= \frac{u_2 - u_2'}{c - c'}\\
        r_3 &= \frac{u_3 - u_3'}{c - c'} &r_4 &= \frac{u_4 - u_4'}{c - c'}
    \end{align*}
    The extracted witness satisfies all verification equations and the multiplicative inverse relation by the binding property of Pedersen commitments.
    
    \item \textbf{Honest-Verifier Zero-Knowledge:} The simulator $\mathcal{S}$ operates as follows:
    \begin{enumerate}
        \item Sample $s_1, s_2, u_1, u_2, u_3, u_4 \sample \Z_q$ uniformly
        \item Compute simulated commitments:
        \begin{align*}
            T_1 &\gets g^{s_1}h^{u_1} \cdot \cm_1^{-c}\\
            T_2 &\gets g^{s_2}h^{u_2} \cdot \cm_2^{-c}\\
            T_3 &\gets \cm_1^{s_2}h^{u_3} \cdot \cm_3^{-c}\\
            T_4 &\gets h^{u_4} \cdot \cm_4^{-c}
        \end{align*}
        \item Output $(T_1, T_2, T_3, T_4, c, s_1, s_2, u_1, u_2, u_3, u_4)$
    \end{enumerate}
    The simulated transcript is perfectly indistinguishable from a real transcript as the distribution of responses $(s_1, s_2, u_1, u_2, u_3, u_4)$ is uniform in both cases, and the commitments are uniquely determined by the verification equations.
\end{itemize}

\paragraph{Connection to VRF Security}  
The protocol’s soundness guarantees that $\textsf{N} = g^{m_2}$ is valid only if $m_2 = 1/m_1$ for $m_1 = k + \textsf{ctx}$. This is critical because:
\begin{itemize}
    \item \textbf{Pseudorandomness:} Under $q$-DHI, $g^{1/m_1}$ is indistinguishable from random without knowledge of $m_1$.
    \item \textbf{Uniqueness:} The equation $m_1 \cdot m_2 = 1$ has a unique solution in $\Zp^*$, preventing adversarial equivocation.
\end{itemize}
Thus, the security of the VRF directly reduces to the hardness of computing discrete logarithms and the soundness of the inverse proof.




\begin{theorem}[VRF Correctness via Multiplicative Inverses]
Under the discrete logarithm assumption, proving the equality $m_1 \cdot m_2 = 1$ for commitments $\cm_1 = g^{m_1}h^{r_1}$ and $\cm_2 = g^{m_2}h^{r_2}$ is equivalent to verifying the correctness of the VRF output $\textsf{Nullifier} = g^{m_2}$. Specifically:
\begin{itemize}
    \item Completeness: A valid VRF output always satisfies $m_1 \cdot m_2 = 1$.
    \item Soundness: Any adversary forging a nullifier must break either the binding of the commitments or the $q$-DHI assumption.
\end{itemize}
\end{theorem}

\begin{proof}[Sybil Resistance Sketch]
\begin{itemize}
    \item \textbf{Uniqueness:} Direct consequence of the VRF’s unique provability. If two nullifiers $\textsf{N}_0, \textsf{N}_1$ exist for the same $(k, \textsf{ctx})$, then $m_1 \cdot m_2^{(0)} = m_1 \cdot m_2^{(1)} = 1$, violating the uniqueness of inverses in $\Zp^*$.
    
    \item \textbf{Unlinkability:} Follows from the zero-knowledge property of the $\Sigma$-protocol. The proof reveals only the validity of $m_1 \cdot m_2 = 1$, not $m_1$ or $m_2$.
    
    \item \textbf{Soundness:} By the extractability of the $\Sigma$-protocol, any valid nullifier must satisfy $\textsf{N} = g^{1/(k + \textsf{ctx})}$. Binding of Pedersen commitments ensures $m_1 = k + \textsf{ctx}$, thus $\textsf{N}$ is uniquely tied to the credentials.
\end{itemize}
\end{proof}


\subsection{Performance Evaluation}

Dodis Yampolskiy
\begin{itemize}
    \item Gen = 1 exponentiation 
    \item GT exponentiation, g2 exponentiation 
    \item 1 g1 mul + 2 pairing + 2 GT equality check
\end{itemize}

UTT


Us
cm3 = g^m1h^r3
cm4 = 



















































% Let $\G$ be a prime-order group with Pedersen commitments $\cm_1 = g^{m_1}h^{r_1}$, $\cm_2 = g^{m_2}h^{r_2}$. We construct a Σ-protocol to prove $m_1 \cdot m_2 = 1 \mod p$ without revealing $m_1, m_2, r_1, r_2$.

% % protocol here

% \subsubsection{Security Intuition}
% \begin{itemize}
%     \item \textbf{Completeness:} Honest executions satisfy all verification equations by algebraic design.
%     \item \textbf{Soundness:} Extracting $m_1, m_2$ from two transcripts forces $m_1 \cdot m_2 = 1$ (via binding of Pedersen commitments).
%     \item \textbf{Zero-Knowledge:} Simulated transcripts are indistinguishable due to masked randomness.
% \end{itemize}






% \subsubsection{VRF Verification via sigma-Protocol}
% The sigma-protocol replaces pairing-based checks in two ways:
% \begin{itemize}
%     \item \textbf{Nullifier Binding:} Instead of pairing equations, the protocol enforces $\textsf{N} = g^{m_2}$ where $m_2 = 1/m_1$ and $m_1 = k + \textsf{ctx}$.
%     \item \textbf{Uniqueness:} The extractor ensures only one valid $\textsf{N}$ per $(k, \textsf{ctx})$, analogous to pairing-derived uniqueness.
% \end{itemize}

% \subsubsection{Pseudorandomness Under q-DHI}
% Pseudorandomness of $\textsf{N} = g^{1/(k+\textsf{ctx})}$ now reduces directly to the $q$-DHI assumption in prime-order groups, mirroring the bilinear case but without pairings. Adversaries cannot distinguish $\textsf{N}$ from random unless they solve $g^{1/\alpha}$ for $\alpha = k + \textsf{ctx}$.














% % % % % % % % % % 
% 
% END Sigma Protocols
% 
% % % % % % % % % % 















% % % % % % % % % % 
% 
% Private Identity System from MIMC-ABC
% 
% % % % % % % % % % 



\cleardoublepage
\section{Private Identity System from MIMC-ABC}\label{sec:idsys}

Our identity system establishes a secure framework for issuing and managing privacy-preserving credentials across multiple authorities while maintaining accountability. The system involves four key entities: users, credential oracles (which verify and attest to user attributes), auditor (who manage revocation), and credential verifiers.

\noindent At the core of our system is a master credential issued by a government credential oracle, which serves as a root of trust. This credential contains two crucial committed elements: a secret identifier $s$ that enables secure credential linking, and a committed VRF key $k$ that generates context-specific nullifiers. These nullifiers serve dual purposes: preventing Sybil attacks at credential oracles and enabling efficient revocation. During master credential issuance, the VRF key is verifiably encrypted, the ciphertext is stored in the government system which associates a plaintext user profile to their ciphertext for revocation.


\noindent Users can obtain context credentials from various credential oracles by proving possession of a valid, unrevoked master credential and deriving a unique nullifier using their VRF key and the credential context. This design allows credential oracles to restrict issuance to users with trusted government-issued credentials, ensuring their credentials are only issued to verified identities. The system supports expressive verification statements that can combine attributes across multiple credentials. Since master credentials are government-issued and require stringent security checks, verifiers can leverage this trust by incorporating master credential validity, expiration, and revocation checks into their verification statements, inheriting the strong security properties of government-issued credentials. This enables credential oracles to maintain trust by ensuring their credentials become unusable if the underlying government credential is revoked.


\noindent The system supports flexible revocation through two mechanisms: targeted revocation of specific credentials via their nullifiers, and complete revocation of all user credentials by recovering their VRF key through the auditors. Government systems can initiate revocation by using plaintext identifiers, with auditors managing the conversion to the appropriate nullifiers. This approach maintains privacy while enabling practical accountability and administration.

We use the Multi Issuer Multi Credential Anonymous Credential system to implement a privacy-preserving digital identity system

\subsection{Entities}
Our identity system involves users, credential issuers, auditors, and credential verifiers.

\noindent \textbf{User} ($\User$) holds a master credential $Cred_{master}$ and any number of context credentials $Cred_{ctx}$ in their identity wallet. The master credential contains a unique identifier $s$, a VRF key $k$, and additional attributes, and is issued by a government entity. Context credentials are issued by participating organizations like universities or licensing authorities.

\noindent \textbf{Credential Oracle} ($\MCO, \CCO$) verifies user identity and issues digital credentials. The Master Credential Oracle $\MCO$ operates with keypair $(SK_{m}, PK_{m})$ for issuing "root" credentials, while Context Credential Oracles $\CCO$ use $(SK_{c}, PK_{c})$ for issuing domain-specific credentials.

\noindent \textbf{Auditor} ($\Auditor$) consists of a threshold of nodes holding encryption and accumulator keypairs; for simplicity, we refer to both as $(sk_A, pk_A)$. Users encrypt their VRF keys under the auditors' public key, as in key escrow schemes. Auditors can decrypt this key during revocation. The Auditor updates the revocation list. 

\noindent \textbf{Verifier} ($\Verifier$) represents any party wishing to verify a user's credentials.

\subsection{Data Objects}

We now describe the data objects that form our privacy-preserving decentralized identity system. At its core, a Master Credential serves as a root of trust, from which Context Credentials can be derived. During Context Credential issuance, users generate a deterministic nullifier unique to each context using their Master Credential's secrets and the context string, enabling privacy-preserving credential linking.

\subsubsection{Master Credential $Cred_m$}: 
A master credential is a high-security root credential issued by a government entity containing:

\begin{itemize}
    \item Identity string $s$: a unique identifier
    \item VRF key $k$: used to generate context-specific nullifiers
    \item Context type $ctx$: always set to "master" for master credentials
    \item Additional attributes $attrs$: including expiry date, date of birth, etc.
    \item Credential Structure:
    \begin{itemize}
        \item Master Commitment $C_m = Com([s, k, ctx, attrs],r)$: A Pedersen commitment to the credential attributes using randomness $r$
        \item Oracle signature $\sigma_m$: A rerandomizable signature over $C_m$, verifiable under $PK_m$
    \end{itemize}
\end{itemize}

\subsubsection{Master Credential Oracle Data Record:} Following successful master credential issuance, the oracle maintains a record containing:
\begin{itemize}
    \item Commitment-Signature Pair $(C_m, Cred_m)$:
    \begin{itemize}
        \item Master commitment $C_m = Com([s,k,ctx,attrs],r)$: the Pedersen commitment over credential attributes
        \item Oracle Signature $Cred_m$ The signature over commitment $C_m$
    \end{itemize}
    \item Key Encryption and Proof:
    \begin{itemize}
        \item Encrypted VRF Key $CT_k$: the encryption of the user's VRF key, encrypted with the Auditor's public key $Enc_{PK_a}(k)$
        \item Consistency proof $\Pi_{CT}$: The zero-knowledge proof that $CT_k$ encrypts the committed key $k$
    \end{itemize}
\end{itemize}


\subsubsection{Context Credential $Cred_c$}: 
A user interacts with the Context Credential oracle to obtain a context-specific credential, which contains:
\begin{itemize}
    \item Identity string $s$: The user's unique identifier from their master credential
    \item Nullifier $\tau$: A deterministic value generated from $(s, ctx)$
    \item Context string $ctx$: A hashed identifier of the credential type (e.g., $dmv$, $universityofsydney$)
    \item Attribute list $attrs$: Additional credential-specific information such as expiry date
    \item $\sigma_c$ the rerandomizable signature over $C_c$ from the context credential oracle that proves the user has been issued $Cred_c$ over $C_c$
    \item Credential Structure:
    \begin{itemize}
        \item Context commitment $C_c$: A Pedersen commitment $Com([s, \tau, ctx, attrs],r')$ to the credential attributes using randomness $r'$
        \item Oracle signature $\sigma_c$: A rerandomizable signature over $C_c$, verifiable under $PK_c$
    \end{itemize}
    
\end{itemize}


\subsubsection{Context Credential Oracle Data Record:} During credential issuance, the oracle maintains a record of the interaction containing:
\begin{itemize}
    \item Master Credential Verification: 
        \begin{itemize}
            \item Randomized credential $Cred_m'$: a rerandomized version of the master credential
            \item Randomized commitment $C_m'$: the corresponding rerandomized commitment
            \item Opening proof $\Pi_{ComOpen}$: Zero-knowledge proof of correct commitment opening
            \item Revocation proof $\Pi_{NonRevoked}$:  Zero-knowledge proof that the credential has not been revoked
        \end{itemize}
    \item Nullifier Components:
    \begin{itemize}
        \item Context nullifier $\tau$: The value $VRF(k,ctx)$ derived from the user's committed VRF key and credential context
        \item Derivation proof $\Pi_{\tau}$: Zero-knowledge proof establishing that
        \begin{itemize}
            \item The VRF computation is correct
            \item The key $k$ matches the one committed in $Cred_m$
            \item The context string $ctx$ is correctly incorporated
        \end{itemize}
    \end{itemize}
\end{itemize}

\subsubsection{Revocation List:} 
\begin{itemize}
    \item Accumulator Structure:
    \begin{itemize}
        \item Accumulator value $A$: The current state of the accumulator representing non-revoked credentials
        \item Secret key $sk_A$: The accumulator manager's key for updates
        \item Auxiliary information $aux$: Additional data needed for witness updates
    \end{itemize}
    \item Revoked Elements:
    \begin{itemize}
        \item Master revocations $k$: VRF keys of revoked master credentials
        \item Context revocations $\tau$: Nullifiers of revoked context credentials
        \item Timestamp $t$: Time of revocation
        \item Reason code $rc$: Justification for revocation
    \end{itemize}
    \item Witness Management:
    \begin{itemize}
        \item Non-membership witness $w$: Proof that a credential is not in the revocation set
        \item Update information $upd$: Data for users to update their witnesses after accumulator changes
    \end{itemize}
\end{itemize}

\betteridea{Notes on Threat/Trust model: threat model has issuer/verifier, trust model has credd oracle, auditor, etc. Keep consistent. Also, state what's out of scope e.g. network, physical, side-channel. domain in arke = context}

\subsubsection{Trust Model}
\begin{itemize}
    \item Credential Oracles: trusted to verify real-world identity before issuing credentials, they aren't trusted for privacy and may be compromised but can't issue credentials without the user participating in their protocol

    \item Auditors: are trusted to only decrypt user keys for legitimate revocation requests

    \item Network: communication assumed to be over encrypted channels, any storage is not trusted for credential contents
\end{itemize}

\subsubsection{Threat Model}
We assume the auditor maintaining the revocation cannot be corrupted.

\begin{itemize}
    \item Malicious Credential Oracle: A malicious credential oracle could "falsely issue attestations and impersonate any user it desires. Fortunately, recent work on authenticating web data has shown privacy-preserving, untrusted and correct credential oracles can be realized in practice [DECO, distefano, etc]. Additionally, we mitigate the threat level by confining each credential oracle to a unique domain." - from Arke. 
    \item Malicious User: attempts to obtain multiple credentials for the same context, tries to forge credentials or share them with others, attempts to link credentials with other credentials not issued to the same master secret key
    \item Malicious Issuer: attempts to link multiple showing, collude with issuers to deanonymize users, stores presentation proofs to track users
    \item Malicious Verifier: issue credentials without proper verification, attempts to track credential usage, colludes with issuers or other verifiers
\end{itemize}



\subsection{Syntax}
\todonote{Sam to update this to include master and context cred and revocation}

Syntax of Anonymous Identity System with Sybil Resistance and Revocation
\begin{itemize}
    \item $\mathsf{Setup}(\secparam) \to (\ppar, \UL, \RL)$ Takes security parameter $\lambda$ in unary, outputs public parameters $\ppar$, empty user list $\UL$ and revocation list $\RL$.

    \item $\mathsf{OrgKeygen}(\ppar, n) \torand (\osk, \opk)$: is a probabilistic algorithm that takes public parameters $\ppar$ and $n$ the upper bound of credential attributes. Outputs organisations keypair $(\osk, \opk)$

    \item $\mathsf{UserKeygen}(\secparam) \torand (\usk)$ is a probabilistic algorithm. Outputs user secret key $\usk$ consisting of PRF key $k$ and identity string $s$

    \item $(\mathsf{Obtain Master}(usk, \textbf{m}, aux), \mathsf{Issue Master}(osk, cm, aux)) \to cred:$ An interactive protocol. $Obtain$ is a probabilistic alrogithm run by a user, inputs secret key, credential attribute vector $\textbf{m}$ and auxiliary info. $Issue$ is a probabilistic algorithm run by an issuing organization that takes a commitment $cm$, issuers secret key $osk$, and auxiliary info. Outputs a credential $cred$ binding $cm$ to the issuer signature.

    \item $(\mathsf{Obtain Context}(usk, \textbf{m}, aux), \mathsf{Issue Context}(osk, cm, aux)) \to cred:$ An interactive protocol. $Obtain$ is a probabilistic alrogithm run by a user, inputs secret key, credential attribute vector $\textbf{m}$ and auxiliary info. $Issue$ is a probabilistic algorithm run by an issuing organization that takes a commitment $cm$, issuers secret key $osk$, and auxiliary info. Outputs a credential $cred$ binding $cm$ to the issuer signature.

    \item $(\mathsf{Show}(usk, cred, \phi), \mathsf{Verify}(cred', cm, \pi)) \to \bit$ An interactive protocol. $Show$ is a probabilistic algorithm run by a Prover. Takes secret key, credential, and predicate statement $\phi$. $Verify$ is a deterministic algorithm run by a verifier, takes a randomized credential and commitment $cred', cm'$ and proof $\pi$. Otuputs 1 if verification succeeds, otherwise 0.

    \item $\mathsf{Revoke}(\RL, k') \to \RL'$ revoke is a deterministic algorithm, updates revocation list with revoked key $k'$
\end{itemize}

\subsection{Security Model}
\begin{itemize}
    \item \textbf{Sybil resistance}: For any given context, no probabilistic polynomial time adversary can obtain more than 1 valid credential with non-negligible probability 
    
    \item \textbf{Revocability}: For any given context, no probabilistic polynomial time adversary use a revoked credential 
\end{itemize}

\subsubsection{Sybil Resistance}

\subsubsection{Revocation}
When $ra$ needs to revoke a user's credential/s (due to user request or credential provider request), $ra$ finds $escrow$ based on the user's $pid$, recall $ra$ has a user list $ul$ = $(pid, escrow)$ and requests the auditor $audit$ to decrypt $s \gets tpkdec_{ask}(escrow)$. $audit$ computes the nullifiers to add to the revocation accumulator. $nullif_{rcd} \gets PRF_s(pid)$ and for each context credential to revoke, $nullif_{ctxid} \gets PRF_s(ctxid)$. $audit$ updates the accumulator $acc' \gets Acc.Add(acc)$
If the registration credential requires revocation, $audit$ can compute each $nullif \gets PRF_{s}(ctxid) ; \forall ; ctxid ; \in ; ctxl$ and add $(nullif, timestamp, reason)$ to $rl$. For record-keeping, $ra$ stores Revocation Information $ri = (nullif, timestamp, reason)$ allowing $ra$ to track which credentials are revoked and why, $nullif$ in $rl$ ensures revoked credentials can't be verified.
During credential verification, verifiers check if a credential's nullifier appears in $rl$, if present, the verification fails.














\newpage
\section{Performance Evaluation}\label{sec:evaluation}
What is the takeaway message from the evaluation?
\begin{itemize}
    \item For non-private system, we enable privacy with little overhead. Our building block sigma protocol for private sybil resistance adds negligible overhead. 
    \item For private system, but better efficiency, we have a SOTA paper TACT/S3ID (in the comparison table). Their paper does multi-attribute/multi-issuer credentials (they issue 1 credential per attribute), but their benchmarks don't show the complexity in verifying credentials together, or proving statements about their credential which they say would have non-negligible impact and theirs is lower bound. For us, by using simpler and well-known construction, we are more efficient (need to test this but I think so due to their construction) and better functionality. 
\end{itemize}








\newpage
\section{Efficient Multi-Show Anonymous Credentials via Algebraic Decoupling}



\subsection{Introduction}
Privacy-preserving authentication systems require cryptographic primitives that allow users to prove certified attributes (e.g., citizenship, qualifications) without revealing additional information or enabling linkage across sessions. Anonymous credential schemes address this by encoding attributes into cryptographically randomized signatures, enabling users to generate unlinkable "showings" of credentials through zero-knowledge proofs (ZKPs). A critical challenge lies in balancing three properties: (1) multi-show unlinkability (proving attributes without correlating sessions), (2) selective disclosure (revealing subsets of attributes), and (3) practical efficiency for real-world deployment.

The problems in accountable privacy were first introduced by Chaum \cite{chaum_untraceable_1981, chaum1985security} and later formalized as the \emph{CL framework} \cite{goos_pseudonym_2000, goos_efficient_2001}, establishing the paradigm of encoding credentials as signatures over committed attributes. While early signature schemes lacked the algebraic structure to support efficient ZKPs and signature randomization, the advent of pairing-based cryptography \cite{goos_short_2001, hutchison_short_2004} coupled with commitment schemes and zero-knowledge proof systems enabled homomorphic rerandomization of credentials—allowing users to transform signatures into fresh, unlinkable versions while preserving validity.

\subsection{Evolution of Anonymous Credential Schemes}
The progression of anonymous credential schemes reflects a sustained effort to simplify the mathematical structures underlying zero-knowledge proofs:

\paragraph{CL Signatures \cite{cimato_signature_2003, hutchison_signature_2004}}
Built on early pairing-based constructions, CL credentials introduced homomorphic rerandomization but required linear-in-attributes pairing operations during proofs, limiting scalability for complex credentials.

\paragraph{BBS+ Signatures \cite{hutchison_constant-size_2006}}
Achieved constant-size credentials by intertwining message commitments with signatures. While \cite{camenisch_anonymous_2016} improved computational complexity, The signature leverages the q-SDH assumption \cite{boneh_short_2008}, requiring a mathematical structure that which intertwines the message and secret key $A^{\frac{1}{x+e}}$ which enables zkp statements but complicates proofs 

\paragraph{BBS+ Signatures \cite{hutchison_constant-size_2006}}
Achieved constant-size credentials through a structure where signatures take the form $A = (gh_0^s\prod_{i=1}^n h_i^{m_i})^{\frac{1}{e+x}}$. While \cite{camenisch_anonymous_2016} improved computational complexity, the signature structure necessitates complex blinding operations with inverse relationships ($r_3 = \frac{1}{r_1}$), cross-terms ($s' = s - r_2 \cdot r_3$), and complex equality checks during proof generation, e.g. 
\[
g = ((gh_0^s \prod_1^nh_i^{-m_i})^{r_1} \cdot h_0^{-r_2})^{r_3}h_0^{-s'}\prod_{i=1}^n h_i^{-m_i}
\]
This leads to a zero-knowledge proof relation involving multiple auxiliary variables and non-linear equations, complicating the implementation and composition of proofs across multiple credentials.


\paragraph{PS and PS\_UTT Signatures \cite{sako_short_2016, tomescu2022utt}}
Introduced separation between signature components and message commitments. The UTT variant further simplified rerandomization by decoupling attribute commitments from the core signature structure, enabling linear ZKP relations over Pedersen commitments. PS based signature rely on the LRSW assumption \cite{goos_pseudonym_2000} rather than BBS+ q-SDH which enables simpler algebraic structures, which we show now. 

\subsection{Cryptographic Foundations: q-SDH vs LRSW}

\subsubsection{q-SDH}
\begin{definition}[q-Strong Diffie-Hellman Assumption]
For any PPT adversary $\mathcal{A}$ and positive integer $q = \poly(\lambda)$, we say the $q$-SDH assumption holds if there exists a negligible function $\negl$ such that:
$$\Pr\left[\begin{array}{l}
    \BG = (p, \G_1, \G_2, \G_T, e, g, \tilde{g}) \sample \BGGen(1^\lambda) \\
    s \sample \Z_p \\
    (c, h) \sample \mathcal{A}(\BG, g, \tilde{g}, \tilde{g}^s, \ldots, \tilde{g}^{s^q})
\end{array} : e(h, \tilde{g}^s \cdot \tilde{g}^c) = e(g, \tilde{g})\right] \leq \negl$$
where $c \in \Z_p \setminus \{-s\}$.
\end{definition}


The choice between these shapes the proof complexity:

\paragraph{BBS+ and q-SDH Limitations}
The $q$-Strong Diffie-Hellman (q-SDH) assumption \cite{boneh_short_2008} requires signatures of the form $A = (g_0g_1^s\prod h_i^{m_i})^{\frac{1}{e+x}}$. This structure:
\begin{itemize}
    \item Demands \textit{inverse exponentiation} ($1/(e+x)$), creating non-linear relationships between secrets
    \item Forces proofs to handle \textit{cross-term cancellation} (e.g., $A_1^e = g_1^{\delta_1}g_2^{\delta_2}$)
    \item Requires pairing inversions ($e(A_2, \hat{h_0})^{-e}$) to verify credential validity
\end{itemize}


\paragraph{PS\_UTT and LRSW Advantages}
The LRSW assumption \cite{lysyanskaya2000pseudonym} underpinning PS\_UTT enables signatures with \textit{linear} algebraic structure:
\begin{itemize}
    \item Signatures take form $\sigma = (h^u, (X \cdot \prod g_i^{m_i} \cdot h^r)^u)$ with \textit{no inverse operations}
    \item Randomization factors ($u_\Delta, r_\Delta$) modify signatures additively rather than multiplicatively
    \item Verification equations remain bilinear pairings without cross-term cancellation
\end{itemize}


\paragraph{Assumption-Driven Efficiency}
The LRSW assumption enables three key efficiency properties, each building on the previous:
\begin{itemize}
    \item \textbf{Linear Exponent Relations}: Messages appear directly in the exponent as $\prod g_i^{m_i}$, avoiding the nested fraction structure of q-SDH
    \item \textbf{Independent Randomization}: The separation of $u_\Delta$ and $r_\Delta$ creates a natural two-layer randomization strategy, unlike BBS+'s entangled randomized
\end{itemize}
\sam{(does it change how SNARKS verify these signatures, multiplicative inverse in circuits?)}





\subsection{The PS\_UTT Advantage: Algebraic Decoupling}
PS\_UTT's key innovation lies in its separation of the signature's algebraic structure from the attribute commitment layer. Consider the ZKP relation for proving knowledge of PS\_UTT-signed attributes:

\begin{equation}
   \pi \gets \mathsf{PoK}\{(m_1,\ldots,m_\ell, u_\Delta, r_\Delta): 
   e(\sigma_2, \hat{h}) = e(\sigma_1, \widehat{X} \cdot \widehat{\cm}) \wedge
   e(\cm, \hat{h}) = e(h, \widehat{\cm}) \wedge
   \cm = h^{r+r_\Delta} \prod_{i=1}^\ell g_i^{m_i}
   \}
\end{equation}

Here, the prover need only linearly combine public parameters $(g_i, h)$ with secrets $(m_i, r_\Delta)$, leveraging the homomorphism of Pedersen commitments. This contrasts sharply with BBS+'s non-linear relation:

\begin{equation}
   \pi \gets \mathsf{SPK}\{(m_1,\ldots,m_{\ell}), e, r_2, r_3, s'): 
   \frac{\Bar{A}}{d} = A'^{-e} \cdot h_0^{r_2} \wedge 
   g = d^{r_3}h_0^{-s'}\prod_{i=1}^n h_i^{-m_i}\}
\end{equation}

\subsection{Technical Advantages}

\paragraph{Simplified Zero-Knowledge Proofs}
By decoupling randomization $(u_\Delta, r_\Delta)$ from the core signature verification equation, PS\_UTT eliminates the need for complex cancellation of cross-terms during proofs. This reduces both the number of group operations and the interactivity required in ZKP composition. 

\paragraph{Efficient Multi-Credential Proofs}
The separation of signature randomization from attribute proving enables more efficient composition of proofs across multiple credentials. Where BBS+ requires handling interleaved inverse operations and auxiliary variables, PS\_UTT's linear structure allows direct combination of attribute proofs through standard Pedersen commitment arithmetic.

\subsection{Practical Impact}
Our analysis demonstrates significant practical advantages:

\sam{Do some testing on this and hopefully it will hold!}

\begin{itemize}
   \item \textbf{Proof Size Reduction}: PS\_UTT reduces proof sizes by (X Percent)  compared to BBS+ in comparable settings
   
   \item \textbf{Verification Performance}: Benchmarks show PS\_UTT proofs are X TIMES FASTER 2.1 faster to generate and verify than BBS+ at the 128-bit security level.
   
   \item \textbf{Implementation Simplicity}: The linear structure of PS\_UTT proofs simplifies implementation and reduces the risk of subtle errors in proof composition.
\end{itemize}

\subsection{Conclusion}
PS\_UTT represents a significant advancement in anonymous credential systems through its elegant separation of signature, commitment, and randomization components. This modularity enables simpler zero-knowledge proofs, more efficient verification, and natural compatibility with modern proof systems—making it particularly suitable for resource-constrained environments and complex multi-credential scenarios.




% Thresholdise capability

% BBS+ They do not “thresholdize” very well: t-out-of- threshold protocols for BBS+ (and standalone BBS) either require offline preprocessing or multiple rounds of interaction between signers. - Alin Tomescu






% % % % % % % % % % 
% 
% PS Start
% 
% % % % % % % % % % 

% \noindent\textbf{Notation:}
% \begin{itemize}
%     \item $F_p-, F_p \times, F_p +$: Field inversion, multiply, add $\in \Z_p$
%     \item $E_{\G_1, \G_2, \G_T}$, $M_{\G_1, \G_2, \G_T}$: Exponentiation / Multiplication in respective groups
%     \item $P$: Pairing Operation
%     \item $L$: Number of message attributes
% \end{itemize}



\subsection{PS \cite{sako_short_2016}}

The signature scheme for signing information-theoretically hidden messages consists of the following algorithms:

\begin{itemize}
    \item \textbf{KeyGen}$(1^\lambda)$:
        \begin{itemize}
            \item Generate bilinear group: $\mathsf{BG} = (p, \G_1, \G_2, \G_T, e, g, \hat{g}) \sample \mathsf{BGGen}(1^\lambda)$
            \item Sample $(x, y_1, \ldots, y_{r}) \sample (\Z_p^*)^{\ell+1}$
            \item Compute $(X, Y_1, \ldots, Y_r) \gets (g^x, g^{y_1}, \ldots, g^{y_r})$ and $(\hat{X}, \hat{Y}_1, \ldots, \hat{Y}_r) \gets (\hat{g}^x, \hat{g}^{y_1}, \ldots, \hat{g}^{y_r})$. Set $\mathsf{sk} \gets X$ and $\mathsf{pk} \gets (g, Y_1, \ldots, Y_r, \hat{g}, \hat{g}^{y_1}, \ldots, \hat{g}^{y_r})$
        \end{itemize}
    
    \item \textbf{BlindSign Protocol}:
        \begin{itemize}
            \item \textbf{Prover} (input: $m_1,\ldots,m_\ell$): samples $t \sample \Z_p^*$, computes $\cm \gets g^t\prod_{i=1}^r Y_i^{m_i}$. Sends $\cm$ with a proof of knowledge to Signer
                \[
               \pi \leftarrow \mathsf{PoK}\{(m_1,\ldots,m_\ell,t): \mathsf{cm} = g^t\prod_{i=1}^r  Y_i^{m_i}\}
                \]
                
            \item \textbf{Signer} proves $\pi$, on success, samples $u \sample \Z_p^*$, computes $\sigma' \gets (g^u, (X\cm)^u)$, returns to Prover
            
            \item \textbf{User} unblinds by $\sigma \gets (\sigma_1', \frac{\sigma_2'}{\sigma_1{'t}})$
        \end{itemize}

        \item \textbf{Verify PoK}:
        \begin{itemize}
            \item \textbf{Prover:} Randomizes $\sigma$, samples $r,t \sample \Z_p^*$, computes $\sigma' \gets (\sigma_1^r, (\sigma_2 \cdot \sigma_1^t)^r)$. Sends $\sigma' = (\sigma_1, \sigma_2)$ to $\Verifier$ with a PoK
                \[
               \pi \gets \mathsf{PoK}\{(m_1,\ldots,m_\ell,t): e(\sigma_2', \hat{g}) = e(\sigma_1',\hat{X}) \cdot \prod_{j=1}^\ell e(\sigma_1', \widehat{Y}_j)^{m_j} \cdot e(\sigma', \hat{g})^t\}
                \]
                
        \end{itemize}
\end{itemize}


\begin{protocol}{PS Signature: Zero-Knowledge Proof of Knowledge of Blind Signature}{blind-sig-pok}
    \textbf{Relation $\mathcal{R}$:} Prove knowledge of messages and randomness in a blind signature:
        \[
        \pi \gets \mathsf{SPK}\{(m_1,\ldots,m_\ell,t): e(\sigma_2', \hat{g}) = e(\sigma_1',\hat{X}) \cdot \prod_{j=1}^\ell e(\sigma_1', \widehat{Y}_j)^{m_j} \cdot e(\sigma_1', \hat{g})^t\}
        \]
    
    \textbf{Common Input:} $(p, \G_1, \G_2, \G_T, e, g, \hat{g})$, $pk = (g, Y_1,\ldots,Y_r, \hat{g}, \hat{X}, \widehat{Y}_1,\ldots,\widehat{Y}_r)$, 
    
    \textbf{Private Input:} $\Prover$ has $(m_1,\ldots,m_\ell, t)$ where $\sigma = (\sigma_1, \sigma_2)$, $\sigma_1 = g^u, \sigma_2 = (g^x \cdot \cm)^u$ and $\cm = g^t\prod_{i=1}^rY_i^{m_i}$
    \vspace{1em}
    \begin{enumerate}
        \item $\Prover$: randomizes $\sigma$, samples $r,t \sample \Z_p^*$, computes $\sigma' \gets (\sigma_1^r, (\sigma_2 \cdot \sigma_1^t)^r)$\
        \begin{itemize}
            \item Samples Schnorr blinding factors from $\Z_p^*$
            \[
            \tilde{x} \text{ for } x \in \{\ t, r, m_1, \ldots, m_{\ell}\}
            \]
            \item Compute Schnorr commitment:
            \[
            T \gets e(\sigma_1',\hat{X}) \cdot \prod_{j=1}^\ell e(\sigma_1', \widehat{Y}_j)^{\tilde{m}_j} \cdot e(\sigma_1', \hat{g})^{\tilde{t}}
            \]
            \item Send $T$ to $\Verifier$
        \end{itemize}
        
        \item $\Verifier$ sends challenge $c \sample \Z_p^*$
        
        \item $\Prover$ computes Schnorr responses:
        \[
        z_{x} = \tilde{x} + c \cdot x \text{ for } x \in \{t,r, m_1, \ldots, m_\ell\}
        \]

        $\Prover$ sends $\Verifier$ $(\sigma_1', \sigma_2' \in \G_1, T \in \G_T, z_{x_j} \in \F_p^{\ell + 2} $
        
        \item $\Verifier$ checks:
        \[
        e(\sigma_2', \hat{g})^c \cdot T \stackrel{?}{=} e(\sigma_1',\hat{X})^c \cdot \prod_{j=1}^\ell e(\sigma_1', \widehat{Y}_j)^{z_{m_j}} \cdot e(\sigma_1', \hat{g})^{z_t}
        \]
    \end{enumerate}
\end{protocol}

\newpage

\noindent\textbf{Notation:}
\begin{itemize}
    \item $F_p-, F_p \times, F_p +$: Field inversion, multiply, add $\in \Z_p$
    \item $E_{\G_1, \G_2, \G_T}$, $M_{\G_1, \G_2, \G_T}$: Exponentiation / Multiplication in respective groups
    \item $P$: Pairing Operation
    \item $\ell$: Number of messages
\end{itemize}


\subsubsection{PS16 Complexity Analysis \cite{sako_short_2016}}
\begin{itemize}
    \item \textbf{Prover's Initial Operations (Signature Randomization)}
    \begin{itemize}
        \item $(\sigma_1^r, (\sigma_2 \cdot \sigma_1^t)^r)$ \qquad $3E_{\G_1} + 1M_{\G_1}$
    \end{itemize}
    
\item \textbf{Prover Schnorr Operations}
    \begin{itemize}
        \item Sample $\ell+2$ field elements ($t, r, m_1,\ldots,m_\ell$) \qquad (negligible)
        \item Compute $T \gets e(\sigma_1',\hat{X}) \cdot \prod_{j=1}^\ell e(\sigma_1', \widehat{Y}_j)^{\tilde{m}_j} \cdot e(\sigma_1', \hat{g})^{\tilde{t}}$ \qquad $(\ell+2)P + (\ell+1)E_{\G_T} + (\ell+1)M_{\G_T}$
    \end{itemize}
    
\item \textbf{Proof Size / Data Sent}
    \begin{itemize}
        \item $(\sigma_1', \sigma_2', T)$ \qquad $2\G_1$, $1\G_T$ elements
        \item $z_x$ for $x \in \{t,r,m_1,\ldots,m_\ell\}$ \qquad $(\ell+2)\Z_p^*$ elements
    \end{itemize}
    
\item \textbf{Verifier Operations}
    \begin{itemize}
        \item Equation verification: $e(\sigma_2', \hat{g}) \stackrel{?}{=} e(\sigma_1',\hat{X}) \cdot \prod_{j=1}^\ell e(\sigma_1', \widehat{Y}_j)^{z_{m_j}} \cdot e(\sigma_1', \hat{g})^{z_t}$ \qquad $(\ell+3)P + (\ell+1)E_{\G_T} + (\ell+2)M_{\G_T}$
    \end{itemize}
\end{itemize}


% % % % % % % % % % 
% 
% PS End
% 
% % % % % % % % % % 


% % % % % % % % % % 
% 
% PS UTT Start
% 
% % % % % % % % % % 


\newpage
\subsection{PS22 \cite{tomescu2022utt}}

\begin{itemize}
    \item \textbf{PS.Rerand}$(\pk, \sigma = (\sigma_1, \sigma_2), \cm = (\cm, \widetilde{\cm}) ) \to (\sigma', \cm', r_\Delta, u_\Delta)$
    \begin{itemize}
        \item $\Prover$ samples $r_\Delta, u_\Delta \sample \Z_p$
        \item Rerandomizes the signature $\sigma'$ = $(\sigma_1', \sigma_2') \gets (\sigma_1^{u_\Delta}, (\sigma_2\cdot \sigma_1^{r_\Delta})^{u_\Delta})$
        \item Randomizes the commitment by computing $g^{r_\Delta}, \hat{g}^{r_\Delta}$, then  $(\cm', \widehat{\cm'}) \gets (\cm \cdot h^{r_\Delta}, \widehat{\cm}\cdot \hat{h}^{r_\Delta})$
    \end{itemize}

    \item \textbf{PoK}$(\pk, \sigma = (\sigma_1, \sigma_2), \cm, \widehat{\cm}, \vec{m}, r_\Delta, u_\Delta)$ $\Prover$ sends rerandomized signature and commitment $\sigma', \cm'$ and $\pi$ 
  \[
        \pi \gets \mathsf{PoK}\{(m_1,\ldots,m_\ell, u+u_\Delta, r+r_\Delta): 
    \]
    \[
         e(\sigma_2', \tilde{g}) = e(\sigma_1', \widetilde{X})\cdot e(\sigma_1', \widehat{\cm}') \quad \wedge \quad
        e(\cm', \tilde{g}) = e(g, \widetilde{\cm}') \quad \wedge \quad
        \cm' = g^{r+r_\Delta} \prod_{i=1}^\ell g_i^{m_i}
        \}
    \]
    
\end{itemize}


notes, recall
\begin{align*}
    &\sigma_1' = \sigma_1^{u_\Delta} = h^{u_\Delta} = g^{u \cdot u_\Delta} \\
    &\sigma_2' = (\sigma_2\cdot \sigma_1^{r_\Delta})^{u_\Delta}) \\
    &= ((sk\cdot \cm)^u \cdot h^{r_\Delta})^{u_\Delta}) \\
    &= g^{x \cdot u \cdot u_\Delta} \cdot \cm^{u \cdot u_\Delta}\cdot g^{u \cdot u_\Delta \cdot r_\Delta}\\
\end{align*}



    \[
        \cm' = g^{r+r_\Delta} \prod_{i=1}^\ell g_i^{m_i}
    \]
    Changing to this
    \[
        \cm' = \tilde{g}^{r_\Delta} \cdot \widetilde{\cm} \text{  without sending  } \widetilde{\cm} 
    \]
    but using its bases $g_1, \ldots, g_\ell$

    \[
        \sigma_1' = \sigma_1^{u_\Delta} = h^{u_\Delta} = g^{u \cdot u_\Delta} \\
    \]
    \begin{align*}
    &\sigma_2' = (\sigma_2\cdot \sigma_1^{r_\Delta})^{u_\Delta}) \\
    &= ((sk\cdot \cm)^u \cdot h^{r_\Delta})^{u_\Delta}) \\
    &= g^{x \cdot u \cdot u_\Delta} \cdot \cm^{u \cdot u_\Delta}\cdot g^{u \cdot u_\Delta \cdot r_\Delta}\\
    \end{align*}

    \begin{align*}
    e(\sigma_2', \tilde{g}) &= e((\sk \cdot \cm)^{u \cdot u\Delta}\cdot h^{u_\Delta \cdot r_\Delta}, \tilde{g}) \\
    &= e(h^{x \cdot u_\Delta}\cdot \cm^{u \cdot u_\Delta} \cdot h^{u_\Delta \cdot r_\Delta}, \tilde{g}) \\
    &= e(h^{x \cdot u_\Delta}, \tilde{g}) \cdot e(\cm^{u \cdot u_\Delta}, \tilde{g}) \cdot e(h^{ u_\Delta \cdot r_\Delta}, \tilde{g}) \\
    &= e(h^{u_\Delta}, \tilde{g}^x) \cdot e(\cm, \tilde{g})^{u \cdot u_\Delta} \cdot e(h^{ u_\Delta}, \tilde{g})^{r_\Delta} \\
    &= e(\sigma_1', \vk) \cdot e(g^{u \cdot u_\Delta}, \widetilde{\cm}) \cdot e(\sigma_1', \tilde{g})^{r_\Delta} \\
    &= e(\sigma_1', \vk) \cdot e(\sigma_1', \widetilde{\cm}) \cdot e(\sigma_1', \tilde{g}^{r_\Delta}) \\
    &= e(\sigma_1', \vk \cdot \widetilde{\cm} \cdot \tilde{g}^{r_\Delta}) \\
\end{align*}

 % = e(g^(u.u_delta), g_tilda^x).e(cm, g_tilda)^(u.u_delta). e(h^u_delta, g_tilda)^r_delta
    
    


\newpage
\begin{protocol}{Zero-Knowledge Proof of Knowledge for PS Signature over Commitments}{ps-pok}
    \textbf{Relation $\mathcal{R}$}
    \[
        \pi \gets \mathsf{PoK}\{(m_1,\ldots,m_\ell, u+u_\Delta, r+r_\Delta): 
    \]
    \[
         e(\sigma_2', \tilde{g}) = e(\sigma_1', \widetilde{X})\cdot e(\sigma_1', \widehat{\cm}') \quad \wedge \quad
        e(\cm', \tilde{g}) = e(g, \widetilde{\cm}') \quad \wedge \quad
        \cm' = g^{r+r_\Delta} \prod_{i=1}^\ell g_i^{m_i}
        \}
    \]

    \textbf{Common Input:} $(p, \G_1, \G_2, \G_T, g, \tilde{g}, e)$, $\pk = (\vk = \tilde{X}, \ck = g_1, \ldots, g_{\ell}, g)$, a rerandomized signature $\sigma' = (\sigma_1', \sigma_2')$, and rerandomized commitment $\cm' = (\cm \cdot g^{r_\Delta}, \widetilde{\cm}' \cdot \tilde{g}^{r_\Delta})$
    
    \textbf{Private Input:} $\Prover$ has messages $(m_1,\ldots,m_\ell)$, commitment randomness $r' = r + r_\Delta$, signature randomness $u' = u + u_\Delta$
    
    \begin{enumerate}
        \item $\Prover$:
        \begin{itemize}
            \item Sample Schnorr blinding factors from $\Z_p$:
            \[
                \tilde{x} \text{ for } x \in \{m_1,\ldots,m_\ell, r', u'\}
            \]
            \item Compute Schnorr commitments:
            \[
                T_1 \gets g^{\tilde{r'}} \prod_{i=1}^\ell g_i^{\tilde{m_i}} \qquad T_2 \gets e(\sigma_1'^{u'}, \vk \cdot \widehat{\cm'})
            \]
            \item Send $(T_1 \in \G_1, T_2 \in \G_T)$ to $\Verifier$
        \end{itemize}
        
        \item $\Verifier$ sends challenge $c \sample \Z_p$
        
        \item $\Prover$ computes Schnorr responses:
        \[
            z_x = \tilde{x} + c \cdot x \text{ for } x \in \{m_1,\ldots,m_\ell, u', r'\}
        \]
        
        \item $\Verifier$ checks:
        \[
            \cm'^c \cdot T_1 \stackrel{?}{=} g^{z_{r'}} \prod_{i=1}^\ell g_i^{z_{m_i}}
            \quad \wedge \quad e(\cm', \tilde{g}) \stackrel{?}{=} e(g, \widetilde{\cm}')
        \]
        \[
            e(\sigma_2', \tilde{g})^c \cdot T_2 \stackrel{?}{=} e(\sigma_1'^{z_{u'}}, \vk \cdot \widetilde{\cm}')
        \]
    \end{enumerate}
\end{protocol}




\newpage
\subsubsection{PS UTT Complexity Analysis \cite{tomescu2022utt}}
\begin{itemize}
    \item \textbf{Prover's Initial Operations (Signature Rerandomization)}
    \begin{itemize}
        \item $(\sigma_1^{u_\Delta}, (\sigma_2\cdot \sigma_1^{r_\Delta})^{u_\Delta})$ \qquad $3E_{\G_1} + 1M_{\G_1}$
        \item $(\cm \cdot h^{r_\Delta}, \widehat{\cm} \cdot \hat{h}^{r_\Delta})$ \qquad $1E_{\G_2} + 1E_{\G_1} + 1M_{\G_1} + 1M_{\G_2}$
    \end{itemize}
\item \textbf{Prover Schnorr Operations}
    \begin{itemize}
        \item Sample $\ell+2$ field elements ($\tilde{m_1},\ldots,\tilde{m_\ell}, \tilde{r'}, \tilde{u'}$) \qquad (negligible)
        \item Compute commitment $T_1 \gets h^{\tilde{r'}} \prod_{i=1}^\ell g_i^{\tilde{m_i}}$ \qquad $(\ell + 1)E_{\G_1} + \ell M_{\G_1}$
        \item Compute commitment $T_2 \gets e(\sigma_1^{\tilde{u'}}, \widehat{X} \cdot \widehat{\cm'})$ \qquad $1E_{\G_1} + 1M_{\G_2} + 1P$
    \end{itemize}
    
\item \textbf{Proof Size / Data Sent}
    \begin{itemize}
        \item $(\sigma_1', \sigma_2', \cm', \widehat{\cm'}, T_1, T_2)$ \qquad $5\G_1$, $1\G_2$ elements
        \item $z_x$ for $x \in \{m_1,\ldots,m_\ell, r', u'\}$ \qquad $(\ell+2)\Z_p$ elements
    \end{itemize}
    
\item \textbf{Verifier Operations}
    \begin{itemize}
        \item First equation check: $\cm'^c \cdot T_1 \stackrel{?}{=} h^{z_{r'}} \prod_{i=1}^\ell g_i^{z_{m_i}}$ \qquad $(\ell + 2) E_{\G_1}$ + $(\ell + 2) M_{\G_1}$
        \item Second equation check: $e(\cm, \hat{h}) \stackrel{?}{=} e(h, \widehat{\cm})$ \qquad $2P$
        \item Third equation check: $e(\sigma_2, \hat{h})^c \cdot T_2 \stackrel{?}{=} e(\sigma_1^{z_{u'}}, \widehat{X} \cdot \widehat{\cm'})$ \qquad $ 1E_{\G_1} + 1M_{\G_2} + 1E_{\G_T} + 2P + 2M_{\G_T} $
    \end{itemize}
\end{itemize}

\begin{figure}
    \centering
    \caption{Complexity comparison between standard PS UTT and optimized variant. The optimized version uses Multi-Scalar Multiplication to reduce Schnorr proof from $\mathcal{O}(\ell)$ individual exponentiation to $\mathcal{O}(log \ell)$ effective operations using MSM techniques. Verifier pairing checks are re-arranged with Miller Loop + Final Exponentiation techniques with Pairing Inversion. Miller Loop batching (MLoop) and final exponentiation sharing (F.Exp), reducing the pairing cost from 4P to approximately 2.5P. MSM(n) denotes an n-point multi-scalar multiplication with complexity O(n/log n) using window methods}
    \label{fig:enter-label}
        \begin{tabular}{|l|p{4.5cm}|p{4.5cm}|p{3.5cm}|}
            \hline
            \textbf{Protocol} & \textbf{Show (Prover)} & \textbf{Verify (Verifier)} & \textbf{Data Sent} \\
            \hline
            PS UTT &
            \textbf{Randomize:}
            \begin{itemize}[nosep]
                \item $4E_{\G_1} + 2M_{\G_1}$ 
                \item $1E_{\G_2} + 1M_{\G_2}$
            \end{itemize}
            \textbf{Schnorr Proof:}
            \begin{itemize}[nosep]
                \item $(\ell+1)E_{\G_1} + \ell M_{\G_1}$ 
                \item $1E_{\G_1} + 1M_{\G_2} + 1P$ 
            \end{itemize}
            &
            \begin{itemize}[nosep]
                \item $(\ell+3)E_{\G_1} + (\ell+2)M_{\G_1} + 1M_{\G_2}$
                \item $1E_{\G_T} + 2M_{\G_T}$
                \item $4P$ 
            \end{itemize}
            &
            \begin{itemize}[nosep]
                \item $5\G_1$
                \item $1\G_2$
                \item $(\ell+2)\Z_p$
            \end{itemize}
            \\
             \hline
             PS UTT Optimized &
            \textbf{Randomize:}
            \begin{itemize}[nosep]
                \item $4E_{\G_1} + 2M_{\G_1}$ 
                \item $1E_{\G_2} + 1M_{\G_2}$
            \end{itemize}
            \textbf{Schnorr Proof:}
            \begin{itemize}[nosep]
                \item $\cancel{(\ell+1)E_{\G_1} + \ell M_{\G_1}}$
                \item $MSM(\ell + 1)\G_1$ 
                \item $1E_{\G_1} + 1M_{\G_2} + 1P$ 
            \end{itemize}
            &
            \begin{itemize}[nosep]
                \item $\cancel{(\ell+3)E_{\G_1} + (\ell+2)M_{\G_1}} + 1M_{\G_2}$
                \item $MSM(\ell+3) + 1M_{\G_2}$
                \item $1E_{\G_T} + 2M_{\G_T}$
                \item $\cancel{4P}$ 
                \item $4\text{MLoop}\G_T + 1\text{F.Exp}\G_T$ 
            \end{itemize}
            &
            \begin{itemize}[nosep]
                \item $5\G_1$
                \item $1\G_2$
                \item $(\ell+2)\Z_p$
            \end{itemize}
            \\
             \hline
        \end{tabular}
\end{figure}

% % % % % % % % % % 
% 
% PS UTT End
% 
% % % % % % % % % % 


\begin{table}[ht]
\centering
\begin{tabular}{l|cc|ccc}
\toprule
\multirow{2}{*}{\textbf{Scheme}} & \multicolumn{2}{c|}{\textbf{Show}} & \multicolumn{3}{c}{\textbf{Verify}} \\
\cmidrule(lr){2-3} \cmidrule(lr){4-6}
& Credential & PoK & Credential & PoK & Data Sent \\
\midrule
PSUTT & $(2\ell + 3)E_{\mathbb{G}_1}$ & $(2\ell + 1)E_{\mathbb{G}_1}$ & $(3\ell + 2)P$ & $(\ell + 2)E_{\mathbb{G}_1}$ & $(2\ell + 3)|\mathbb{G}_1| + |PK|$ \\
PSUTT+LVS & $3E_{\mathbb{G}_2} + E_{\mathbb{G}_1}$ & $MSM(\ell + 1)_{\mathbb{G}_1} + E_{\mathbb{G}_1}$ & $2M\text{Loop}\mathbb{G}_T + E_{\mathbb{G}_T}$ & $E_{\mathbb{G}_1} + MSM(\ell + 1)_{\mathbb{G}_1}$ & $2|\mathbb{G}_1| + 2|\mathbb{G}_2| + (\ell + 1)|\mathbb{Z}_p|$ \\
\bottomrule
\end{tabular}
\caption{Comprehensive comparison of anonymous credential schemes. $P$ denotes pairing operation, $E_{\mathbb{G}_1}$, $E_{\mathbb{G}_2}$ and $E_{\mathbb{G}_T}$ denote exponentiations in $\mathbb{G}_1$, $\mathbb{G}_2$ and target group $\mathbb{G}_T$ respectively, $\ell$ denotes number of attributes, $|\mathbb{G}_1|$ and $|\mathbb{G}_2|$ denote group element sizes, and $|\mathbb{Z}_p|$ denotes field element size.}
\label{tab:unified-comparison}
\end{table}
















% % % % % % % % % % 
% 
% BBS+
% 
% % % % % % % % % % 

\newpage
\subsection{BBS+ 2006}
Original BBS+ signature
\subsubsection{Protocol for Signature Proof of Knowledge}
asd

\begin{protocol}{\cite{hutchison_constant-size_2006} Zero-Knowledge Proof of Knowledge of BBS+ }{bbsplus-pok-2006}
    \textbf{Relation $\mathcal{R}$}
        \[
        \pi \gets \mathsf{SPK}\{(r_1, r_2, e, \delta_1, \delta_2, s, m_1,\ldots,m_{\ell})): \quad A_1 = g_1^{r_1}g_2^{r_2} \quad \wedge \quad A_1^e = g_1^{\delta_1}g_2^{\delta_2} \quad \wedge 
        \]
        \[
        \frac{e(A_2, \widehat{w})}{e(g_2, \widehat{h_0})} \quad = \quad 
        e(g_2,\widehat{w})^{-e}e(g_2,\widehat{w})^{r_1}e(g_1,\widehat{h_0})^e(g_2,\widehat{h_0})^{m_1}\cdots e(g_{L+1},\widehat{h_0})^{m_L}
        \]
    \textbf{Common Input:} $(p, \G_1, \G_2, \G_T, e, g_0, \widehat{h_0})$, $pk = (\hat{w} = \hat{h_0}^{\gamma},  g_0, \ldots, g_{L})$

    \textbf{Private Input:} $\Prover$ has BBS+ signature $(A,e,s)$ where $A = (g_0g_1^s\prod_{i=1}^{L} g_{i+1}^{m_i})^{\frac{1}{e+\gamma}}$ and $\delta_1 = r_1e$ and $\delta_2 = r_2e$

    \vspace{1em}
    \begin{enumerate}
        \item $\Prover$ samples random $r_1, r_2 \sample \Z_p^*$, set $\delta_1 = r_1e$ and $\delta_2 = r_2e$
         \begin{itemize}
        \item Compute blinded signature: $A_1 = g_1^{r_1}g_2^{r_2} \quad \wedge \quad A_1^e = g_1^{\delta_1}g_2^{\delta_2} \quad \wedge \quad A_2 = Ag_2^{r_1}$

        \item sample Schnorr blinding factors from $\Z_p^*$
         \[
         \tilde{x} \text{ for } x \in \{r_1, r_2, e, \delta_1, \delta_2, s, m_1,\ldots,m_{L}\}
         \]

        \item compute Schnorr Commitments:
        \[
        T_1 \gets g_1^{\tilde{r_1}}g_2^{\tilde{r_2}} \qquad T_2 \gets g_1^{\tilde{\delta_1}} g_2^{\tilde{\delta_2}} 
        \]
        \[
        T_3 \gets e(A_2, \hat{h_0})^{\tilde{-e}}\cdot e(g_2, \hat{w})^{\tilde{r_1}} \cdot e(g_2, \hat{h_0})^{\tilde{\delta_1}} \cdot e(g_1, \hat{h_0})^{\tilde{s}} \cdot e(g_2, \hat{h_0})^{\tilde{m_1}} \cdots e(g_{L+1}, \hat{h_0})^{\tilde{m_L}}
        \]
        
        \item  Send $(A_1, A_1^e, A_2, T_1, T_2, T_3)$ to $\Verifier$
                
        \end{itemize}

    \item $\Verifier$ sends challenge $c \sample \Z_p^*$\

    \item $\Prover$ computes Schnorr responses:
         \[
         z_x = \tilde{x} + c \cdot x \text{ for } x \in \{r_1, r_2, e, \delta_1, \delta_2, e, s, m_1,\ldots,m_{\ell})\}
         \]
 
    \item $\Verifier$ checks
    \[
    A_1^c \cdot T_1 \stackrel{?}{=} g_1^{z_{r_1}}g_2^{z_{r_2}} \quad \wedge \quad (A_1^e)^c \cdot T_2 = g_1^{{z}_{\delta_1}}g_2^{{z}_{\delta_2}} \quad \wedge
    \]
        \[
            \frac{e(A_2, \widehat{w})}{e(g_2, \widehat{h_0})} \stackrel{?}{=}  e(A_2, \hat{h_0})^{z_e} \cdot e(g_2, \hat{w})^{z_{r_1}} \cdot e(g_2, \hat{h_0})^z_{\delta_1} \cdot e(g_1, \hat{h_0})^{z_s} \cdot \prod_{i=1}^L e(g_{i+1}, \hat{h_0})^{z_{m_i}}
        \]
    \end{enumerate}
\end{protocol}

\newpage
\subsubsection{BBS+ 2006 Complexity Analysis}

\begin{itemize}
    \item \textbf{Precomputed Values}
    \begin{itemize}
        \item Base pairings: $(e(g_1, \hat{h_0}), e(g_2, \hat{h_0}), e(g_2, \hat{w}))$ \qquad $3$ stored $\G_T$ elements
        \item Message pairings: $\{e(g_{i+1}, \hat{h_0})\}_{i \in [1,L]}$ \qquad $L$ stored $\G_T$ elements
    \end{itemize}

    \item \textbf{Prover's Initial Operations}
    \begin{itemize}
        \item $(\delta_1, \delta_2) \gets (r_1e, r_2e)$ \qquad $2F_p\times$
        \item $(A_1, A_1^e, A_2) \gets (g_1^{r_1}g_2^{r_2}, (g_1^{r_1}g_2^{r_2})^e, Ag_2^{r_1})$ \qquad $4E_{\G_1} + 2M_{\G_1}$
    \end{itemize}
    
    \item \textbf{Prover Schnorr Operations}
    \begin{itemize}
        \item Sample $L+6$ field elements $(\tilde{r_1}, \tilde{r_2}, \tilde{e}, \tilde{\delta_1}, \tilde{\delta_2}, \tilde{s}, \tilde{m_1},\ldots,\tilde{m_L})$ \qquad (negligible)
        \item $(T_1, T_2) \gets (g_1^{\tilde{r_1}}g_2^{\tilde{r_2}}, g_1^{\tilde{\delta_1}}g_2^{\tilde{\delta_2}})$ \qquad $4E_{\G_1} + 2M_{\G_1}$
        \item Compute $T_3$ using precomputed pairings \qquad $1P + (L+4)E_{\G_T} + (L+3)M_{\G_T}$
    \end{itemize}
    
    \item \textbf{Proof Size / Data Sent}
    \begin{itemize}
        \item $(A_1, A_1^e, A_2, T_1, T_2, T_3)$ \qquad $5$ elements in $\G_1$, $1$ element in $\G_T$
        \item $z_x$ for $x \in \{r_1, r_2, e, \delta_1, \delta_2, s, m_1,\ldots,m_L\}$ \qquad $(L+6)$ elements in $\Z_p^*$
    \end{itemize}
    
    \item \textbf{Verifier Operations}
    \begin{itemize}
        \item Commitment verification: $A_1^c \cdot T_1 \stackrel{?}{=} g_1^{z_{r_1}}g_2^{z_{r_2}}$ \qquad $3E_{\G_1} + 2M_{\G_1}$
        \item Exponentiation verification: $(A_1^e)^c \cdot T_2 \stackrel{?}{=} g_1^{z_{\delta_1}}g_2^{z_{\delta_2}}$ \qquad $3E_{\G_1} + 2M_{\G_1}$
        \item Pairing equation verification: $e(A_2, \widehat{w}) \stackrel{?}{=} e(g_2, \widehat{h_0}) \cdot T_3^c$ \qquad $2P + (L+4)E_{\G_T} + (L+3)M_{\G_T}$
    \end{itemize}
\end{itemize}



% % % % % % % % % % 
% 
% BBS+ CDL16
% 
% % % % % % % % % % 



\newpage
\subsection{BBS+ 2016 \cite{camenisch_anonymous_2016}}
asd
\subsubsection{Protocol for Signature Proof of Knowledge}
asd
\begin{protocol}{CDL16 Zero-Knowledge Proof of Knowledge of BBS+  \cite{camenisch_anonymous_2016}}{bbsplus-pok-2016}
    \textbf{Relation $\mathcal{R}$}
        \[
        \pi \gets \mathsf{SPK}\{(m_1,\ldots,m_{\ell}), e, r_2, r_3, s'): \quad \frac{\Bar{A}}{d} = A'^{-e} \cdot h_0^{r_2} \quad \wedge \quad g = d^{r_3}h_0^{-s'}\prod_{i=1}^n h_i^{-m_i}\}
        \]
    \textbf{Common Input:} $(p, \G_1, \G_2, \G_T, e, g_2)$, $pk = (\hat{w}, \{h_i\}_{i=0}^n)$

    \textbf{Private Input:} $\Prover$ has BBS+ signature $(A,e,s)$ where $A = (gh_0^s\prod_{i=1}^n h_i^{m_i})^{\frac{1}{e+x}}$ and $b = gh_0^s \prod_1^nh_i^{m_i}$

    \vspace{1em}
    \begin{enumerate}
        \item $\Prover$ samples random $r_1, r_2 \sample \Z_p^*$, set $r_3 = \frac{1}{r_1},$ and $s' \gets s - r_2 \cdot r_3$
         \begin{itemize}
        \item Compute blinded signature: $A' \gets A^{r_1}$ and set $\Bar{A} \gets A'^{-e} \cdot b^{r_1}$ $\quad (=A'^{x})$ 
        
        \item compute $d \gets (gh_0^s \prod_1^nh_i^{-m_i})^{r_1} \cdot h_0^{-r_2}$

        \item sample Schnorr blinding factors from $\Z_p$
         \[
         \tilde{x} \text{ for } x \in \{r_1, r_2, e, s, m_1, \ldots, m_{\ell}\}
         \]

        \item compute Schnorr Commitments:
        \[
        T_1 \gets A^{\tilde{e}} \cdot h_0^{\tilde{s}} \qquad T_2 \gets g\prod_{i=1}^n h_i^{\tilde{m_i}}
        \]
        
        \item  Send $(A', \Bar{A}, d, T_1, T_2)$ to $\Verifier$
                
        \end{itemize}

    \item $\Verifier$ sends challenge $c \sample \Z_p^*$\

    \item $\Prover$ computes Schnorr responses:
         \[
         z_x = \tilde{x} + c \cdot x \text{ for } x \in \{r_1, r_2, e, s', m_1, \ldots, m_{\ell}\}
         \]
 
    \item $\Verifier$ checks
        \[
            A' \neq 1_{\G_1} \quad \wedge \quad e(A',\hat{w}) = e(\Bar{A},g_2) \qquad T_1 \stackrel{?}{=} A^{z_e} \cdot h_0^{z_s} \cdot (\Bar{A})^{-c} \qquad T_2 \stackrel{?}{=} g^c\prod_{i=1}^n h_i^{z_{m_i}}
        \]
    \end{enumerate}
\end{protocol}

\newpage
\subsubsection{Complexity Analysis}

\begin{itemize}
    \item \textbf{Precomputed Values}
    \begin{itemize}
        \item Base pairings: $(e(g, g_2), e(h_0, g_2))$ \qquad $2$ stored $\G_T$ elements
        \item Attribute pairings: $\{e(h_i, g_2)\}_{i \in [1,n]}$ \qquad $n$ stored $\G_T$ elements
    \end{itemize}

    \item \textbf{Prover's Initial Operations}
    \begin{itemize}
        \item Field computations: $(r_3, s') \gets (\frac{1}{r_1}, s - r_2 \cdot r_3)$ \qquad $1F_p- + 1F_p\times + 1F_p+$
        \item Signature randomization: $(A', \Bar{A}) \gets (A^{r_1}, A'^{-e} \cdot b^{r_1})$ \qquad $3E_{\G_1} + 1M_{\G_1}$
        \item Attribute commitment: $d \gets (gh_0^{r_1}\prod_{i=1}^n h_i^{-m_i})^{r_2} \cdot h_0^{r_3}$ \qquad $(n+2)E_{\G_1} + (n+1)M_{\G_1}$
    \end{itemize}
    
    \item \textbf{Prover Schnorr Operations}
    \begin{itemize}
        \item Sample $n+4$ field elements $(\tilde{e}, \tilde{s}, \tilde{m_1},\ldots,\tilde{m_n}, \tilde{r_1}, \tilde{r_2})$ \qquad (negligible)
        \item $(T_1, T_2) \gets (A^{\tilde{e}} \cdot h_0^{\tilde{s}}, g\prod_{i=1}^n h_i^{\tilde{m_i}})$ \qquad $(n+2)E_{\G_1} + nM_{\G_1}$
    \end{itemize}
    
    \item \textbf{Proof Size / Data Sent}
    \begin{itemize}
        \item $(A', \Bar{A}, d, T_1, T_2)$ \qquad $5$ elements in $\G_1$
        \item $z_x$ for $x \in \{r_1, r_2, e, s', m_1,\ldots,m_n\}$ \qquad $(n+4)$ elements in $\Z_p^*$
    \end{itemize}
    
    \item \textbf{Verifier Operations}
    \begin{itemize}
        \item Pairing verification: $e(A',\hat{w}) \stackrel{?}{=} e(\Bar{A},g_2)$ \qquad $2P + 1M_{\G_T}$
        \item Commitment verification: $T_1 \stackrel{?}{=} A^{z_e} \cdot h_0^{z_s} \cdot (\Bar{A})^{-c}$ \qquad $3E_{\G_1} + 2M_{\G_1}$
        \item Attribute verification: $T_2 \stackrel{?}{=} g^c\prod_{i=1}^n h_i^{z_{m_i}}$ \qquad $(n+1)E_{\G_1} + nM_{\G_1}$
    \end{itemize}
\end{itemize}




% % % % % % % % % % 
% 
% CL04
% 
% % % % % % % % % % 

\newpage
\subsection{CL04 \cite{hutchison_signature_2004}}
Signature scheme D from \cite{hutchison_signature_2004} Mapped to Type3 Pairings

\begin{itemize}
    \item \textbf{KeyGen}($1^\lambda$):
    \begin{itemize}
        \item $\mathsf{BG} = (p, \G_1, \G_2, \G_T, e, g, \hat{g}) \sample \mathsf{BGGen}(1^\lambda)$
        \item Sample $x, y \sample \Z_p^*$, $(z_1, \ldots, z_\ell) \sample (\Z_p^*)^\ell$. Set $sk = (x, y, z_1, \ldots, z_\ell)$
        \item Compute public key:
            \begin{align*}
                X &\gets g^x \in \G_1, \quad \widehat{Y} \gets \hat{g}^y \in \G_2 \qquad h \sample \Z_p^*, H \gets g^h\\
                \widehat{Z}_i &\gets \hat{g}^{z_i} \in \G_2, \quad W_i \gets g^{x z_i} \in \G_1 \quad \forall i \in [1..\ell]
            \end{align*}
        \item Output: $pk = (\mathsf{BG}, X, \widehat{Y}, \{\widehat{Z}_i\}_{i=1}^\ell, \{W_i\}_{i=1}^\ell)$
    \end{itemize}
    
    \item \textbf{Sign}($sk, (m_1,\ldots,m_\ell)$):
    \begin{itemize}
        \item Sample $\alpha \sample \Z_p^*$, compute $a \gets g^\alpha \in \G_1$
        \item For $i \in [1..\ell]$: $A_i \gets a^{z_i} \in \G_1$
        \item Compute $b \gets a^y \in \G_1$, $B_i \gets A_i^y \in \G_1$
        \item Compute $c \gets a^{x} \cdot b^{\alpha} \cdot \prod_{i=1}^\ell B_i^{m_i} \in \G_1$
        \item Output $\sigma = (a, \{A_i\}, b, \{B_i\}, c)$
    \end{itemize}

    \item \textbf{Verify}($pk, (m_1,\ldots,m_\ell), \sigma$):
    \begin{itemize}
        \item Parse $\sigma = (a, \{A_i\}, b, \{B_i\}, c)$
        \item Verify:
            \begin{align*}
                e(b, \hat{g}) &= e(a, \widehat{Y}) \\
                \forall i: e(B_i, \hat{g}) &= e(A_i, \widehat{Y}) \\
                e(c, \hat{g}) &= e(X, \hat{g}) \cdot e(a, \widehat{Y})^\alpha \cdot \prod_{i=1}^\ell e(A_i, \widehat{Y})^{m_i}
            \end{align*}
    \end{itemize}

    \item \textbf{BlindSign Protocol}:
    \begin{itemize}
        \item \textbf{User} (with $(m_1, \ldots, m_\ell)$):
            \begin{itemize}
                \item Sample $\gamma \sample \Z_p^*$
                \item Compute commitment: $\cm \gets h^\gamma\prod_{i=1}^\ell W_i^{m_i} \in \G_1$
                \item Send $\cm$ to Signer with proof:
                    \[
                    \pi = \mathsf{PoK}\{(m_1, \ldots, m_\ell, \gamma): \cm = H^\gamma\prod_{i=1}^\ell W_i^{m_i}\}
                    \]
            \end{itemize}
        
        \item \textbf{Signer} (with $sk = (x, y, z_1, \ldots, z_\ell)$):
        \item Verify $\pi$. If valid:
                
        \begin{itemize}
            \item Sample $\alpha \sample \Z_p^*$, compute $a \gets g^\alpha$, $A_i \gets a^{z_i}$
            \item Compute $b \gets a^y$, $B_i \gets A_i^y$
            \item Compute $c \gets a^x \cdot \cm^{xy} \in \G_1$
            \item Send $\sigma = (a, \{A_i\}, b, \{B_i\}, c)$ to User
        \end{itemize}


        \item \textbf{User} (Unblinding):
            \begin{itemize}
                \item Sample $r, r' \sample \Z_p^*$
                \item Compute blinded signature $\tilde{\sigma}$:
                    \begin{align*}
                        \tilde{a} &\gets a^{r'} \\
                        \tilde{A_i} &\gets A_i^{r'} && \text{for } i \in [1,\ell] \\
                        \tilde{b} &\gets b^{r'} \\
                        \tilde{B_i} &\gets B_i^{r'} && \text{for } i \in [1,\ell] \\
                        \tilde{c}^r &\gets c^{r r'}
                    \end{align*}
            \end{itemize}

    \item \textbf{ZKPoK-Verify}:
    \begin{itemize}
        \item \textbf{Common Input}: $pk$, $\tilde{\sigma} = (\tilde{a}, \{\tilde{A}_i\}, \tilde{b}, \{\tilde{B}_i\}, \tilde{c})$
        
        \item \textbf{Prover} (with $m_1, \ldots, m_\ell$):
            \begin{itemize}
                \item Compute pairings:
                    \begin{align*}
                        v_x &\gets e(\tilde{a}, \hat{g}) \\
                        v_{xy} &\gets e(\tilde{a}, \widehat{Y}) \\
                        v_s &\gets e(\tilde{c}, \hat{g})
                    \end{align*}
                \item Generate proof:
                    \[
                    \pi = \mathsf{PoK}\{(m_1, \ldots, m_\ell, r): v_s = v_x \cdot \prod_{i=1}^\ell e(\tilde{A}_i, \widehat{Y})^{m_i}\}
                    \]
            \end{itemize}
        
        \item \textbf{Verifier}:
            \begin{itemize}
                \item Check signature structure:
                    \begin{align*}
                        e(\tilde{b}, \hat{g}) &\stackrel{?}{=} e(\tilde{a}, \widehat{Y}) \\
                        e(\tilde{B}_i, \hat{g}) &\stackrel{?}{=} e(\tilde{A}_i, \widehat{Y}) && \text{for } i \in [1,\ell]
                    \end{align*}
                \item Verify proof $\pi$ using the pairing equation for $v_s$
                \item Accept if all checks pass
            \end{itemize}
    \end{itemize}
\end{itemize}
\end{itemize}


\newpage
\begin{itemize}
    \item \textbf{Precomputed Values}
    \begin{itemize}
        \item Base pairings: $(e(\tilde{a}, \hat{g}), e(\tilde{a}, \widehat{Y}))$ \qquad $2$ stored $\G_T$ elements
    \end{itemize}

    \item \textbf{Prover's Initial Operations (Signature Randomization)}
    \begin{itemize}
        \item $(\tilde{a}, \tilde{b}, \{\tilde{A_i}\}, \{\tilde{B_i}\}, \tilde{c}) \gets (a^{r'}, b^{r'}, \{A_i^{r'}\}, \{B_i^{r'}\}, c^{rr'})$ \qquad $(2\ell + 3)E_{\G_1}$
    \end{itemize}
    
    \item \textbf{Prover Schnorr Operations}
    \begin{itemize}
        \item Sample $\ell+1$ field elements $(\tilde{m_1},\ldots,\tilde{m_\ell}, \tilde{r})$ \qquad (negligible)
        \item Compute commitment $T \gets v_x \cdot \prod_{i=1}^\ell e(\tilde{A}_i, \widehat{Y})^{\tilde{m_i}}$ \qquad $\ell E_{\G_T} + (\ell-1)M_{\G_T}$
    \end{itemize}
    
    \item \textbf{Proof Size / Data Sent}
    \begin{itemize}
        \item $(\tilde{a}, \{\tilde{A}_i\}, \tilde{b}, \{\tilde{B}_i\}, \tilde{c}, T)$ \qquad $(2\ell + 3)$ elements in $\G_1$, $1$ element in $\G_T$
        \item $z_x$ for $x \in \{m_1,\ldots,m_\ell, r\}$ \qquad $(\ell + 1)$ elements in $\Z_p^*$
    \end{itemize}
    
    \item \textbf{Verifier Operations}
    \begin{itemize}
        \item Structure verification: $e(\tilde{b}, \hat{g}) \stackrel{?}{=} e(\tilde{a}, \widehat{Y})$ \qquad $2P$
        \item Attribute consistency: $\{e(\tilde{B}_i, \hat{g}) \stackrel{?}{=} e(\tilde{A}_i, \widehat{Y})\}_{i=1}^\ell$ \qquad $2\ell P$
        \item Challenge verification: $v_s \stackrel{?}{=} v_x \cdot \prod_{i=1}^\ell e(\tilde{A}_i, \widehat{Y})^{z_{m_i}}$ \qquad $\ell P + \ell E_{\G_T} + (\ell-1)M_{\G_T}$
    \end{itemize}
\end{itemize}



% % % % % % % % % % 
% 
% CL04 FINISH
% 
% % % % % % % % % % 



\newpage
\subsection{Analysis No Optimization}
\begin{tabular}{|l|p{4.5cm}|p{4.5cm}|p{3.5cm}|}
    \hline
    \textbf{Protocol} & \textbf{Show (Prover)} & \textbf{Verify (Verifier)} & \textbf{Data Sent} \\
    \hline
    CL04 &
    \textbf{Randomize:}
    \begin{itemize}[nosep]
        \item $(2\ell + 3)E_{\G_1}$ (sig. rand.)
    \end{itemize}
    \textbf{Schnorr Proof:}
    \begin{itemize}[nosep]
        \item $(\ell+1)$ samplings
        \item $\ell E_{\G_T} + (\ell-1)M_{\G_T}$ (commits)
    \end{itemize}
    &
    \begin{itemize}[nosep]
        \item $(2\ell + 2)P$ (struct. verify)
        \item $\ell P + \ell E_{\G_T} + (\ell-1)M_{\G_T}$ (chall. verify)
    \end{itemize}
    &
    \begin{itemize}[nosep]
        \item $(2\ell + 3)\G_1$
        \item $1\G_T$
        \item $(\ell + 1)\Z_p^*$
    \end{itemize}
    \\
    \hline
    BBS+ &
    \textbf{Randomize:}
    \begin{itemize}[nosep]
        \item $2F_p\times$ (deltas)
        \item $4E_{\G_1} + 2M_{\G_1}$ (sig. rand.)
    \end{itemize}
    \textbf{Schnorr Proof:}
    \begin{itemize}[nosep]
        \item $4E_{\G_1} + 2M_{\G_1}$ (commits)
        \item $1P + (L+4)E_{\G_T} + (L+3)M_{\G_T}$
    \end{itemize}
    &
    \begin{itemize}[nosep]
        \item $6E_{\G_1} + 4M_{\G_1}$ (commits)
        \item $2P + (L+4)E_{\G_T} + (L+3)M_{\G_T}$
    \end{itemize}
    &
    \begin{itemize}[nosep]
        \item $5\G_1$
        \item $1\G_T$
        \item $(L+6)\Z_p^*$
    \end{itemize}
    \\
    \hline
    BBS+ 2016 &
    \textbf{Randomize:}
    \begin{itemize}[nosep]
        \item $1F_p^- + 2F_p\times$ (field ops)
        \item $3E_{\G_1} + 1M_{\G_1}$ (sig. rand.)
        \item $(n+2)E_{\G_1} + (n+1)M_{\G_1}$ (attr. commit)
    \end{itemize}
    \textbf{Schnorr Proof:}
    \begin{itemize}[nosep]
        \item $(n+4)$ samplings
        \item $(n+2)E_{\G_1} + nM_{\G_1}$ (commits)
    \end{itemize}
    &
    \begin{itemize}[nosep]
        \item $2P + 1M_{\G_T}$ (pairing)
        \item $(n+4)E_{\G_1} + (n+2)M_{\G_1}$ (commits)
    \end{itemize}
    &
    \begin{itemize}[nosep]
        \item $5\G_1$
        \item $(n+4)\Z_p^*$
    \end{itemize}
    \\
    \hline
    PS16 & 
    \textbf{Randomize:}
    \begin{itemize}[nosep]
        \item $3E_{\G_1} + 1M_{\G_1}$ (sig. rand.)
    \end{itemize}
    \textbf{Schnorr Proof:}
    \begin{itemize}[nosep]
        \item $(\ell+2)P + (\ell+1)E_{\G_T} + (\ell+1)M_{\G_T}$
    \end{itemize}
    & 
    \begin{itemize}[nosep]
        \item $(\ell+3)P$
        \item $(\ell+1)E_{\G_T}$
        \item $(\ell+2)M_{\G_T}$
    \end{itemize}
    & 
    \begin{itemize}[nosep]
        \item $2\G_1$
        \item $1\G_T$
        \item $(\ell+2)\Z_p^*$
    \end{itemize}
    \\
    \hline
    PS UTT &
    \textbf{Randomize:}
    \begin{itemize}[nosep]
        \item $4E_{\G_1} + 2M_{\G_1}$ 
        \item $1E_{\G_2} + 1M_{\G_2}$
    \end{itemize}
    \textbf{Schnorr Proof:}
    \begin{itemize}[nosep]
        \item $(\ell+1)E_{\G_1} + \ell M_{\G_1}$ 
        \item $1E_{\G_1} + 1M_{\G_2} + 1P$ 
    \end{itemize}
    &
    \begin{itemize}[nosep]
        \item $(\ell+3)E_{\G_1} + (\ell+2)M_{\G_1} + 1M_{\G_2}$
        \item $1E_{\G_T} + 2M_{\G_T}$
        \item $4P$ 
    \end{itemize}
    &
    \begin{itemize}[nosep]
        \item $5\G_1$
        \item $1\G_2$
        \item $(\ell+2)\Z_p$
    \end{itemize}
    \\
    
     \hline
\end{tabular}






% % % % % % % % % % 
% 
% OPTIMISATIONS
% 
% % % % % % % % % % 

\newpage
\subsection{Optimizations}
Most cryptographic papers analyze computational complexity in a theoretical sense without regarding optimizations available for operations within their credentials. 
For example, some schemes measure the complexity of multiple pairing operations \cite{sako_short_2016} but do not take into account optimizations such as computing Miller Loop and Final Exponentiation separately, algorithms available in practical cryptography libraries. We discuss optimizations found in many cryptography libraries below and the impact they have in practical implementations.

\begin{itemize}
    \item \textbf{Pairing Optimizations:}
    \begin{itemize}
        \item \textbf{Miller Loop + Final Exponentiation:} 
        A pairing computation (e.g., Tate, Ate) consists of two distinct phases, denoted as $e(P,Q)$ in complexity analysis:
        \begin{itemize}
            \item \textit{Miller Loop}: Computes a rational function over points (complexity linear in loop length)
            \item \textit{Final Exponentiation}: Ensures unique representation in the target group $\mathbb{G}_T$
        \end{itemize}
        
        For products of pairings, we can optimize:
        \[
        \prod_{i=1}^\ell e(g_i, \hat{h}_i) = \text{FinalExp}\left(\prod_{i=1}^\ell \text{MillerLoop}(g_i, \hat{h}_i)\right)
        \]
        
        \noindent The left-hand side requires:
        \begin{itemize}
            \item $\ell$ complete pairings ($\ell P$)
            \item $(\ell-1)$ multiplications in $\mathbb{G}_T$ ($(\ell-1)M_{\mathbb{G}_T}$)
        \end{itemize}
        
        \noindent The right-hand side reduces to:
        \begin{itemize}
            \item $\ell$ Miller Loops ($\approx 0.4\ell P$)
            \item 1 Single Final Exponentiation ($\approx 0.6P$)
        \end{itemize}
        
        \item \textbf{Batch Pairing Inversion:} For equations of the form $e(a,b) = e(c,d)$, transform to:
        \[
        e(a,b) \cdots e(c^{-1},d) \stackrel{?}{=} 1_{\mathbb{G}_T}
        \]
        This optimization reduces standalone pairing counts by approximately 50\% through the elimination of redundant Final Exponentiations.
    \end{itemize}
    
    \item \textbf{Multi-Scalar Multiplication (MSM):}
        Multi-scalar multiplication addresses the common operation of computing:
        \[
            T = \prod_{i=1}^\ell g_i^{m_i}
        \]
        where $g_i$ are group elements and $m_i$ are scalar exponents. A naive approach computing each $g_i^{m_i}$ separately would require $\ell$ independent exponentiations. However, several algorithms exist that can compute this product significantly faster by processing multiple scalars simultaneously, similar to how carrying works in manual addition. These optimizations reduce the complexity from $O(\ell)$ exponentiations to sublinear complexity in $\ell$.
        

    This is useful in Anonymous Credentials, we use it with:
    \begin{itemize}
        \item Commitment openings involving multiple attributes
        \item Proof generation with multiple blinding factors
        \item Verification equations combining multiple witnesses
    \end{itemize}
    All schemes we denote benefit from MSM.
    
    \item \textbf{Precomputation Strategies:} 
    \begin{itemize}
        \item Cache frequently used pairing results: $e(g_i, \hat{h}_j)$ for fixed bases
        \item Optimize BBS+ operations: Transform $\prod_{i=1}^L e(g_{i+1}, \hat{h}_0)^{\tilde{m}_i}$ into $L$ multiplications in $\mathbb{G}_T$
        \item Store processed group elements for repeated operations
    \end{itemize}
    
    \item \textbf{Batch Verification:}
    \begin{itemize}
        \item For $N$ BBS+ proofs under a common public key:
        \begin{align*}
            \prod_{i=1}^N e(A_i, \hat{w}_i) \stackrel{?}{=} e(g, \hat{h}_0)^N \cdot \prod_{j=1}^n e(g_j, \hat{h}_j)^{\sum_{i=1}^N m_{i,j}}
        \end{align*}
        This optimization reduces complexity from $O(N \cdot n)$ to $O(n + N)$ pairings
    \end{itemize}
\end{itemize}

\subsubsection*{Practical Implications}
\begin{itemize}
    \item \textbf{PS2016:} Leverages pairing batching optimizations effectively but requires q-type assumptions
    \item \textbf{BBS+:} Employs precomputation and MSM optimizations for attribute handling, though proof size remains linear
    \item \textbf{PSUTT:} Achieves balance between succinctness and token updatability through careful application of MSM optimizations
\end{itemize}






\newpage
\section{Improvements}


\subsubsection{$\G_1$ Signature}
We change the signature algorithm from signing in G1 to signing in G2, this gives a bigger signature (2 x G2 instead of 2 x G1) but faster verification.    

\noindent $\mathsf{RS.Ver}(\sigma, \widetilde{\cm'}, ..)$ takes in $\sigma_2 \in \G_1$, and $\widetilde{\cm'} \in \G_2$. My intuition is we need to do the pairing equality check $e(\cm', \tilde{g}) = e(g, \widetilde{\cm'}) $ to be able to use $\cm \in \G_1$ for $\mathsf{PoK}$ because it's not explicitly used in the pairing verification, the $\G_2$ commitment is. The verifier needs to know why it can trust it.

\begin{itemize}
   \item $\mathsf{CM.Setup:} \ck \gets (g, (g_1,\ldots,g_\ell), \tilde{g}, (\tilde{g}_1,\ldots,\tilde{g}_\ell))$
   
   \item $\mathsf{RS.KeyGen:} ({\sk}, \widetilde{\vk}) \gets (g^x, \tilde{g}^x)$, return $({\sk}, \widetilde{\vk})$
   
   \item $\mathsf{RS.Sign:}$ ${\sigma} \in \G_1 \gets ({\sigma_1}, {\sigma_2}) = (h, ({\sk} \cdot {\cm})^u)$
   
   \item $\mathsf{RS.Rerand:}$ \qquad ${\sigma_1}' \gets {\sigma_1}^{u_\Delta}$ \qquad ${\sigma_2}' \gets ({\sigma_2} \cdot {\sigma_1}^{r_\Delta})^{u_\Delta}$ \qquad $\cm' \gets \cm \cdot g^{r_\Delta}$ \qquad  $\widetilde{\cm}' \gets \widetilde{\cm} \cdot \tilde{g}^{r_\Delta}$
   
   \item $\mathsf{RS.Ver}(\widetilde{\vk}, \cm', {\sigma}') \to \bit:$ 
   \[
   e(\sigma_2', \tilde{g}) = e(h, \vk \cdot \widetilde{\cm'}) \qquad \wedge \qquad  e(\cm', \tilde{g}) = e(g, \widetilde{\cm'}) 
   \]
   \[
    \pi \gets \mathsf{PoK}\{(r + r_\Delta, m_1,\ldots,m_\ell): \cm' = g^{r + r_\Delta} \prod_{i=1}^\ell g_i^{m_i}
    \]
\end{itemize}





\subsubsection{$\G_2$ Signature}
\noindent When $\sigma_2 \in \G_2$, and $\mathsf{RS.Ver}(\cm' \in \G_1, \widetilde{\sigma} \in \G_2)$ is a pairing verification with $\cm' \in \G_1$. Using $\cm' \in \G_1$ we can follow with $\mathsf{PoK}$
\begin{itemize}
    \item $\mathsf{CM.Setup:} \ck \gets (g, (g_1,\ldots,g_\ell), \tilde{g}, (\tilde{g}_1,\ldots,\tilde{g}_\ell))$

    \item $\mathsf{RS.KeyGen:} (\widetilde{\sk}, \vk) \gets (\tilde{g}^x, g^x)$, return $(\widetilde{\sk}, \vk))$
    
    \item $\mathsf{RS.Sign:}$ $\widetilde{\sigma} \in \G_2 \gets (\widetilde{\sigma_1}, \widetilde{\sigma_2}) = (\tilde{h}, (\tilde{\sk} \cdot \widetilde{\cm})^u)$
    
    \item $\mathsf{RS.Rerand:}$ \qquad $\widetilde{\sigma_1}' \gets \widetilde{\sigma_1}^{u_\Delta}$ \qquad $\widetilde{\sigma_2}' \gets (\widetilde{\sigma_2} \cdot \widetilde{\sigma_1}^{r_\Delta})^{u_\Delta}$ \qquad $\cm' \gets \cm \cdot g^{r_\Delta}$ \qquad  $\widetilde{\cm}' \gets \widetilde{\cm} \cdot \tilde{g}^{r_\Delta}$
    
    \item $\mathsf{RS.Ver}(\vk, \cm', \widetilde{\sigma}') \to \bit:$ 
    \[
    e(g, \widetilde{\sigma_2}') = e(\mathsf{vk} \cdot \mathsf{cm}',\widetilde{\sigma_1}')
    \]
   \[
    \pi \gets \mathsf{PoK}\{(r + r_\Delta, m_1,\ldots,m_\ell): \cm' = g^{r + r_\Delta} \prod_{i=1}^\ell g_i^{m_i}
    \]
\end{itemize}


\subsubsection{$\G_2$ Correctness}
\begin{enumerate}
    \item Prove $e(g, \widetilde{\sigma_2}') = e(\mathsf{vk} \cdot \mathsf{cm}', \widetilde{\sigma_1}')$
    
    \begin{align*}
        e(g, \widetilde{\sigma_2}') &= e(g, (\widetilde{\sigma_2} \cdot \widetilde{\sigma_1}^{r_\Delta})^{u_\Delta}) \\
        &= e(g, (\widetilde{\sk} \cdot \widetilde{\cm}^{u})^{u_\Delta} \cdot \tilde{h}^{r_{\Delta} \cdot u_\Delta}) \\
        &= e(g, \widetilde{\sk}^{u_\Delta}) \cdot e(g, \widetilde{\cm}^{u + u_\Delta}) \cdot e(g,\tilde{h}^{r_{\Delta} \cdot u_\Delta}) \\
        &= e(g^x, \widetilde{h}^{u_\Delta}) \cdot e(g, \widetilde{\cm})^{u + u_\Delta} \cdot e(g,\tilde{h}^{u_\Delta})^{r_{\Delta}} \\
        &= e(\vk, \widetilde{h}^{u_\Delta}) \cdot e(\cm, \widetilde{h}^{u_\Delta}) \cdot e(g^{r_{\Delta}},\tilde{h}^{u_\Delta}) \\
        &= e(\vk \cdot \cm \cdot g^{r_{\Delta}}, \sigma_1')  \\
        &= e(\vk \cdot \cm', \sigma_1')  \\
    \end{align*}

    \item then PoK
    \[
        \pi \gets \mathsf{PoK}\{(r + r_\Delta, m_1,\ldots,m_\ell): \cm' = g^{r + r_\Delta} \prod_{i=1}^\ell g_i^{m_i}
    \]
\end{enumerate}


\begin{table}[ht]
\centering
\begin{tabular}{l|cc|ccc}
\toprule
\multirow{2}{*}{\textbf{Scheme}} & \multicolumn{2}{c|}{\textbf{Show}} & \multicolumn{3}{c}{\textbf{Verify}} \\
\cmidrule(lr){2-3} \cmidrule(lr){4-6}
& Credential & PoK & Credential & PoK & Data Sent \\
\midrule
PSUTT 
& \makecell{$4E_{\G_1} + 1E_{\G_2}$} 
& \makecell{$1E_{\G_1} + 1P$ \\ $MSM(\ell + 1)\G_1$} 
& \makecell{$1E_{\G_T}$ \\ $4M\text{Loop}\G_T + 1FE_{\G_T}$} 
& $MSM(\ell + 2)_{\G_1}$ 
& \makecell{$5\G_1 + 1\G_2 + (\ell + 2)\Z_p$} \\
\midrule
PSUTT+LVS 
& \makecell{$3E_{\G_2} + 1E_{G_1}$} 
& \makecell{$ 1E_{G_1} +$ \\ $MSM(\ell + 1)_{\G_1}$} 
& \makecell{$2M\text{Loop}\G_T + 1FE_{\G_T}$} 
& \makecell{$MSM(\ell + 1)_{\G_1} + 1E_{\G_1} $}
& \makecell{$2\G_1 + 2\G_2 + (\ell + 1)\Z_p$} \\
\bottomrule
\end{tabular}
\caption{Removed scalar point multiplications and anything in $\F_p$}
\label{tab:unified-comparison}
\end{table}

\subsubsection{Optimizations moving to $\sigma \in \G_2$}
\begin{itemize}
    \item Show Cred changes from 4EG1 + 1EG2 to 3EG2 + 1EG1 ()
    \item PoK changes from $1E_{\G_1} + 1P + MSM(\ell + 1)\G_1$ $\quad \Rightarrow \quad$ $ 1E_{G_1} +MSM(\ell + 1)_{\G_1}$ --- We remove the pairing!
    \item Verify cred changes from $1E_{\G_T} + 4M\text{Loop}\G_T + 1FinalExp_{\G_T}$ $\quad \Rightarrow \quad$ $2M\text{Loop}\G_T + 1FinalExp_{\G_T}$ --- reduce 2 miller loop and 1 GT exponentiation
\end{itemize}
