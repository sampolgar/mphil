\section{Introduction}\label{sec:intro}
Digital Identity systems form the foundation of online trust and authentication, processing billions of verifications daily \cite{noauthor_happy_2021, pang_zanzibar_nodate}. Traditional centralized systems, while effective for regulatory compliance \cite{eltayeb_crucial_2024}, suffer from significant privacy and security vulnerabilities. Ongoing data breaches \cite{zhang_data_2022} affect billions of users, demonstrating the risks of storing identity data and centralizing systems. Decentralized Identity (DID) is a loosely defined framework (W3C specification) having evolved over the past 2 decades, offering users greater control over their credentials \cite{soltani_survey_2021}, many concrete implementations struggle to balance privacy with accountability \cite{maram2021candid} for the required feature set. 


\noindent Anonymous Credential Systems (ACS) \cite{chaum1985security,hutchison_signature_2004, hutchison_constant-size_2006, sako_short_2016, fuchsbauer_structure-preserving_2019} address privacy concerns but face challenges balancing privacy with accountability, orthogonally, unconditionally anonymous payment systems have demonstrated how unconditional anonymity can enable system abuse. Current systems focus on protecting against sybil attacks \cite{crites_syra_2024, rabaninejad_attribute-based_nodate}, enabling revocation \cite{goos_dynamic_2002, robshaw_uc_2016, camenisch_scalable_2016, baldimtsi_accumulators_2017}, rich attribute-based credential authentication \cite{rosenberg_zk-creds_2022, babel_bringing_2023} but very few implement all. The tension between privacy and accountability has become increasingly critical as governments worldwide, particularly the EU's Digital Identity Framework \cite{noauthor_regulation_2024}, move toward privacy-preserving digital identity wallets. These challenges motivate the need for a comprehensive identity system that achieves privacy, accountability, and practical deployment requirements simultaneously.

\subsection{Paper Layout}
Section \ref{sec:intro} introduces the problem, the gap, and relatex work. Section \ref{sec:overview} is the system overview, 3 describes 

\begin{enumerate}
    \item section \ref{sec:protocoldescription} is the full construction of the multi-issuer, multi-credential anonymous credential scheme using sigma proofs as a black-box
    \item section \ref{sec:sigmaproofs} outlines the sigma proofs within the construction
    \item section \ref{sec:identitysystem} builds a private identity system from  
\end{enumerate}

Section \ref{sec:protocoldescription}

\subsection{Related Work}

\subsubsection{Decentralized Identity (DID)}
enables entities to create and manage digital identities without relying on a central authority. W3C specifications for DID and Verifiable Credentials define standards for globally unique, publicly verifiable credentials, allowing a user to prove claims (information) about their identity attributes. DID typically uses Distributed Ledgers and public key cryptography to establish a "web of trust" and maintain revocation registries. 

The DID model consists of 
\begin{enumerate}
    \item \textbf{Holders} Identities with Decentralized Identifiers (DID's) who manage their own keys, and credentials, and request access to resources
    
    \item \textbf{Issuers} create and sign credentials about identity holders
    
    \item \textbf{Verifiers} validate credentials by checking the presented cryptographic information against the registry

    \item  \textbf{Verifiable Data Registry}, often a DLT, is the root of trust, maintaining DID records, keys, and credential schemas, but doesn't store credential data
    
    \item \textbf{Identity Wallet}: the user interface for storing, managing, and presenting verifiable credentials
\end{enumerate}
 
Citations
- U-Prove, U-Port, Connect.me, Sovrin, PingID, w3c

While the W3C DID specifications outline core functionalities such as cryptographic verification, privacy preservation, selective disclosure, and revocation, it requires a formal security definition and proofs to achieve these properties. Anonymous Credential Systems provide well-established formal security definitions for many properties that DID aims to achieve. Specifically, Correctness, Unforgeability, Anonymity, Sybil Resistance, and Revocation. By building DID systems on top of Anonymous Credential primitives, DID systems can inherit these formal security guarantees. 

\subsubsection{Multi Attribute Anonymous Credentials} 
Anonymous Credentials are a long line of orthogonal work with the goal of providing privacy/anonymity to online interactions, These are now deployed in a number of real-world systems (U-Prove, Idemix, PrivacyPass).  
The line of work has improved with features, efficiency, and expressiveness throughout time. 
Abstractly, they provide private protocols to prove information on committed attributes. 
Pairing-based blind signatures enabled efficient multi-show credentials (CL, PS, BBS+).
Other constructions are based on (chase's MAC's, etc) 
Further work was done to the Anonymous Credential primitive to support delegation, update, and pseudonyms and may also require incorporating other cryptographic primitives to enable revocation, auditing, tracing, and sybil resistance. 

\subsubsection{Anonymous Credential Systems (ACS)} 
Anonymous Credential Systems implement primitives together in ways that preserve privacy and offer additional functionality required by systems. The combination of multiple primtiives to be used together in a privacy preserving way is complex it itself. 

\noindent \textbf{Accountable Privacy}
In a parallel industry, fully private financial systems like zcash, monero, and tornado cash where blockchain users can exploit and misuse the system is a big problem and will prevent governments and organisations to deploy private preserving techniques. Innovations in Identity often follow those in financial systems, (Chaum's e-cash and blind signatures, DAC and ZCash for example) as they share similar motivations and infrastructure, spending a coin anonymously is analogous to using an identity anonymously. Therefore, advancements in the field of Accountable Privacy (UTT, other examples), a series of techniques and protocols that balance the tradeoffs between privacy and accountability in financial systems, can inspire and motivate private identity systems.

\noindent \textbf{Privacy Preserving Decentralized Identity Systems}
CanDID proposed a privacy-preserving decentralized identity system achieving Sybil Resistance, Accountability. 
They defined a system architecture that has been extended in many different directions, such as \cite{wang2023hades, rathee_zebra_2022} optimising for blockchain performance and additional private-accountability features. \cite{crites_syra_2024, rabaninejad_attribute-based_nodate} optimize for non-interactivity and minimal stored state with the CanDID threshold committee

CanDID leaves integrating Decentralized Identity with Anonymous Credentials as open work.

\noindent \textbf{Decentralized Identity with Anonymous Credentials}
The strawman approach to combining Decentralized Identity with Anonymous Credentials replaces the existing credential, usually in the form of a signature over attributes, signed by an identity provider and verifiable with their public key, with a blind signature over attributes, which introduces the accountable privacy problems such as how to issue and verify a credential to an anonymous user, and how to retain accountability of an anonymous user, such are the real-world identity system requirements. 
Compatibility for a decentralized architecture requires decentralized cryptography which has propelled the use of threshold cryptography in anonymous credential schemes and other settings e.g. (Coconut, Threshold BBS+, ...). 


\newpage

\subsection{Contributions}

We present a privacy-preserving decentralized identity system for multi-issuer environments. Our system combines anonymous credential primitives with decentralized identity architecture, achieving security and privacy properties that are challenging to realize when naively combining these building blocks. Our main contributions are:

\begin{enumerate}
    
    \item  A privacy-preserving identity system that enables secure credential chaining and complex anonymous identity verification across multiple issuers.

    \item A novel zero-knowledge building block that enables private proofs of VRF derivations from committed messages.
    
    \item  A complete system implementation using PS Signatures over commitments that achieves sybil resistance and revocation while enabling multi-issuer credential chaining - validated through concrete implementations, benchmarks, and formal security analysis.

\end{enumerate}

\subsection{Gap Analysis}

Digital identity is undergoing a fundamental transformation, evolving across three frontiers: decentralization, mandatory institutional adoption, and the emergence of attestation services.    
Identity systems are evolving from trusted, single-issuer models where a user authenticates with a single authority toward a decentralized paradigm where users publicly verify any multitude of credentials, manage multiple credentials for diverse issuers with their digital wallets.

\noindent As traditional organizations increasingly adopt decentralized identity capabilities and while it's also being mandated in the EU, they seek solutions that minimize changes to their existing infrastructure while enabling new DID capabilities and maintaining regulatory compliance. Beyond traditional organisations, a new frontier of credential issuance is emerging through automated attestation services like TLS Notary, Chainlink's DECO, Brave Browser's distefano, and Sui Labs zkLogin which enable verifiable data to become a credential. This transformation, while powerful, introduces challenges to identity systems run by governments and trusted organisations  who require sybil resistance protecation and revocation while maintaining privacy in a system where traditional infrastructure assumptions such as ease of revocation no longer hold.

\noindent \textbf{Core Challenges} Evolving from single-issuer to multi-issuer, multi-credential environments introduces several challenges. While existing solutions support private identity systems with anonymity, sybil resistance and revocation for single issuers. The introduction of multiple credentials and their sources transforms solved problems into new challenges. A decentralized system for the frontier of credentials must maintain anonymity across credential presentations, implement cross credential sybil resistance and efficient revocation checks without centralized trust.

\noindent Additionally, composing privacy-preserving primitives together to achieve the properties we require introduces complexity. While individual primitives for anonymous credentials, Sybil resistance, and revocation are well understood in isolation, the integration highlights the trilemma of accountable privacy systems - the tension between privacy, accountability, and functionality. The core challenge lies in designing efficient zero knowledge proof systems that combine these primitives in protocols that maintain the security and privacy properties of our system with practical efficiency.

\noindent Thirdly arises when users verify attributes from multiple credentials. Secure credential composition is required, while allowing flexible zero knowledge proof attribute attestations and selective disclosure. Lastly, users with multiple credentials require to privately prove their credentials are not revoked, introducing a scaling challenge - enabling efficient zero-knowledge batch proofs of non-membership while maintaining privacy and practical verification times. 




\subsection{Technical Challenges}

Building a privacy-preserving decentralized identity system requires balancing competing requirements: adhereing to strong security and privacy properties while retaining accountability measures and providing efficient verification of complex identity statements. While individual cryptographic primitives exist for many of these properties in isolation, combining them while maintaining security and efficiency introduces technical challenges, we identity three fundamental challenges below: 

\begin{enumerate}

    \item \textbf{Efficient Rerandomizable Signatures over Commitments} A key technical challenge was designing a signature scheme that efficiently supports both rerandomization and zero-knowledge proofs over-committed attributes. While existing schemes like BBS+, CL, and standard PS provide these properties, we use a customized PS signature with the lowest overhead in the randomization step. %what I want to say here is that after the randomization step, we are given a commitment in G1 which is easy and efficient to work with, rather than some other construction which needs custom proofs and new security proofs for each system built with it. 
    Unlike BBS+ and CL04, we maintain compatibility with standard Pedersen Commitments, enabling efficient proofs from standard techniques in the literature.
    

    \item \textbf{Sybil-Resistant Context Credential Construction} Designing an efficient mechanism to link context credentials to a master credential while preserving privacy, our solution uses a novel building block that combines a VRF with committed attributes - the user's Master Credential contains a commitment with their VRF key and generates a context credential nullifier with a VRF parameterized by the key and input the context string. 
    The complexity lies in efficiently proving in zero knowledge this nullifier was correctly derived from the committed key present in a valid, unrevoked master credential. This construction enables strong sybil resistance while maintaining unlinkability between presentations.


    \item \textbf{Efficient Multi-Credential Proofs and Revocation} enabling efficient proofs over multiple credentials while ensuring practical revocation. Our construction leverages Sigma protocols and Pedersen commitments, which, although they scale linearly with the credential attributes, they are extremely efficient in practice and support the most expressive statements. We integrate existing efficient revocation mechanisms that support batch non-membership proofs, allowing multiple credentials to be efficiently verified simultaneously while maintaining anonymity through zero-knowledge proof protocols. 

\end{enumerate}


\subsubsection{Comparison}


\begin{table}
\begin{center}
\caption{Comparison of our construction over previous work.}
\label{tab:comparison}
\begin{tabular}{l|cccccc}
Features    									& Multi Issuer & Sybil Resistance  & Revocation & Efficient Cred. Chaining$\footnotemark[1]$ & M-ABC$\footnotemark[2]$   & Anonymity$\footnotemark[3]$   \\
\hline

CanDID \cite{maram2021candid}     				& \ding{51}     & \ding{51} 	& \ding{51}  &  \ding{55}     & \ding{55}                     & \ding{55}		\\
SyRA \cite{crites_syra_2024}     				& \ding{55}     & \ding{51}    	& \ding{55}  &  \ding{55}     & \ding{55}                     & \ding{51}		\\
S3ID \cite{rabaninejad_attribute-based_nodate}  & \ding{51}     & \ding{51}    	& \ding{55}  &  \ding{51}     & \ding{55}\footnotemark[4]     & \ding{51}		\\
Our Work  										& \ding{51}     & \ding{51}    	& \ding{51}  &  \ding{51}     & \ding{51}                     & \ding{51}		\\
\end{tabular}
\end{center}

\vspace{1em}
\footnotesize
$\footnotemark[1]$ Credential Chaining is a user presenting multiple credentials to be verified together for a complex identity statement.

\footnotesize
$\footnotemark[2]$ M-ABC is a Multi-Show Attribute Based Credential, allowing a user to satisfy rich, attribute-based identity statements 

\footnotesize
$\footnotemark[3]$ Anonymity is defined in the Anonymous Credential model, no verifier and issuer (collaborating together) may learn more about the user or their credentials other than what the user discloses and what their credentials verify. Multiple credential verifications are unlinkable.

\footnotesize
$\footnotemark[4]$ While possible in S3ID, they mention 

\footnotesize
$\footnotemark[5]$ Multi-issuer means supporting credentials from different authorities that can be cryptographically linked while preserving privacy
\end{table}

\todonote{S3ID is inefficient for attribute-based verification, this table doesn't show that}

















\cleardoublepage
\section{Identity System Overview}\label{sec:overview}

\subsection{Entities}
Our identity system involves users, credential issuers, auditors, and credential verifiers.

\noindent \textbf{User} ($\User$) holds a master credential $Cred_{master}$ and any number of context credentials $Cred_{ctx}$ in their identity wallet. The master credential contains a unique identifier $s$, a VRF key $k$, and additional attributes, and is issued by a government entity. Context credentials are issued by participating organizations like universities or licensing authorities.

\noindent \textbf{Credential Oracle} ($\MCO, \CCO$) verifies user identity and issues digital credentials. The Master Credential Oracle $\MCO$ operates with keypair $(SK_{m}, PK_{m})$ for issuing "root" credentials, while Context Credential Oracles $\CCO$ use $(SK_{c}, PK_{c})$ for issuing domain-specific credentials.

\noindent \textbf{Auditor} ($\Auditor$) consists of a threshold of nodes holding encryption and accumulator keypairs; for simplicity, we refer to both as $(sk_A, pk_A)$. Users encrypt their VRF keys under the auditors' public key, as in key escrow schemes. Auditors can decrypt this key during revocation. The Auditor updates the revocation list. 

\noindent \textbf{Verifier} ($\Verifier$) represents any party wishing to verify a user's credentials.


\subsection{Data Objects}

We now describe the data objects that form our privacy-preserving decentralized identity system. At its core, a Master Credential serves as a root of trust, from which Context Credentials can be derived. During Context Credential issuance, users generate a deterministic nullifier unique to each context using their Master Credential's secrets and the context string, enabling privacy-preserving credential linking.

\subsubsection{Master Credential $Cred_m$}: 
A master credential is a high-security root credential issued by a government entity containing:

\begin{itemize}
    \item Identity string $s$: a unique identifier
    \item VRF key $k$: used to generate context-specific nullifiers
    \item Context type $ctx$: always set to "master" for master credentials
    \item Additional attributes $attrs$: including expiry date, date of birth, etc.
    \item Credential Structure:
    \begin{itemize}
        \item Master Commitment $C_m = Com([s, k, ctx, attrs],r)$: A Pedersen commitment to the credential attributes using randomness $r$
        \item Oracle signature $\sigma_m$: A rerandomizable signature over $C_m$, verifiable under $PK_m$
    \end{itemize}
\end{itemize}

\subsubsection{Master Credential Oracle Data Record:} Following successful master credential issuance, the oracle maintains a record containing:
\begin{itemize}
    \item Commitment-Signature Pair $(C_m, Cred_m)$:
    \begin{itemize}
        \item Master commitment $C_m = Com([s,k,ctx,attrs],r)$: the Pedersen commitment over credential attributes
        \item Oracle Signature $Cred_m$ The signature over commitment $C_m$
    \end{itemize}
    \item Key Encryption and Proof:
    \begin{itemize}
        \item Encrypted VRF Key $CT_k$: the threshold encryption of the user's VRF key, encrypted with the Auditor's public key $TPKE.Enc_{PK_a}(k)$
        \item Consistency proof $\Pi_{CT}$: The zero-knowledge proof that $CT_k$ encrypts the committed key $k$
    \end{itemize}
\end{itemize}


\subsubsection{Context Credential $Cred_c$}: 
A user interacts with the Context Credential oracle to obtain a context-specific credential, which contains:
\begin{itemize}
    \item Identity string $s$: The user's unique identifier from their master credential
    \item Nullifier $\tau$: A deterministic value generated from $(s, ctx)$
    \item Context string $ctx$: A hashed identifier of the credential type (e.g., $dmv$, $universityofsydney$)
    \item Attribute list $attrs$: Additional credential-specific information such as expiry date
    \item $\sigma_c$ the rerandomizable signature over $C_c$ from the context credential oracle that proves the user has been issued $Cred_c$ over $C_c$
    \item Credential Structure:
    \begin{itemize}
        \item Context commitment $C_c$: A Pedersen commitment $Com([s, \tau, ctx, attrs],r')$ to the credential attributes using randomness $r'$
        \item Oracle signature $\sigma_c$: A rerandomizable signature over $C_c$, verifiable under $PK_c$
    \end{itemize}
    
\end{itemize}


\subsubsection{Context Credential Oracle Data Record:} During credential issuance, the oracle maintains a record of the interaction containing:
\begin{itemize}
    \item Master Credential Verification: 
        \begin{itemize}
            \item Randomized credential $Cred_m'$: a rerandomized version of the master credential
            \item Randomized commitment $C_m'$: the corresponding rerandomized commitment
            \item Opening proof $\Pi_{ComOpen}$: Zero-knowledge proof of correct commitment opening
            \item Revocation proof $\Pi_{NonRevoked}$:  Zero-knowledge proof that the credential has not been revoked
        \end{itemize}
    \item Nullifier Components:
    \begin{itemize}
        \item Context nullifier $\tau$: The value $VRF(k,ctx)$ derived from the user's committed VRF key and credential context
        \item Derivation proof $\Pi_{\tau}$: Zero-knowledge proof establishing that
        \begin{itemize}
            \item The VRF computation is correct
            \item The key $k$ matches the one committed in $Cred_m$
            \item The context string $ctx$ is correctly incorporated
        \end{itemize}
    \end{itemize}
\end{itemize}

\subsubsection{Revocation List:} 
\begin{itemize}
    \item Accumulator Structure:
    \begin{itemize}
        \item Accumulator value $A$: The current state of the accumulator representing non-revoked credentials
        \item Secret key $sk_A$: The accumulator manager's key for updates
        \item Auxiliary information $aux$: Additional data needed for witness updates
    \end{itemize}
    \item Revoked Elements:
    \begin{itemize}
        \item Master revocations $k$: VRF keys of revoked master credentials
        \item Context revocations $\tau$: Nullifiers of revoked context credentials
        \item Timestamp $t$: Time of revocation
        \item Reason code $rc$: Justification for revocation
    \end{itemize}
    \item Witness Management:
    \begin{itemize}
        \item Non-membership witness $w$: Proof that a credential is not in the revocation set
        \item Update information $upd$: Data for users to update their witnesses after accumulator changes
    \end{itemize}
\end{itemize}









\newpage
\subsection{Protocols}









\newpage
\subsection{Syntax}
Syntax of Anonymous Identity System with Sybil Resistance and Revocation
\begin{itemize}
    \item $\mathsf{Setup}(\secparam) \to (\ppar, \UL, \RL)$ Takes security parameter $\lambda$ in unary, outputs public parameters $\ppar$, empty user list $\UL$ and revocation list $\RL$.

    \item $\mathsf{OrgKeygen}(\ppar, n) \torand (\osk, \opk)$: is a probabilistic algorithm that takes public parameters $\ppar$ and $n$ the upper bound of credential attributes. Outputs organisations keypair $(\osk, \opk)$

    \item $\mathsf{UserKeygen}(\secparam) \torand (\usk)$ is a probabilistic algorithm. Outputs user secret key $\usk$ consisting of PRF key $k$ and identity string $s$

    \item $(\mathsf{Obtain}(usk, \textbf{m}, aux), \mathsf{Issue}(osk, cm, aux)) \to cred:$ An interactive protocol. $Obtain$ is a probabilistic alrogithm run by a user, inputs secret key, credential attribute vector $\textbf{m}$ and auxiliary info. $Issue$ is a probabilistic algorithm run by an issuing organization that takes a commitment $cm$, issuers secret key $osk$, and auxiliary info. Outputs a credential $cred$ binding $cm$ to the issuer signature.

    \item $(\mathsf{Show}(usk, cred, \phi), \mathsf{Verify}(cred', cm, \pi)) \to \bit$ An interactive protocol. $Show$ is a probabilistic algorithm run by a Prover. Takes secret key, credential, and predicate statement $\phi$. $Verify$ is a deterministic algorithm run by a verifier, takes a randomized credential and commitment $cred', cm'$ and proof $\pi$. Otuputs 1 if verification succeeds, otherwise 0.

    \item $\mathsf{Revoke}(\RL, k') \to \RL'$ revoke is a deterministic algorithm, updates revocation list with revoked key $k'$
\end{itemize}


\subsection{Security Model}

\subsubsection{Security Properties}
Our private identity system with Sybil Resistance satisfies the following security and privacy properties:
\begin{enumerate}
    \item \textbf{Correctness: } For any honestly generated credentials and valid witness values, verification accepts if and only if (1) the credentials were legitimately issued by the credential issuer. (2) the credentials satisfy the verification predicate $\phi$. (3) all commitments are well-formed with respect to their corresponding signed credentials. 
    
    \item \textbf{Unforgeability}: No probabilistic polynomial time adversary can (1) forge valid credentials for honest users. (2) use credentials belonging to other users. (3) combine multiple credentials to create new ones. (4) replay a credential show from a different user. 
    
    \item \textbf{Anonymity:} Given polynomial-time adversary views of credential verification, the adversary cannot (1) learn any information beyond the public information. (2) link multiple showings of the same credential. (3) Correlate different credentials belonging to the same user.
    
    \item \textbf{Sybil resistance}: For any given context, no probabilistic polynomial time adversary can obtain more than 1 valid credential with non-negligible probability 

    \item \textbf{Credential Binding}: For any polynomial-time adversary $\adv$, given a set of credentials $\{cred_1, \dots, cred_n\}$ the probability of producing a valid proof $\pi$ for a statement $\phi$ that links the credentials is negligible unless (1) all credentials were legitimately issued to the same user with master secret key $s$, (2) the user knows the opening of all credential commitments, (3) the linking proof demonstrates the same $s$ value across all credentials

\end{enumerate}

\subsubsection{Threat Model}
We assume the threshold committee maintaining the revocation list cannot be fully corrupted.
% look at Arke for a good threat model!


\begin{itemize}
    \item Malicious Credential Oracle: A malicious credential oracle could "falsely issue attestations and impersonate any user it desires. Fortunately, recent work on authenticating web data has shown privacy-preserving, untrusted and correct credential oracles can be realized in practice [DECO, distefano, etc]. Additionally, we mitigate the threat level by confining each credential oracle to a unique domain." - from Arke. 
    \todonote{fix this}
    \item Malicious User: attempts to obtain multiple credentials for the same context, tries to forge credentials or share them with others, attempts to link credentials with other credentials not issued to the same master secret key
    \item Malicious Issuer: attempts to link multiple showing, collude with issuers to deanonymize users, stores presentation proofs to track users
    \item Malicious Verifier: issue credentials without proper verification, attempts to track credential usage, colludes with issuers or other verifiers
\end{itemize}

\subsubsection{Trust Model}
\begin{itemize}
    \item Credential Oracles: trusted to verify real-world identity before issuing credentials, they aren't trusted for privacy and may be compromised but can't issue credentials without the user participating in their protocol

    \item Auditors: are trusted to only decrypt user keys for legitimate revocation requests, they cannot individually decrypt keys i.e. requires the threshold committee

    \item Threshold Committee: at most t-out-of-n members may be compromised, trusted for revocation list integrity, not trusted for privacy

    \item Network: communication assumed to be over encrypted channels, any storage is not trusted for credential contents
\end{itemize}






\newpage
\section{Protocol Description}\label{sec:protocoldescription}
Our identity system establishes a secure framework for issuing and managing privacy-preserving credentials across multiple authorities while maintaining accountability. The system involves four key entities: users, credential oracles (which verify and attest to user attributes), a threshold committee of auditors (who manage revocation), and credential verifiers.

\noindent At the core of our system is a master credential issued by a government credential oracle, which serves as a root of trust. This credential contains two crucial committed elements: a secret identifier $s$ that enables secure credential linking, and a committed VRF key $k$ that generates context-specific nullifiers. These nullifiers serve dual purposes: preventing Sybil attacks at credential oracles and enabling efficient revocation. During master credential issuance, the VRF key is verifiably encrypted to a threshold of auditors, the ciphertext is stored in the government system which associates a plaintext user profile to their ciphertext for revocation.


\noindent Users can obtain context credentials from various credential oracles by proving possession of a valid, unrevoked master credential and deriving a unique nullifier using their VRF key and the credential context. This design allows credential oracles to restrict issuance to users with trusted government-issued credentials, ensuring their credentials are only issued to verified identities. The system supports expressive verification statements that can combine attributes across multiple credentials. Since master credentials are government-issued and require stringent security checks, verifiers can leverage this trust by incorporating master credential validity, expiration, and revocation checks into their verification statements, inheriting the strong security properties of government-issued credentials. This enables credential oracles to maintain trust by ensuring their credentials become unusable if the underlying government credential is revoked.


\noindent The system supports flexible revocation through two mechanisms: targeted revocation of specific credentials via their nullifiers, and complete revocation of all user credentials by recovering their VRF key through the threshold committee. Government systems can initiate revocation by using plaintext identifiers, with auditors managing the conversion to the appropriate nullifiers. This approach maintains privacy while enabling practical accountability and administration.

\newpage
\subsection{Master Credential Issuance}
The master credential issuance protocol enables a user to obtain their root credential from the Master Credential Oracle $\MCO$ while preserving the privacy of their VRF key $k$ and ensuring accountability. The protocol combines Threshold Encryption, Verifiable Random Function, Zero Knowledge Proofs, and Rerandomizable PS Signatures over commitments to achieve Sybil Resistance, Revocation, and Anonymity.

\begin{center}
\begin{tabular}{l@{\hspace{12em}}c@{\hspace{12em}}l}
\multicolumn{3}{l}{$\underline{Setup(1^{\lambda}, 1^n)}$:} \\[0.5em]
\multicolumn{3}{l}{System: $(\G_1, \G_2, e, g, \tilg ) \gets BG.Gen(\secparam, p), \; ck_m \gets CM.Setup(BG, \secparam, n)$} \\[1em]
\multicolumn{3}{l}{Credential Oracle: $(SK_m, PK_m) \gets PS.KeyGen(ck_m)$} \\[1em]
\multicolumn{3}{l}{Auditor: $(SK_A, PK_A) \gets TPKE.KeyGen(ck_m)$} \\[1em]
\multicolumn{3}{l}{Auditor setup Revocation List} \\[1em]
\underline{User($s$)} && \underline{MCO($SK_M$)} \\[0.5em]
\multicolumn{3}{l}{$k_1 \gets \Z_p$, \; $C_1 \gets Com([0,k_1,0,0],r)$}\\[1em]
\multicolumn{3}{l}{$\Pi_1 \gets ZKPoK.Prove_{Zeros}(C_1)(k_1, r)$} \\[1em]
& $\xrightarrow{C_1, \Pi_1}$ & \\[1em]
\multicolumn{3}{r}{If $ZKPoK.Verify_{Zeros}(\Pi_1, C_1) = 0, $ return $ \bot$} \\[1em]
\multicolumn{3}{r}{$k_2 \gets \Z_p, \; C_2 \gets Com([s, k_2, "master", attrs], 0)$} \\[1em]
\multicolumn{3}{r}{$C_m \gets C_1 \cdot C_2 = Com([s,k_1+k_2,"master", attrs], r)$} \\[1em]
& $\xleftarrow{C_2, C_m, s, k_2}$ & \\[1em]
\multicolumn{3}{l}{$k \gets k_1 + k_2$} \\[1em]
\multicolumn{3}{l}{$\Pi_2 \gets ZKPoK.Prove_{addition}(C_1, C_2, C_m)(k_1, k_2, k, r)$} \\[1em]
\multicolumn{3}{l}{$\tau \gets TPKE.Enc(PK_A, k)$} \\[1em]
\multicolumn{3}{l}{$\Pi_3 \gets ZKPOK.Prove_{enc}(C_m)(\tau, k, r)$} \\[1em]
& $\xrightarrow{C_1, C_2, C_m, \Pi_2, \Pi_3, \tau}$ &\\[1em]
\multicolumn{3}{r}{If $ZKPOK.Verify_{addition}(\Pi_2, C_1, C_2, C_m) = 0, \;$ return $\bot$} \\[0.5em]
\multicolumn{3}{r}{If $ZKPOK.Verify_{enc}(C_m)(\Pi_3, PK_A, \tau)  = 0, \;$ return $\bot$} \\[0.5em]
\multicolumn{3}{r}{$\sigma_m \gets PS.Sign(SK_M, C_1)$} \\[0.5em]
\multicolumn{3}{r}{Store Data Record MCO $(C_m, \sigma_m, \tau, \Pi_2, \Pi_3, C_1, C_2, k_2)$ } \\[1em]
& $\xleftarrow{\sigma_m}$ & \\[1em]
\multicolumn{3}{l}{If $PS.Verify(PK_A, \sigma_m, C_m) = 1$, Store $Cred_m(\sigma_m, C_m)$} \\[1em]
\end{tabular}
\end{center}

\paragraph{Informal Security Analysis}

The two-party process between the user and master credential oracle ensures sybil resistance of unique identifier $s$; the oracle has access to the user information and checks duplicate issuance within their own identity system. 
During VRF key issuance, the anonymity of the master credential is preserved via the secrecy of the VRF key $k$. During the two-party computation, the user's share $k_1$ remains hidden to $\MCO$ via the hiding property of the commitment $C_1$, and malicious commitment usage is prevented by the soundness property of $\Pi_1$. 

\noindent The user combines  $k_1 + k_2$ to form their VRF key, $\Pi_2$ proves $k_1$ is correctly derived from $C_1$, $k_2$ is derived from $C_2$ and $k$ combines $k_1 + k_2$, $\MCO$'s input to $k$ prevents forgery attempts on the key $k$. The hiding property of the commitments and zero-knowledge property of the proofs ensures correct protocol adherence while maintaining private computation. Revocation is enabled by threshold encryption of the VRF key $k$ with the public key of the Auditor $PK_A$. $\Pi_3$ proves that $\tau$ is an encryption of the committed key $k$. $\tau$ is stored with the credential oracle maintaining privacy during normal operation. Finally, the protocol prevents replay attacks by using interactive zero-knowledge proofs requiring a challenge from the verifier, fresh commitment randomness, and $\MCO$'s input of their share of the VRF key $k_2$ preventing existing transcript reuse.



\newpage
\subsection{Create Context Credential}

Context Credential Issuance enables a user to obtain a context-specific credential while proving ownership of a valid master credential. The user first constructs a commitment to their context credential attributes, including their identity $s$ and a deterministic nullifier derived from their VRF key $k$ and the credential context $ctx$. Through zero-knowledge proofs, the user demonstrates their master credential is valid and unrevoked, and proves the context commitment is well-formed with the same identity $s$. The nullifier $\tau$ = $VRF(k,ctx)$ prevents multiple credentials for the same context while maintaining privacy. Upon successful verification, the Context Credential Oracle signs the commitment and records the nullifier.

\begin{center}
\begin{tabular}{l@{\hspace{12em}}c@{\hspace{12em}}l}
\multicolumn{3}{l}{$\underline{Setup(1^{\lambda}, 1^n)}$:} \\[0.5em]
\multicolumn{3}{l}{System: $(\G_1, \G_2, e, g, \tilg ) \gets BG.Gen(\secparam, p), \; ck_c \gets CM.Setup(BG, \secparam, n)$} \\[1em]
\multicolumn{3}{l}{Credential Oracle: $(SK_c, PK_c) \gets PS.KeyGen(ck_c)$} \\[1em]
\underline{User($Cred_m, s, k$)} && \underline{CCO($SK_c$)} \\[0.5em]
\multicolumn{3}{l}{$\delta \gets VRF(k, ctx)$} \\[1em]
\multicolumn{3}{l}{$r* \sample Z_p, \; C_c \gets Com([s,\delta,ctx,attrs],r*)$} \\[1em]
\multicolumn{3}{l}{$\Pi_4 \gets ZKPoK.Prove_{selective-disclosure}(C_c,\delta,ctx,attrs)(s, r*)$} \\[1em]
\multicolumn{3}{l}{$r' \sample \Z_p, Cred_{m}' \gets Cred.Rerand(Cred_{m}, r')$} \\[1em]
\multicolumn{3}{l}{$\Pi_5 \gets ZKSoK.Prove(Cred_m')(s,k,master,attrs,r')$} \\[1em]
\multicolumn{3}{l}{Parse $Cred_m'$ as $C_m', \sigma_m'$} \\[1em]
\multicolumn{3}{l}{$\Pi_6 \gets ZKPoK.Prove_{reciprocal}(C_m', C_c,ctx)(s,k,r',r*)$}  \\[1em]
\multicolumn{3}{l}{$\Pi_7 \gets ZKPoK.Prove_{equality}(C_m', C_c)(s, r)$} \\[1em]
\multicolumn{3}{l}{$\Pi_8 \gets ZKPoK.Prove_{revocation}(Cred_m', \RL)(k)$} \\[1em]
& $\xrightarrow{Cred_m', C_c, \Pi_4, \Pi_5, \Pi_6, \Pi_7, \Pi_8}$ & \\[1em]
\multicolumn{3}{r}{If} \\[1em]
\multicolumn{3}{r}{$ZKPok.Verify_{selective-disclosure}(\Pi_4, C_c)(\delta, ctx, attrs)$ = 1 $\; \wedge$} \\[1em]
\multicolumn{3}{r}{$ZKSoK.Verify(\Pi_5, Cred_m')$ = 1 $\; \wedge$} \\[1em]
\multicolumn{3}{r}{$ZKPoK.Verify_{reciprocal}(\Pi_6, C_m', C_c, ctx)$ = 1 $\; \wedge$} \\[1em]
\multicolumn{3}{r}{$ZKPoK.Verify_{equality}(\Pi_7, C_m', C_c)$ = 1 $\; \wedge$} \\[1em]
\multicolumn{3}{r}{$ZKPoK.Verify_{revocation}(\Pi_8, Cred_m')$ = 0} \\[1em]
\multicolumn{3}{r}{$\sigma_c \gets PS.Sign(SK_c, C_c)$} \\[1em]
\multicolumn{3}{r}{Store Data Record CCO $(C_c, \sigma_c, \delta, \Pi_4, \Pi_5, \Pi_6, \Pi_7, \Pi_8  )$} \\[1em]
& $\xleftarrow{\sigma_c}$& \\[1em]
\multicolumn{3}{l}{If $PS.Verify(PK_c,\sigma_c, C_c) = 1$, Store $Cred_c(\sigma_c, C_c)$} \\[1em]
\end{tabular}
\end{center}



\subsubsection{Informal Security Analysis}
Sybil Resistance: The deterministic nullifier $\delta \gets VRF(k,ctx)$ binds each context credential to a unique (user, context) pair, preventing multiple credentials for the same context. The reciprocal proof $\Pi_6$ ensures correct nullifier derivation from the master key $k$. 
Credential Binding: Context Credentials are bound to master credentials through shared identity $s$ and $\Pi_7$. The selective disclosure proof $\Pi_4$ ensures correct commitment structure without revealing private values. 
Privacy: The protocol only reveals $ctx$ and $attrs$ to CCO to allow identity verification while hiding $s$. The Master Credential $Cred_m$ remains unlinkable by being  rerandomized and proven in zero knowledge it verifies with the Master Credential Oracles public key.
Revocation: The proof $\Pi_8$ demonstrates $Cred_m$ is not revoked, ensuring only valid master credentials can be used.














\newpage

\subsubsection{Revocation}
When $ra$ needs to revoke a user's credential/s (due to user request or credential provider request), $ra$ finds $escrow$ based on the user's $pid$, recall $ra$ has a user list $ul$ = $(pid, escrow)$ and requests the auditor $audit$ to decrypt $s \gets tpkdec_{ask}(escrow)$. $audit$ computes the nullifiers to add to the revocation accumulator. $nullif_{rcd} \gets PRF_s(pid)$ and for each context credential to revoke, $nullif_{ctxid} \gets PRF_s(ctxid)$. $audit$ updates the accumulator $acc' \gets Acc.Add(acc)$
If the registration credential requires revocation, $audit$ can compute each $nullif \gets PRF_{s}(ctxid) ; \forall ; ctxid ; \in ; ctxl$ and add $(nullif, timestamp, reason)$ to $rl$. For record-keeping, $ra$ stores Revocation Information $ri = (nullif, timestamp, reason)$ allowing $ra$ to track which credentials are revoked and why, $nullif$ in $rl$ ensures revoked credentials can't be verified.
During credential verification, verifiers check if a credential's nullifier appears in $rl$, if present, the verification fails.
\subsubsection{Verification}
A user $user$ wants to prove to any relying party $rely$ they have a valid credential that satisfies a verification statement $\phi$.
The protocol takes as input $(rcd, ccd, \phi, rpk, acc, n)$ and outputs success or failure.
$rely$ starts by sending $(\phi, n, acc)$ to $user$ where $\phi$ is a statement that specifies the requirements for a successful verification and $acc$ is the current accumulator value of revoked nullifiers.
$user$ starts by randomizing their credentials $rcd' = psrerand(rcd)$ and $ccd' = psrerand(ccd)$ and verifies $psverify_{ck_{rcd}}(rcd')$ and $psverify_{ck_{ccd}}(ccd')$. $user$ generate their nullifiers $nullif_{pid} \gets PRF_s(pid)$ and $nullif_{ctx} \gets PRF_s(ctxid)$ and obtains non-membership witnesses $wpid$, $wctx$ for nullifiers against $acc$.
$user$ generates a zero-knowledge proof $\pi$ showing 1) their credentials are valid, 2) they're not expired $(expiry > current_time)$, 3) their nullifiers are correctly formed from $s$, 4) their nullifiers are not in $acc$ using witnesses $wpid, wctx$, 5) the credential attributes satisfy $\phi$, 6) proof freshness using $n$.
$user$ sends $(\pi, attrs_{\phi})$ to $rely$, $rely$ verifies $\pi$ against $acc$ and validates $attrs_{\phi}$ satisfies $\phi$. Returns accept if all checks pass, reject otherwise.




\section{Construction of NIZK Proofs}\label{sec:sigmaproofs}
% Recall definitions and introduction here: https://infoscience.epfl.ch/server/api/core/bitstreams/fc1cfb22-d943-4c96-a942-d715b76e6cc4/content#page=6.31





Preliminaries: Let $\G$ be a cyclic group of prime order $q$ with generators $g, g_1, \dots, g_n$


\newpage

\begin{construction}{Opening Proof($C$)}{openproof}
    \vspace{1em}
    \textbf{Public parameters:} $g, h \in \G$

    \textbf{Inputs:} $C$ such that $C = g^mh^r$, $\Prover$ knows $m, r \in \Z_q$.

    \textbf{Relation:} $\mathcal{R} = \left\{ (C,g,h,q),(m,r) \; | \; C = g^{m}h^r \right\}$
    \vspace{1em}

    \begin{enumerate}
        \item $\Prover$ samples $\alpha_1, \rho_1 \sample [q-1]$ and sends $T \gets g^{\alpha}h^{\rho}$
        
        \item $\Verifier$ sends challenge $c \sample [q-1].$
    
        \item $\Prover$ sends $s \gets \alpha + cm, u \gets \rho + cr$
    
        \item $\Verifier$ verifies that $g^{s}h^{u} = C^cT$
    \end{enumerate}
\end{construction}

\begin{theorem}[Perfect Completeness]
    Construction \ref{construct:openproof} is a $\Sigma-$protocol for the relation $\mathcal{R}$ with perfect completeness: 
\end{theorem}
\begin{proof}
    We prove completeness by showing that for any $(C, g, h, q),(m,r) \in \mathcal{R}$, when both $\Prover$ and $\Verifier$ follow the protocol, $\Verifier$ accepts with $\Pr$ = 1.

    Let $x = (C,g,h,q)$ be common input and $w = (m, r)$ be $\Prover$'s private input. Consider an execution of the protocol where:
    \begin{enumerate}
        \item $\Prover$ samples $\alpha, \rho \sample [q-1]$ and sends $T \gets g^{\alpha}h^{\rho}$
        \item $\Verifier$ sends challenge $c \sample [q-1]$
        \item $\Prover$ responds with $s \gets \alpha+m, u \gets \rho+r$
    \end{enumerate}
    Verification holds by 
    \begin{align}
        g^sh^u &\stackrel{?}{=} C^cT \notag \\
        g^{\alpha + cm}h^{\rho + cr} &\stackrel{?}{=} (g^mh^r)^cg^{\alpha}h^{\rho} \notag  \\
        g^{\alpha + cm}h^{\rho + cr} &= g^{mc + \alpha} h^{rc + \rho} \notag 
    \end{align}
    Thus, an honest verifier always accepts an honest prover's proof.
\end{proof}


\begin{theorem}[Special Soundness]
    Construction \ref{construct:openproof} satisfies the special soundness of relation $\mathcal{R}$. 
\end{theorem}
\begin{proof}
    Let $Tr_1 = (T, c, s, u)$ and $Tr_2 = (T,c',s',u')$ be two accepting transcripts for the same initial commitment $T$ where $c \neq c'$. We construct a knowledge extractor $\Extractor$ that extracts the witness $w = (m,r)$ as follows:
    \begin{enumerate}
        \item  Since both transcripts are accepting, they satisfy: $g^sh^u = C^cT$ and $g^{s'}h^{u'} = C^{c'}T$.
        \item Evaluate as a system of linear equations:
             \begin{align}
               \frac{g^sh^u}{g^{s'}h^{u'}} &= \frac{C^c}{C^{c'}} \notag \\
               g^{s-s'}h^{u-u'} &= g^{m(c-c')}h^{r(c-c')} \notag \\
            \end{align}
       \item By the homomorphic property of the exponents, we obtain two accepting transcripts 
       \[
       s-s' = m(c-c') \qquad u-u' = r(c-c')
       \] 
       therefore $\Extractor$ extracts, $m = \frac{s-s'}{c-c'} \qquad r = \frac{u-u'}{c-c'}$ Which satisfies the commitment construction $C = g^mh^r$
    \end{enumerate}

    This shows that if $\Prover$ can respond correctly to 2 different challenges for the commitment $T$, they must "know" the witness $(m,r)$.
\end{proof}

\begin{proof}
    Suppose we have two accepting transcripts for the same commitment $(Comm, Chall, Resp)$
    $(C, T, c, s, u)$ and $(C,T,c',s',u')$ where $c \neq c'$
\end{proof}


\begin{theorem}[Perfect Zero-Knowledge]
    Construction 1 is perfect zero-knowledge.
\end{theorem}

\begin{proof}
    We show that for any verifier $\Verifier$*, there exists a simulator $\Simulator$ that can generate transcripts that are perfectly indistinguishable from real protocol execution. Let $\texttt{view}_v(x,w)$ denote $\Verifier$'s view in a real protocol execution with common input $x = (C,g,h,q)$ and witness $w = (m,r)$. 

    \noindent \textbf{Simulator Construction: } Given only public input $(C,g,h,q)$, simulator $\Simulator$ operates as follows:
    \begin{enumerate}
        \item Sample $s', u', c' \sample [q-1]$ uniformly at random
        \item  Compute $T' = g^{s'}h^{u'} \cdot C^{-c'}$
        \item Output transcript $(T', c', (s,u))$
    \end{enumerate}

    \noindent \textbf{Correctness of Simulation: } The simulated transcript satisfies the verification equation $g^{s'}h^{u'} = C^{c'}T'$, by substituting $T' = g^{s'}h^{u'} \cdot C^{-c'}$ and satisfying $g^{s'}h^{u'} = C^{c'} \cdot g^{s'}h^{u'} \cdot C^{-c'}$

    \noindent \textbf{Perfect Indistinguishability: } For any fixed witness $(m,r)$ where $C = g^mh^r$, we prove 
    \[
    \Pr \left[ \Simulator(C, g, h, q) = (T',c',(s',u')) \right] = \Pr \left[ \texttt{view}_v(x,w) = (T,c,(s,u)) \right]
    \]
    




\newpage
    
    Recall a real transcript:
    \begin{enumerate}
        \item $T = g^{\alpha}h^{\rho}$ where $\alpha, \rho \sample [q-1]$ are random
        \item $c \sample [q-1]$ is a random challenge
        \item $s = \alpha + cm, u = \rho + mr$. Solving for $\alpha, \rho$, we obtain $\alpha = s - cm, \rho = u - mr$. We use this in the section below.
    \end{enumerate}


    We construct a simulator $\Simulator$ that, given public input $(C, g, h, q)$ generates transcripts indistinguishable from real.  $\Simulator$ operates as follows:
    \begin{enumerate}
        \item Samples $s', u', c' \sample [q-1]$ from random
        \item Computes $T' = g^{s'}h^{u'} \cdot C^{-{c'}} $
        \begin{align}
            T' \; &= \; g^{s'}h^{u'} \cdot C^{-{c'}} \notag \\
            &= g^{s'}h^{u'} \cdot (g^mh^r)^{-{c'}} \notag \\
            &= g^{s'}h^{u'} \cdot g^{-cm'}h^{-cr'} \notag \\
            &= g^{s'-mc'}h^{u'-rc'} \notag \\
        \end{align} 
        \item Output transcript $(T', c', (s', u'))$ where without $\alpha, \rho$ from the real run, $\Simulator$ recreates the probability distribution for $\alpha = s - mc, \rho = u - rc$
    \end{enumerate}

    For any fixed witness $(m,r)$, where $C = g^mh^r$,  for any transcript $T, c, (s,u)$, we show that the probability of $S$ outputting the transcript is the same probability of it occurring in protocol execution. 
\[
\Pr \left[ \Simulator(C, g, h, q) = (T',c',(s',u')) \right] = \Pr \left[ \langle \Prover(m,r),\Verifier \rangle = (T,c,(s,u)) \right]
\]

To prove in
\begin{itemize}
    \item $\Prover$ samples $\alpha, \rho, c \sample [q-1]$
    \item $T = g^{\alpha}h^{\rho}$
    \item $s = \alpha + cm, u = \rho + cr$
\end{itemize}

For any fixed transcript $(T, c, (s,u))$ we show:
\begin{enumerate}
    \item In both real and simulated executions, $c$ is uniformly distributed in $[q-1]$
    \item Given any fixed $c$
\end{enumerate}


\end{proof}































\newpage
\begin{construction}{Multi-Message Opening Proof($C$)}{mmopenproof}
    \vspace{1em}
    \textbf{Public parameters:} $g_1, \dots, g_n, h \in \G$

    \textbf{Inputs:} $C$ such that $C = g_1^{m_1}\dots g_n^{m_n}h^r$, $\Prover$ knows $m_1, \dots, m_n, r \in \Z_q$.
    \vspace{1em}
        \begin{enumerate}
            \item $\Prover$ samples $\alpha_1, \dots, \alpha_n, \rho \sample [q-1]$ and sends $T \gets g_1^{\alpha_1} \dots g_n^{\alpha_n}h^{\rho}$
            
            \item $\Verifier$ sends challenge $c \sample [q-1].$
        
            \item $\Prover$ sends $s_1 \gets \alpha_1 + cm_1, \dots, s_n \gets \alpha_n + cm_n, u \gets \rho + cr$
        
            \item $\Verifier$ verifies that $g_1^{s_1} \dots g_n^{s_n} h^{u} = C^cT$
        \end{enumerate}
\end{construction}


\begin{theorem}
    Construction \ref{construct:mmopenproof} is a $\Sigma-$construction for the relation: 
    \[
    \mathcal{R} = \left\{ (C,g_1,\dots, g_n, h, q),(m_1, \dots ,m_n,r) \; | \; C = g^{m_1}\dots g^{m_n}h^r \right\}
    \]    
\end{theorem}
\begin{proof}
  By extension, it follows from Protocol \ref{prot:openproof}
\end{proof}




\begin{construction}{Equality Proof($C_1, C_2$)}{equalityproof}
    \vspace{1em}
    \textbf{Public Parameters:} $g_1, g_2, h_1, h_2 \in \G$

    \textbf{Inputs:} $C_1, C_2$ such that $C_1 = g_1^{m_1}h_1^{r_1}, C_2 = g_2^{m_1}h_2^{r_2}$, $\Prover$ knows $m_1, r_1, r_2 \in \Z_q$.
    \vspace{1em}
        \begin{enumerate}
            \item $\Prover$ samples $\alpha_1, \rho_1, \rho_2 \sample [q-1]$ and sends $T_1 \gets g_1^{\alpha_1}h_1^{\rho_1}$ and $T_2 \gets g_2^{\alpha_1}h_2^{\rho_2}$
            \item $\Verifier$ sends challenge $c \sample [q-1]$
            \item $\Prover$ sends $s \gets \alpha_1 + cm_1, u_1 \gets \rho_1 + cr_1, u_2 \gets \rho_2 + cr_2$
            \item $\Verifier$ verifies that $g_1^sh_1^{u_1} = C_1^cT_1 \; \wedge \; g_2^sh_2^{u_2} = C_2^cT_2$
        \end{enumerate}
\end{construction}
    

\begin{theorem}
    Construction~\ref{construct:equalityproof} is a $\Sigma-$Construction for the relation: 
    \[
    \mathcal{R} = \left\{ (C_1, C_2,g_1,g_2,h_1,h_2, q),(m_1,r_1,r_2) \; | \; C_1 = g_1^{m_1}h_1^{r_1} \; \wedge \; C_2 = g_2^{m_1}h_2^{r_2} \right\}
    \]    
\end{theorem}

\begin{proof}
    Folklore
\end{proof}









\begin{construction}{Proof of Zero($C$)}{zeroproof}
    \vspace{1em}
    \textbf{Public Parameters:} $g_1, g_2, h_1\in \G$

    \textbf{Inputs:} $C$ such that $C = g_1^{m_1}g_2^0h^{r}$, $\Prover$ knows $m_1, r_1 \in \Z_q$.
    \vspace{1em}
        \begin{enumerate}
        \item $\Prover$ samples $\alpha_1, \rho_1 \sample [q-1]$ and sends $T_1 \gets g_1^{\alpha_1}g_2h_1^{\rho_1}$ 

        \item $\Verifier$ sends challenge $c \sample [q-1]$

        \item $\Prover$ sends $s \gets \alpha_1 + cm_1, u_1 \gets \rho_1 + cr_1$

        \item $\Verifier$ verifies that $g_1^sg_2^ch_1^{\rho_1} = C_1^cT_1$
    \end{enumerate}
\end{construction}
    

\begin{theorem}
    Construction~\ref{construct:zeroproof} is a $\Sigma-$Construction for the relation: 
    \[
    \mathcal{R} = \left\{ (C_1, C_2,g_1,g_2,h_1,h_2, q),(m_1,r_1,r_2) \; | \; C_1 = g_1^{m_1}h_1^{r_1} \; \wedge \; C_2 = g_2^{m_1}h_2^{r_2} \right\}
    \]    
\end{theorem}

\begin{proof}
    Folklore
\end{proof}






\begin{construction}{Proof of reciprocal exponents equals 1($C_1, C_2$)}{recipexpproof}
    \vspace{1em}
    \textbf{Public Parameters:} $g, h \in \G$

    \textbf{Inputs:} $C_1, C_2$ such that $C_1 = g^{m_1}h^{r_1}$, $C_2 = g^{m_2}h^{r_2}$. $\Prover$ knows $m_1, m_2, r_1, r_2 \in \Z_q$.
    \vspace{1em}
        \begin{enumerate}
        \item $\Prover$ samples $\alpha_1, \alpha_2, \rho_1, \dots, \rho_4 \sample [q-1]$ and computes blinding commitments for $C_1, C_2$

        $T_1 \gets g^{\alpha_1}h^{\rho_1}$ \qquad $T_2 \gets g^{\alpha_2}h^{\rho_2}$
        
        \vspace{1em}

        and interim commitments $C_3, C_4$ and their blinding commitments $T_3, T_4$

        $C_3 \gets C_1^{m_2}h^{r_3}$ \qquad $C_4 \gets h^{r_4}$ \qquad $T_3 \gets C_1^{\alpha_2}h^{\rho_3}$ \qquad $T_4 \gets h^{\rho_4}$

        \vspace{1em}

        \item $\Verifier$ sends challenge $c \sample [q-1]$

        \item $\Prover$ responds with 

        $s_1 \gets \alpha_1 + cm_1$  \qquad $s_2 \gets \alpha_2 + cm_2$

        $u_1 \gets \rho_1 + cr_1$ \qquad $u_2 \gets \rho_2 + cr_2$ \qquad  $u_3 \gets \alpha_3 + cr_3$ \qquad  $u_4 \gets \alpha_4 + cr_4$

        \item $\Verifier$ verifies that 
        
        $g^{s_1}h^{u_1} = C_1^c T_1$ \qquad $g^{s_2}h^{u_2} = C_2^c T_2$ \qquad $C_1^{s_2}h^{u_3} = C_3^c T_3$
        
        $h^{u_4} = C_4^c T_4$ \qquad  $C_3/C_4 = g$
    \end{enumerate}
\end{construction}
    

\begin{theorem}
    Protocol~\ref{construct:recipexpproof} is a $\Sigma-$protocol for the relation: 
     \[
    \mathcal{R} = \left\{ (C_1, C_2, g, h, q),(m_1, m_2, r_1, r_2) \; | \; C_1 = g^{m_1}h^{r_1} \wedge C_2 = g^{m_2}h^{r_2} \wedge m_1 \cdot m_2 = 1 \right\}
    \]  
\end{theorem}

\begin{proof}
    Completeness. 
\end{proof}













\subsubsection{Completeness}
Proof of knowledge of exponents $m1, r1$ by opening $C_1$ 
\begin{align}
    C_1^e \cdot T_1 &\stackrel{?}{=} g^{z_{m1}} h^{z_{r1}} \notag \\
    (g^{m1}h^{r_1})^e \cdot g^{\beta_1}h^{\rho_1} &= g^{\beta_1 + e \cdot m_1} h^{\rho_1 + e \cdot r_1} \notag \\
    g^{e \cdot m1 + \beta_1}h^{e \cdot r_1 + \rho_1} &= g^{\beta_1 + e \cdot m_1} h^{\rho_1 + e \cdot r_1} \notag 
\end{align}

Proof of knowledge of exponents $m2, r2$ by opening $C_2$ 
\begin{align}
    C_2^e \cdot T_2 &\stackrel{?}{=} g^{z_{m2}} h^{z_{r2}} && \label{eq:ver1} \\
    (g^{m2}h^{r_2})^e \cdot g^{\beta_2}h^{\rho_2} &= g^{\beta_2 + e \cdot m_2} h^{\rho_2 + e \cdot r_2} \notag \\
    g^{e \cdot m2 + \beta_2}h^{e \cdot r_2 + \rho_2} &= g^{\beta_2 + e \cdot m_2} h^{\rho_2 + e \cdot r_2} \notag 
\end{align}


Equality of $m2 \in \{C_2, C_3\}$ proven by equality of responses $g^{z_{m2}}$ used in \eqref{eq:ver1} and \eqref{eq:ver2}
\begin{align}
    C_3^e \cdot T_3 &\stackrel{?}{=} C_1^{z_{m2}} h^{z_{r3}} \notag \\
    (C_1^{m2}h^{r_3})^e \cdot C_1^{\beta_2}h^{\rho_3} &= C_1^{\beta_2 + e \cdot m_2} h^{\rho_3 + e \cdot r_3} \label{eq:ver2} \\
    C_1^{m2 \cdot e + \beta_2}h^{e \cdot r_3 + \rho_3} &= C_1^{\beta_2 + e \cdot m_2} h^{\rho_3 + e \cdot r_3} \notag
\end{align}

Proof of knowledge of exponent $r4$ by opening $C_4$ 
\begin{align}
    C_4^e \cdot T_4 &\stackrel{?}{=} h^{z_{r4}} \notag \\
    (h^{r_4})^e \cdot h^{\rho_4} &\stackrel{?}{=} h^{\rho_4 + e \cdot r_4} \notag \\
    h^{e \cdot r_4 + \rho_4} &= h^{\rho_4 + e \cdot r_4} \notag
\end{align}

Prove that $C_3/C_4 = g$ implies $g^{\frac{m1}{m2}} = 1$ which proves their inverse relation. Recall $C_1 = g^{m_1}h^{r_1}, r_4 = r_1m_2 + r_3$
\begin{align}
    \dfrac{C_3}{C_4} = \dfrac{C_1^{m2}h^{r_3}}{h^{r_4}} = \dfrac{(g^{m_1}h^{r_1})^{m2}h^{r_3}}{h^{r_1 \cdot m_2 + r_3}} = \dfrac{g^{m_1\cdot m2}h^{r_1\cdot m2 + r_3}}{h^{r_1 \cdot m_2 + r_3}} = \dfrac{g}{1} = g \notag \\
\end{align}

\subsubsection{Soundness}
\todonote{Sam todo}

\subsubsection{Zero Knowledge}
\todonote{Sam todo}

\subsubsection{Analysis G1 Method}
\begin{itemize}
    \item \textbf{Prover:} 11 $\G_1$ exponentiations, 4 $\G_1$ additions, 6 $\F_p$ multiplications, 6 $\F_p$ additions
    \item \textbf{Verifier:} 11 $\G_1$ exponentiations, 7 $\G_1$ additions/subtractions, 
\end{itemize}

\subsection{NIZK for Credential Chaining}
\subsection{NIZK for equality of commitments in different groups}
\todonote{sam to do}




\subsection{Proof of NIZK}


\cleardoublepage


\section{Construction of Private Identity System}\label{sec:identitysystem}




\newcommand{\vt}{\mathsf{vt}}
\newcommand{\wx}{\mathsf{wx}}
\newcommand{\wxone}{\mathsf{w_1x}}
\newcommand{\wxtwo}{\mathsf{w_2x}}
\newcommand{\wxhat}{\mathsf{\hat{w}x}}
% \newcommand{\x}{\mathsf{x}}

\newcommand{\acu}{\mathsf{ACU}}
\newcommand{\acusetup}{\mathsf{ACU.Setup}}
\newcommand{\acuadd}{\mathsf{ACU.Add}}
\newcommand{\acudel}{\mathsf{ACU.Del}}
\newcommand{\acuvermem}{\mathsf{ACU.VerMem}}
\newcommand{\acuvernonmem}{\mathsf{ACU.VerNonMem}}


\newcommand{\rev}{\mathsf{REV}}
\newcommand{\revsetup}{\mathsf{REV.Setup}}
\newcommand{\revrevoke}{\mathsf{REV.Revoke}}
\newcommand{\revtokengen}{\mathsf{REV.TokenGen}}
\newcommand{\revtokenver}{\mathsf{REV.TokenVer}}

\newcommand{\rt}{\mathsf{rt}}

% \newcommand{\tilcm}{\tilde{\mathsf{cm}}}
\newcommand{\tilcm}{\tilde{cm}}


\newcommand{\mb}{\textbf{m}}
\newcommand{\gb}{\textbf{g}}
\newcommand{\tilgb}{\tilde{\textbf{g}}}
\newcommand{\yb}{\textbf{y}}
\newcommand{\rd}{\Delta_r}
\newcommand{\td}{\Delta_t}
\newcommand{\ud}{\Delta_u}


\subsection{Commitment}
\subsubsection{Syntax}
\begin{itemize}
    \item $CM.Setup(BG, \secparam, 1^n) \to ck$: Sample $g \sample \G_1, \tilg \sample \G_2$. Sample $\yb \sample \Z_p^{n}$ and compute $(\gb, \tilgb) \gets (g^{\yb}, \tilg^{\yb})$. Output $ck \gets (g, \gb, \tilg, \tilgb)$
    
    \item $CM.Com_{ck}(\mb, r) \to (\cm, \tilcm):$ Parse $ck$ as $(g, \gb, \tilg, \tilgb)$ and $\mb$ as $(m_1, \dots, m_{\ell})$, return $(\cm, \tilcm)$ as $(\gb^{\mb}g^r, \tilgb^{\mb}\tilg^r)$

    \item $CM.Rerand_{ck}((\cm, \tilcm), \rd) \to (\cm', \tilcm'):$ Parse $ck$ as $(g, \gb, \tilg, \tilgb)$. Compute $(g^{\rd}, \tilg^{\rd})$ and return $(\cm', \tilcm')$ as $(\cm \cdot g^{\rd}, \tilcm' \cdot \tilg^{\rd})$
\end{itemize}

\subsubsection{Construction}

\begin{itemize}
    \item $CM.Setup(\secparam, n) \to ck:$ The setup Algorithm generates the commitment key $ck$. Samples $(g, \tilg) \sample \G_1^* \times \G_2^*$ and $n$ scalars $y_i \gets \Z_p$, $Y_i \gets g^{y_i}$, and $\tily_i \gets \tilg^{y_i}$ $\forall \; 1 \leq i \leq n;$ such that $Y_i = g_1^{y_1}\dots g_n^{y_n}$ and $\tily_i = \tilg_1^{y_1}\dots \tilg_n^{y_n}$. Outputs $ck$ a tuple $(g, Y_i, \tilg, \tily_i)$ with commitment keys in both $\G_1$ and $\G_2$ where $e(Y_i,\tilg) = e(g,\tily_i)$

    \item $CM.Com_{ck}(\{m_i\}^n_{i=1}) \to (cm, \tilcm):$ to commit to $n$ messages $m_1, \dots, m_n$, the committer samples $r \sample \Zp$, and parses $ck$ as $(g, Y_i, \tilg, \tily_i)$ and commits to $\{m_i\}^n_{i=1}$ over dual commitments in $\G_1$ and $\G_2$. Computes $g^r, \tilg^r$, Commits to $\{m_i\}^n_{i=1}$ with respect to $ck$ such that $\cm \gets g_1^{m_1}\dots g_n^{m_n} g^r$ and $\tilcm \gets \tilg_1^{m_1} \dots \tilg_n^{m_n}\tilg^r$ Then outputs $(\cm, \tilcm)$ where the equality of commitments can be verified by pairing $e(\cm, \tilg) = e(g, \tilcm)$
    
    \item $CM.Rerand_{ck}((\cm, \tilcm), \rd) \to (\cm', \tilcm'):$ To rerandomize the commitment, the last element $g, \tilg$ is randomized with $\rd$. Compute $g^{\rd}, \tilg^{\rd}$, Compute $\cm'$ = $\cm \cdot g^{\rd}$ as $g_1^{m_1}\dots g_n^{m_n} g^r \cdot g^{\rd}$ which will equal $g_1^{m_1}\dots g_n^{m_n} g^{r + \rd}$ and equivalently for $\tilcm'$. Return the rerandomized commitments $(\cm', \tilcm')$
    
\end{itemize}

\subsubsection{Security}


\subsection{PS Signature}
\subsubsection{Syntax}
\begin{itemize}
    \item $PS.KeyGen(\secparam, \ck) \to (\sk, \vk):$ Parse $\ck$ as $ck \gets (g, \gb, \tilg, \tilgb)$. Sample $x \sample \Zp$, set $(\sk, \vk) \gets (g^x, \tilg^x)$

    \item $PS.Sign_{ck}(\sk, \cm) \to \sigma:$ Parse $\ck$ as $\gets (g, \cdot, \tilg, \cdot)$ Sample $u \sample \Zp$, compute $\sigma_1 \gets g^u$, $\sigma_2 \gets (\sk \cdot \cm)^u$
     and return $\sigma \gets (\sigma_1, \sigma_2)$

     \item $PS.Rerand(\sigma, \rd, \ud) \to \sigma': $ Parse $\sigma$ as $(\sigma_1, \sigma_2)$. Compute $\sigma_1' \gets \sigma_1^{\ud}$ and $\sigma_2' \gets (\sigma_2 \cdot \sigma_1^{\rd})^{\ud}$. Return $\sigma' \gets (\sigma_1', \sigma_2')$

     \item $PS.Verify_{ck, vk}(\sigma, (\cm, \tilcm)) \to \bit: $ Verify $ZKPoK.Open_{ck}(\cm)$. Parse $\ck$ as $(g, \cdot, \tilg, \cdot)$ and $\sigma$ as $(\sigma_1, \sigma_2)$. Assert $e(\cm, \tilg) = e(g, \tilcm)$ and $e(\sigma_2, \tilg) = e(\sigma_1, \vk \cdot \tilcm)$
     
\end{itemize}
\subsubsection{Construction}
\begin{itemize}
    \item $PS.KeyGen_{\ck}(\secparam) \to (\sk, \vk):$ The PS Signature KeyGen algorithm is parameterized by the corresponding commitment key $\ck$. The Signer retreives $(g, \cdot, \tilg, \cdot)$ from $\ck$, samples secret $x \sample \Zp$, sets $X \gets g^x$ and $\tilx \gets \tilg^x$, sets $\sk$ as $(g, X)$ and the public verification key $\vk$ as $(\ck, \tilx)$ and returns $(\sk, \vk)$

    \item $PS.Sign_{\sk}(\cm) \to \sigma: $ The signing algorithm signs the commitment. Retreives $(g, \cdot, \tilg, \cdot)$ from $\ck$, Samples $u \sample \Zp$, Computes $\sigma_1$ as $g^u$ and $\sigma_2 \gets (X \cdot \cm)^u$ both are notably in $\G_1$ and thus $(X \cdot \cm)^u$ = $(g_1^{m_1u}\dots g_n^{m_nu}g^{xu+ru})$. Returns $\sigma \gets (\sigma_1, \sigma_2)$    

    \item $PS.Rerand(\sigma, \rd, \ud) \to \sigma':$ Parse $\sigma$ as $(\sigma_1, \sigma_2)$. Compute $\sigma_1' \gets \sigma_1^{\ud}$ and $\sigma_2' \gets (\sigma_2 \cdot \sigma_1^{\rd})^{\ud}$. Return $\sigma' \gets (\sigma_1', \sigma_2')$

    \item $PS.Verify(\sigma, (\cm, \tilcm)) \to \bit:$ Verify $ZKPoK.Open_{ck}(\cm)$. Parse $\ck$ as $(g, \cdot, \tilg, \cdot)$ and $\sigma$ as $(\sigma_1, \sigma_2)$. Assert $e(\cm, \tilg) = e(g, \tilcm)$ and $e(\sigma_2, \tilg) = e(\sigma_1, \vk \cdot \tilcm)$

\end{itemize}

\subsubsection{Security}


\subsection{PS Signature over Commitment Construction}
\begin{itemize}
    \item $PS.Rerand_{ck,vk}(\sigma, \rd, \ud) \to \sigma'$: Rerandomization of the signature must preserve the algebraic properties of the commitment itself to allow the commitment to be used for zero knowledge proof protocols. To do so, the commitment is re-randomized with the random factor $\rd$ such that a commitment and signature pair 

\end{itemize}

\subsection{Zero Knowledge Proof}
\begin{itemize}
    \item $ZKP.ComOpen_{ck}(cm, m_i, r) \to \Pi^{cm}$
    \item $ZKP.ComOpenVfy_{ck}(cm, \Pi^{cm}) \to \bit$
\end{itemize}

\subsection{Anonymous Credential}


\begin{center}
\begin{tabular}{l@{\hspace{8em}}c@{\hspace{8em}}l}
\multicolumn{3}{l}{$\underline{OrgKeyGen(1^{\lambda}, 1^n)}$:  Given $\lambda, n > 0$, compute $BG = (p, \G_1, \G_2, \G_T, e, g, \tilg) $}.\\[0.5em]
\multicolumn{3}{l}{Run $ck \gets CM.Setup(BG, 1^{\lambda}, 1^n)$ which defines $(g, g^{\yb}, \tilg, \tilg^{\yb})$ with $ \yb_{\in[n]}$} \\[0.5em]
\multicolumn{3}{l}{Run $(sk, vk) \gets PS.KeyGen(ck, 1^{\lambda}, 1^n)$ which defines $sk = X \in \G_1$ and $vk = \tilx \in \G_2$}\\[0.5em]
\multicolumn{3}{l}{$osk = (g, X), opk = (ck, \tilx, BG)$, return $(osk, opk)$}\\[2em]
\underline{Obtain(opk, $\mathbf{m}$)} && \underline{Issue(osk, $cm$)} \\[1em]
\multicolumn{3}{l}{Parse $opk = (ck, \tilx, BG)$, sample $r \sample \Z_p$} \\[0.5em]
\multicolumn{3}{l}{Compute $(cm, \widehat{cm}) \gets CM.Com(ck, \mathbf{m}, r)$} \\[0.5em]
\multicolumn{3}{l}{Run $\Pi^{cm} \gets ZKP.ComOpen(ck, cm, \mathbf{m}, r)$} \\[0.5em]
& $\xrightarrow{\Pi^{cm}}$ & \\[1em]
\multicolumn{3}{r}{If $ZKP.ComOpenVfy(\Pi^{cm},cm) = 0$, return $\bot$} \\[1em]
& $\xleftarrow{\sigma = (\sigma_1, \sigma_2)}$ & $\sigma \gets \mathsf{PS.Sign}(osk, cm)$ \\[1em]
\multicolumn{3}{l}{If $\mathsf{PS.Verify}(opk, cm, \sigma) = 0$, return $\bot$} \\[1em]
\multicolumn{3}{l}{$Cred \gets (\sigma = (\sigma_1, \sigma_2), opk, cm, \widehat{cm})$} \\[1em]
\end{tabular}
\end{center}

\noindent \underline{(Show, Verify)}: Using ..... Show, and Verify interact as follows



\begin{center}
    \begin{tabular}{l@{\hspace{8em}}c@{\hspace{8em}}l}
    \underline{Show($opk, cm, Cred$)} && \underline{Verify($osk, Cred' $)} \\[1em]
    \end{tabular}
\end{center}

\newpage


\subsection{Sybil Resistance}
-



























\newpage
\section{Security analysis of identity system}






\section{Performance Evaluation}


















\cleardoublepage
\section{Appendix, Old Writings}
\newpage

\subsection{Old Intro}

\textbf{Privately Linked Context Credentials}
The Internet Identity Workshop discussed a problem space summarised by the following problems:
1. issuing credentials that are both government and privately issued
2. retaining accountability in derived credentials, ensuring derived credentials are fit for purpose and have revocation (Proveable Provenance, Linked Data)
3. combining traditional digital identity with decentralized identity




As digital wallets are gradually introduced, one notable problem involves combining 
As digital identities are introduced, there must be methods to combine the old world and the new world with respect to identities. 
One problem use-case is organisations such as a university issuing certificates as credentials. 
Universities want to start issuing credentials to users 

A university, a credential provider, and wants to issue a credential to a user sam.

The University is not yet using decentralized identity but would like to issue a credential to Sam's digital identity wallet. 
Sam's logged in to the university portal with his classical login. Sam presses "Issue Credential" and starts the credential-issuing process. 

The university wants to check a few things before issuing this credential.
1. make sure their national credential is valid, that is, it verifies
2. as it's an anonymous credential, the university wants to make sure the user that's logged into their portal is the same user with the registration credential. The user may selectively disclose their attributes, or prove equality of attributes in zero knowledge, or may have another proof.

The university generates a credentialId and stores it in their system and carries out the following protocol with Sam

Sam wants to keep as many details as secret as possible, and thus, he carries out the following protocol
1. Sam creates a new commitment Com([pid, 0]r), proves opening of the commitment and equality of pid between rcm and this commitment.
2. The university generates Com([0,credId]0) and homomorphically creates ccm([pid, credId]r) = Com([pid, 0]r) x Com([0,credId]0). The university then signs ccm([pid, credId]r) with their own signature scheme.
3. Sam can now take rcm and ccm, sigma(ccm) to the blockchain of nodes.
4. Sam runs a protocol with the blockchain to be issued a Decentralied version of this credential with full private accountability. 


\subsection{ZKP Sigma Protocol for proving PRF output with pairing}

\[
ZKP
    \left\{ 
    (m_1, m_2, r_1, r_2): C_1 = g_1^{m_1}h_1^{r_1} \in \G_1 \wedge C_2 = g_2^{m_2}h_2^{r_2} \in \G_2 \wedge m_1 \cdot m_2 = 1
    \right\}
\]


\pcb{
\prover[m_1, m_2, r_1, r_2] \< \< \verifier[C_1, C_2, g, h]  \\[0.1\baselineskip][\hline]
\<\< \\[-0.5\baselineskip]
\pclinecomment{$C_1 = g_1^{m_1}h_1^{r_1}, C_2 = g_2^{m_2}h_2^{r_2}$ } \\
{\{\rho_i\}_{i=1}^2, \{\beta_i\}_{i=1}^2, \{\gamma_i\}_{i=1}^4}  \sample \mathbb{Z}_q^8 \<\< \\
T_1 \in \G_1 \gets g_1^{\beta_1}h_1^{\rho_1} \<\< \\
T_2 \in \G_2 \gets g_2^{\beta_2}h_2^{\rho_2} \<\< \\
\pclinecomment{generate interim elements} \\
\alpha_1 \gets m_1 \cdot m_2 \<\< \\
\alpha_2 \gets m_1 \cdot t_2 \<\< \\
\alpha_3 \gets t_1 \cdot m_2 \<\< \\
\alpha_4 \gets t_1 \cdot t_2 \<\< \\
A_1 \gets e(g_1, g_2) \<\< \\
A_2 \gets e(g_1, h_2) \<\< \\
A_3 \gets e(h_1, g_2) \<\< \\
A_4 \gets e(h_1, h_2) \<\< \\
\pclinecomment{$C_3 = e(C_1, C_2)$} \\
C_3 \in \G_T \gets A_1^{\alpha_1} A_2^{\alpha_2} A_3^{\alpha_3}  A_4^{\alpha_4}\<\< \\
T_3 \in \G_T \gets  A_1^{\gamma_1} A_2^{\gamma_2} A_3^{\gamma_3} A_4^{\gamma_4} \<\< \\
\< \sendmessageright* {\{C_i, T_i\}_{i=1}^3, \{A_i\}_{i=1}^4} \< \\
\< \sendmessageleft*{e} \< e \sample \mathbb{Z}_q \\
\{z_{mi} = \beta_i + e \cdot m_i \}_{i=1}^2 \<\< \\
\{z_{ri} = \rho_i + e \cdot r_i \}_{i=1}^2 \<\< \\
\{z_{ai} = \gamma_i + e \cdot \alpha_i \}_{i=1}^4 \<\< \\
\< \sendmessageright*{\{z_{mi}, z_{ri}\}_{i=1}^2, \{z_{ai}\}_{i=1}^4 } \< \\
\<\< C_1^e \cdot T_1 \stackrel{?}{=} g_1^{z_{m1}} h_1^{z_{r1}}\\
\<\< C_2^e \cdot T_2 \stackrel{?}{=}  g_2^{z_{m2}} h_2^{z_{r2}}\\
\<\< C_3^e \cdot T_3 \stackrel{?}{=}  A_1^{z_{a1}}A_2^{z_{a2}}A_3^{z_{a3}}A_4^{z_{a4}}\\
\<\< 
}


\newpage
\subsubsection{Completeness}
Proof of knowledge of exponents $m1, r1$ by opening $C_1$
    \begin{align}
    C_1^e \cdot T_1 &\stackrel{?}{=} g^{z_{m1}} h^{z_{r1}} \notag \\
    (g^{m1}h^{r_1})^e \cdot g^{\beta_1}h^{\rho_1} &= g^{\beta_1 + e \cdot m_1} h^{\rho_1 + e \cdot r_1} \notag \\
    g^{e \cdot m1 + \beta_1}h^{e \cdot r_1 + \rho_1} &= g^{\beta_1 + e \cdot m_1} h^{\rho_1 + e \cdot r_1} \notag
    \end{align}

    
Proof of knowledge of exponents $m2, r2$ by opening $C_2$
\begin{align}
    C_2^e \cdot T_2 &\stackrel{?}{=} \tilg^{z_{m2}} \tilh^{z_{r2}} && \label{eq:ver2} \\
    (\tilg^{m2}\tilh^{r_2})^e \cdot \tilg^{\beta_2}\tilh^{\rho_2} &= \tilg^{\beta_2 + e \cdot m_2} \tilh^{\rho_2 + e \cdot r_2} \notag \\
    \tilg^{e \cdot m2 + \beta_2}\tilh^{e \cdot r_2 + \rho_2} &= \tilg^{\beta_2 + e \cdot m_2} \tilh^{\rho_2 + e \cdot r_2} \notag
    \end{align}

    
\begin{align}
    C_3 = e(C_1, \tilde{C_2}) = e(g^{m1} h^{r1}, \tilg^{m2} \tilh^{r2}) \notag \\
    = e(g^{m1}, \tilg^{m2}) \cdot e(g^{m1},\tilh^{r2}) \cdot e(h^{r1}, g^{m2}) \cdot e(h_1^{r1}, \tilh^{r2})  \notag \\
    = e(g, \tilg)^{m1\cdot m2} \cdot e(g,\tilh)^{m1 \cdot r2} \cdot e(h, \tilg)^{r1 \cdot m2} \cdot e(h, \tilh)^{r1 \cdot r2}  \notag \\
\end{align}



\begin{itemize}
    \item Prove knowledge of exponents $(m1 \cdot r2), (r1 \cdot m2), (r1 \cdot r2)$ for $C_3$/$e(g,\tilg)$  with respect to base points $e(g,\tilh) e(h, \tilg) e(h, \tilh)$
    \item $C_3$/$e(g,\tilg)$ 
    \item 
\end{itemize}


Prove that $e(g, \tilg)^{(m1 \cdot m2)} = e(g, \tilg)$ by computing $C_4 = e(g,\tilh)^{m1 \cdot r2} \cdot e(h, \tilg)^{r1 \cdot m2} \cdot e(h, \tilh)^{r1 \cdot r2}$, proving the opening and equality of $(m1 \cdot r2), (r1 \cdot m2), (r1 \cdot r2)$ with $C_3$, then proving $C_3/C_4 = e(g, \tilg) \cdot e(g,\tilh) \cdot e(h, \tilg) \cdot e(h, \tilh) $

\newpage
\subsubsection{Analysis Pairing Method}
\begin{itemize}
    \item \textbf{Prover:} 2 $\G_1$ exp, 2 $\G_2$ exp, 8 $\G_T$ exp, 1 $\G_1$ add, 1 $\G_2$ add, 6 $\G_T$ mul, 12 $\F_p$ mul, 8 $\F_p$ add, 4 pairing
    
    \item \textbf{Verifier:} 3 $\G_1$ exp, 3 $\G_2$ exp, 5 $\G_T$ exp, 2 $\G_1$ add, 2 $\G_2$ add, 4 $\G_T$ mul
\end{itemize}

\subsubsection{Soundness}
\todonote{Sam todo}

\subsubsection{Zero Knowledge}
\todonote{Sam todo}



\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Operation} & \textbf{Prover} & \textbf{Verifier} \\
\hline
\multicolumn{3}{|l|}{\textbf{Commitment Equality Method}} \\
\hline
G1 exponentiations & 4 & 5 \\
G1 additions & 2 & 4 \\
Fp multiplications & 3 & 0 \\
Fp additions & 3 & 0 \\
\hline
\multicolumn{3}{|l|}{\textbf{G1 VRF Method}} \\
\hline
G1 exponentiations & 11 & 11 \\
G1 additions & 4 & 7 \\
Fp multiplications & 6 & 0 \\
Fp additions & 6 & 0 \\
\hline
\multicolumn{3}{|l|}{\textbf{Pairing + VRF Method}} \\
\hline
G1 exponentiations & 2 & 3 \\
G2 exponentiations & 2 & 3 \\
G1 additions & 1 & 2 \\
G2 additions & 1 & 2 \\
Fp multiplications & 12 & 0 \\
Fp additions & 8 & 0 \\
GT exponentiations & 8 & 5 \\
GT multiplications & 6 & 4 \\
Pairings & 4 & 4 \\
\hline
\end{tabular}
\caption{Comparison of computational operations between G1 and Pairing methods}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{|l|r|}
\hline
\textbf{Operation} & \textbf{Time} \\
\hline
Full Pairing & 1.6218 ms \\
Miller Loop & 0.6931 ms \\
Final Exponentiation & 0.9287 ms \\
G1 Mixed Addition (Affine + Jacobian) & 672 ns \\
G1 Point Doubling (2P) & 414 ns \\
G2 Mixed Addition (Affine + Jacobian) & 2143 ns \\
G2 Point Doubling (2P) & 1302 ns \\
\hline
Estimated G1 Scalar Mult (255-bit) & 191.59 $\mu$s \\
\emph{\small(255 doublings + ~128 additions)} & \\
Estimated G2 Scalar Mult (255-bit) & 606.01 $\mu$s \\
\emph{\small(255 doublings + ~128 additions)} & \\
\hline
\end{tabular}
\caption{Performance metrics for arkworks BLS12-381 implementation. Scalar multiplication estimates assume naive double-and-add implementation without optimizations.}
\label{tab:arkworks-performance}
\end{table}
\footnotetext{The G1 and G2 scalar multiplication estimates are derived using a naive double-and-add implementation analysis for 255-bit scalars. For a random scalar $k$, we assume approximately 255 doubling operations (one per bit) and 128 addition operations (corresponding to an expected Hamming weight of $\frac{255}{2}$ for a random scalar). The G1 estimate of 191.59$\mu$s is computed as $(255 \times 414\text{ns}) + (128 \times 672\text{ns})$ using the measured doubling and mixed addition timings. Similarly, the G2 estimate of 606.01$\mu$s is computed as $(255 \times 1302\text{ns}) + (128 \times 2143\text{ns})$. These estimates represent upper bounds as they do not account for common optimizations such as windowing methods, NAF (Non-Adjacent Form) representations, or parallel computation strategies.}


\newpage
\subsection{Research Questions}
\textbf{Main Research Question: }

\textit{How can credential systems be designed to maintain accountability and sybil resistance with privacy and unlinkability. }

\noindent \textbf{Sub Research Questions}

\textit{How can we design a privacy-preserving credential system that enables hidden linking of government and private credentials while maintaining provable provenance and revocability?}

\textit{How can we efficiently combine credentials for verification while retaining their security properties}


\subsection{Methods}

\subsubsection{Notation}
Let $a : \N \mapsto \N \bigcup \{*\}$ and $b : \N \mapsto \N$ be any functions for which $a(\lambda)$ and $b(\lambda)$ are computable in $poly(\lambda)$ time (expect when $a$ takes value $*$).
\begin{definition}
    A function family $F_{(\cdot)}(\cdot) : \bit^{a(\lambda)} \mapsto \bit^{b(\lambda)}$ is a family of $VRFs$ if there exists a PPT algorithm $Gen$ and deterministic algorithms $Prove$ and $Ver$ such that $Gen(\secparam)$ outputs a pair of keys $(sk, pk)$, $Prove_{sk}(x)$ computes $(y, \pi)$ where $\pi$ is the proof of correctness, and $Ver_{pk}(x,y,\pi)$ verifies that $y = e(g,g)^{1/x+sk}$ using the proof $\pi = g^{1/x+sk}$
\end{definition}

\subsubsection{Notation - another version}
A probabilistic polynomial time algorithm $\algo(\ins) \rightarrow \out$ receives an input $\ins$ and returns an output $\out$. $r \getsrand \Zp$ r is sampled uniformly from the set of field elements modulo $p$,  $h \gets y$ is a deterministic assignment. $[n]$ denotes a sample space of $\{1,\dots,n\}$. We assume type 3 bilinear pairings, $e: \G_1 \times \G_2 \to \G_t$ over groups of prime order $p$, $g, \tilde{g}$ are uniformly chosen generators for $\G_1, \G_2$ such that $e(g, \tilde{g}) = g_t$. We use bold variables to denote vectors as \vect{m} = $[m_1, \dots, m_{\ell}]$, \textbf{g} $\in \G^{\ell}$, \textbf{x} $\in \Z_p^{\ell}$, $\textbf{g}^{\textbf{x}}$ = $\sum\nolimits_{i=1}^\ell g_i^{x_i}$. We use multiplicative notation for $\G$ points i.e. $g^k = g \cdot g \;  (k \text{ times})$

\subsubsection{Pseudo Random Function}
We use the properties of a pseudo-random function to derive the relationship between a master and context credential. The pseudorandomness property ensures the output $y$ is computationally indistinguishable from random and thus hides the relationship between the user's secret key $sk$ and an input $x$ which could be the context of the new credential we want to privately link to.
\[
    PRF_{sk}(x) \to y
\]

\begin{definition}[Pseudo Random Function]
    A PRF is a couple of algorithms $(PRF.Gen, f)$ with key space $\setK$, input space $\setX$ and output space $\setY$ such that 
    \begin{itemize}
        \item $Gen(\secparam) \to (sk): s \sample S$, sets $sk = s$
        \item $f:$ $\mathcal{K} \times \mathcal{X} \to \mathcal{Y}$ is a keyed function family
    \end{itemize}
\end{definition}

The main security property of a $PRF$ is pseudorandomness, which informally states the output should appear random and not be able to be guessed. Formally, defined as

\begin{definition}[Pseudorandomness]
    A couple of PPT algorithms $(PRF.Gen, f)$ is a \textit{Pseudo Random Function} if, for any $\PPT$ adversary $\adv$ there exists a negligible function $\epsilon$ such that 
    \[
    \advantage{}{}[(\adv)] := 
        \left|
    \Pr     \left[ 
                \mathsf{Exp}^{\mathsf{prf}}(\adv) = 1
            \right] - \frac{1}{2}
        \right| \leq \epsilon(\lambda)
    \]
\end{definition}

\begin{figure}
\begin{pchstack}[boxed, center, space=1em]
    \procedure[]{$\mathrm{Exp}^{\mathsf{prf}}(\adv)$}{%
        b \sample \bit \\
        \text{Sample } k \sample PRF.Gen(1^{\lambda}) \\
        \text{Sample } f^* \sample \{g : g : \mathcal{X} \to \mathcal{Y}\} \\
        \text{Run } b' \gets \adv^{\oracle_{\mathsf{prf}}}(1^{\lambda}) \\
        \pcreturn b == b'
    }
    \procedure[]{$\oracle_{\mathsf{prf}(x)}$}{%
        \pcif b = 1 \\
        \t \pcreturn f_k(x) \\
        \pcelse \\
        \t \pcreturn f^*(x)
    }
\end{pchstack}
  \caption{The pseudorandomness game with adversary $\adv$ and PRF $(PRF.Gen, f)$}
  \label{fig:prf}
\end{figure}


\begin{definition}[Computational Indistinguishability] \\
    Let $X = \{X(a,n)\}_{a \in \{0,1\}^*; n \in \mathbb{N}}$ and $Y = \{Y(a,n)\}_{a \in \{0,1\}^*; n \in \mathbb{N}}$ be two probability ensembles, where:
    \begin{itemize}
        \item Each ensemble is an infinite sequence of random variables
        \item $a \in \{0,1\}^*$ represents parties' inputs
        \item $n \in \mathbb{N}$ represents the security parameter
    \end{itemize}
    
    $X$ and $Y$ are said to be computationally indistinguishable, denoted by $X \stackrel{c}{\equiv} Y$, if for every non-uniform polynomial-time algorithm $D$ (called a distinguisher), there exists a negligible function $\mu(\cdot)$ such that for every $a \in \{0,1\}^*$ and every $n \in \mathbb{N}$:
    
    \[ |\Pr[D(X(a,n)) = 1] - \Pr[D(Y(a,n)) = 1]| \leq \mu(n) \]
    
    \end{definition}
    
    \begin{remark}
    This definition captures the idea that no efficient algorithm can tell the difference between samples from $X$ and samples from $Y$ with non-negligible probability. The term "non-uniform" allows the distinguisher $D$ to have hard-coded advice that may depend on the input length, potentially making it more powerful.
    \end{remark}

\begin{definition}[Bilinear map]
    Let $\mathbb{G}_1$, $\mathbb{G}_2$ and $\mathbb{G}_T$ be cyclic groups of prime order $p$, where $\mathbb{G}_1$ and $\mathbb{G}_2$ are multiplicative and $\mathbb{G}_T$ is multiplicative. Let $g$ and $h$ be generators of $\mathbb{G}_1$ and $\mathbb{G}_2$, respectively. We call $e : \mathbb{G}_1 \times \mathbb{G}_2 \rightarrow \mathbb{G}_T$ a bilinear map or pairing if it is efficiently computable and the following holds:
    
    \textbf{Bilinearity:} $e(g^a, \tilde{g^b}) = e(g, \tilde{g})^{ab} \quad \forall a,b \in \mathbb{Z}_p$.
    
    \textbf{Non-degeneracy:} $e(g, \tilde{g}) \neq 1_{\mathbb{G}_T}$, i.e., $e(g, \tilde{g})$ generates $\mathbb{G}_T$.
    
   \noindent If $\mathbb{G}_1 = \mathbb{G}_2$, then $e$ is symmetric (Type-1) and asymmetric (Type-2 or 3) otherwise. For Type-2 pairings, there is an efficiently computable isomorphism $\Psi : \mathbb{G}_2 \rightarrow \mathbb{G}_1$ but none from $\mathbb{G}_1 \rightarrow \mathbb{G}_2$; for Type-3 pairings, no efficiently computable isomorphisms between $\mathbb{G}_1$ and $\mathbb{G}_2$ are known. Type-3 pairings are currently the optimal choice in terms of efficiency for a given security level.
\end{definition}

\begin{definition}[Commitment scheme]
    A commitment scheme is a tuple $(\mathsf{Setup}, \mathsf{Commit}, \mathsf{Open})$ of PPT algorithms where:
    
    \begin{itemize}
        \item $\mathsf{Setup}(1^\lambda) \to \mathsf{ck}$ takes security parameter $\lambda$ (in unary) and generates the commitment key $\mathsf{ck}$;
        
        \item $\mathsf{Commit}_{\mathsf{ck}}(m) \to (\cm, r)$ obtains commitment $\cm$ from secret message $m$ and an opening key $r$ which may be the randomness used in the computation.
        
        \item $\mathsf{Open}_{\mathsf{ck}}(\cm; m, r) \to b \in \{0, 1\}$ verifies the opening of the commitment $\cm$ to the message $m$ provided with the opening hint $r$, outputting a decision as to whether $\cm$ commits to $m$. 
    \end{itemize}
\end{definition}

\begin{definition}[Secret Sharing]
    A $(t,n)$ secret sharing scheme $\mathsf{SS}$ is a tuple of $\PPT$ algorithms $(\mathsf{Share}, \mathsf{Combine})$ over message space $x \in X$:
    \begin{itemize}
        \item $\mathsf{Share}^{t,n}(x, r) \torand ([x]_1, \dots, [x]_n)$ takes input $x \in X$, randomness $r$ and outputs $n$ shares $([x]_1, \dots, [x]_n)$
        \item $\mathsf{Combine}^{t,n}([x]_i, \dots, [x]_t) \to x'$ takes a threshold of secret shares $[x]_i$ for $i > t$ as input and combines to form $x'$ the representation of the original message $x' \in X$
    \end{itemize}
\end{definition}

\begin{definition}[Threshold Public-Key Encryption]
A Threshold Public-Key Encryption Scheme $\mathsf{TPK}$ is a set of $\PPT$ algorithms $\mathsf{(KeyGen, Enc, Dec, Verify, Combine)}$ over $\messagespace$: 
    \begin{itemize}
        \item $\mathsf{TPK.Setup}(\secparam, n, t) \torand \{\pk, \vk, (\sk_1, \dots, \sk_n)\}:$ input the $t$ of $n$ threshold, output $\pk$ the public key, $\vk$ the verification key, and $\sk_i$ the shared secret key for each party.
        \item $\mathsf{TPK.Enc}(\pk, m, \rho) \torand \beta:$ input message $m$ and randomness $\rho$, output encryption $\beta$
        \item $\mathsf{TPK.Dec}(\beta, \sk_i)) \to m_i:$ each party decrypts $\beta$ with their shared secret key $\sk_i$
        \item $\mathsf{TPK.Verify}(\pk, \vk , m_i) \to  \bit:$ input $\pk, \vk$ and share of $m_i$, verify $m_i$ was computed correctly from $\pk, \vk$
        \item $\mathsf{TPK.Combine}(\pk, \vk, {m_i}_{i \in \setspace \subseteq [n] s.t. |\setspace| \geq t + 1}) \to m:$ recovers message $m$ given $t + 1$ partial decryptions which verify successfully
    \end{itemize}
\end{definition}


\begin{definition}[Homomorphism]
    Let $G$ and $H$ be groups. A function $\phi: G \to H$ is called a \textit{homomorphism} if it preserves the group operation. Specifically, for any elements $a, b \in G$, the following equation holds:
    
    \[\phi(a \ast b) = \phi(a) \circ \phi(b)\]
    
    where $\ast$ denotes the group operation in $G$ and $\circ$ denotes the group operation in $H$.
    \end{definition}
    
    \begin{remark}
    Note that $\phi$ is not required to be injective (one-to-one) or surjective (onto).
    \end{remark}
    
    \begin{definition}
    For a homomorphism $\phi: G \to H$, the \textit{image} of $\phi$ is defined as:
    
    \[\operatorname{Im}(\phi) = \phi(G) = \{\phi(g) : g \in G\} \subseteq H\]
    \end{definition}

    \begin{definition}[Image of homomorphism]
        For a homomorphism $\phi: G \to H$, the \textit{image} of $\phi$ is defined as:
        
        \[\operatorname{Im}(\phi) = \{h \in H \mid \exists g \in G \text{ such that } \phi(g) = h\}\]
        
        \end{definition}

        \begin{remark}
            The image of a homomorphism $\phi: G \to H$ can be thought of as the "landing spot" in $H$ for elements coming from $G$. It's the subset of $H$ that includes all possible outputs when $\phi$ is applied to any element in $G$. In essence, $\operatorname{Im}(\phi)$ tells us which elements of $H$ are "reachable" through $\phi$ from some element in $G$.
        \end{remark}





\newpage
\subsubsection{Verifiable Random Function}

\subsubsection{Syntax}
\begin{itemize}
    \item $Gen(\secparam) \to (sk, pk):$ samples $s \sample \Zp^*$, sets $sk = s$ and $pk \gets g^s$, returns $(sk, pk)$
    \item $Prove_{sk}(x) \to (y, \pi):$ $y \gets e(g,g)^{1/(x+sk)}$, $\pi \gets g^{1/(x+sk)}$ where $y$ is the $PRF$ output and $\pi$ is the proof of correctness
    \item $Verify_{pk}(x, y, \pi) \to \bit$ to verify $y$ was computed correctly, verify $e(g^x \cdot pk, \pi) = e(g,g)$ and $y = e(g, \pi)$, output 1 for success, 0 for fail
\end{itemize}

\begin{definition}[Verifiable Random Function]

    A PRF is a triplet of $\PPT$ algorithms $(VRF.Gen, VRF.Eval, VRF.Vfy)$ satisfying:
    \begin{enumerate}
        \item Correctness: For any $(pk, sk)$ in the image of $VRF.Gen(\secparam)$ and any $x \in \setX$
        \[
        \begin{aligned}
            (y, \pi) &\gets VRF.Eval_{sk}(x) \\
            1 &\gets VRF.Vfy_{pk}(x, y, \pi)
        \end{aligned}
        \]


    \item Unique Provability: For any $pk$ (not necessarily in the range of $VRF.Gen$, any input $x \in \setX$, pair of outputs $y_0, y_1 \in \setY$ and pair of proofs $\pi_0, \pi_1$ the following holds
    \[
        \begin{aligned}
            1 &\gets VRF.Vfy_{pk}(x,y_0,\pi_0) \\
            1 &\gets VRF.Vfy_{pk}(x,y_1,\pi_1) \\
            y_0 &= y_1
        \end{aligned}
    \]

    \item Pseudorandomness: For any $\PPT$ adversary $\adv$ running the VRF Experiment, there exists a negligible function $\epsilon$ such that 
    \[
         \advantage{}{}[(\adv)] := 
            \left|
        \Pr     \left[ 
                    \mathsf{Exp}^{\mathsf{rnd}}(\adv) \to 1
                \right] - \frac{1}{2}
            \right| \leq \epsilon(\lambda)
    \]
    
    \end{enumerate}

\end{definition}

\begin{figure}
\begin{pchstack}[boxed, center, space=1em]
    \procedure[]{$\mathrm{Exp}^{\mathsf{eval}}(\adv)$}{%
        \text{Sample } b \sample \bit \\
        pk, sk \sample VRF.Gen(1^{\lambda}) \\
        \text{set } x^* = \bot \\
        x^* \gets \adv^{\oracle_{\mathsf{eval}}}(pk) \\
        \pcif x^* \text{was previously queried:} \\
        \t \pcreturn 0 \\
        y_0 \sample \setY \\
        (y_1, \pi) \gets VRF.Eval(pk, x^*) \\
        \adv^{\oracle_{\mathsf{eval}}}(sk, y_b) \to b' \\
        \pcreturn b == b'
    }
    \procedure[]{$\oracle_{\mathsf{eval}(x)}$}{%
        \pcif x \neq x^* \\
        \t (y, \pi) \gets VRF.Eval_{sk}(x) \\
        \t \pcreturn (y, \pi) \\
        \pcelse: \pcreturn \bot \\
    }
\end{pchstack}
  \caption{The pseudorandomness game with adversary $\adv$ and PRF $(PRF.Gen, f)$}
  \label{fig:prf}
\end{figure}



% \newcommand{\vt}{\mathsf{vt}}
% \newcommand{\wx}{\mathsf{wx}}
% \newcommand{\wxone}{\mathsf{w_1x}}
% \newcommand{\wxtwo}{\mathsf{w_2x}}
% \newcommand{\wxhat}{\mathsf{\hat{w}x}}
% % \newcommand{\x}{\mathsf{x}}

% \newcommand{\acu}{\mathsf{ACU}}
% \newcommand{\acusetup}{\mathsf{ACU.Setup}}
% \newcommand{\acuadd}{\mathsf{ACU.Add}}
% \newcommand{\acudel}{\mathsf{ACU.Del}}
% \newcommand{\acuvermem}{\mathsf{ACU.VerMem}}
% \newcommand{\acuvernonmem}{\mathsf{ACU.VerNonMem}}


% \newcommand{\rev}{\mathsf{REV}}
% \newcommand{\revsetup}{\mathsf{REV.Setup}}
% \newcommand{\revrevoke}{\mathsf{REV.Revoke}}
% \newcommand{\revtokengen}{\mathsf{REV.TokenGen}}
% \newcommand{\revtokenver}{\mathsf{REV.TokenVer}}

% \newcommand{\rt}{\mathsf{rt}}

\subsection{Revocation}
Credential revocation is a fundamental challenge in identity management systems. While credentials grant users access to services, there must be mechanisms to invalidate them when necessary. Since the introduction of public key infrastructure, numerous solutions have been proposed to handle certificate revocation such as time-based expiration, usage limits (k-times use), and revocation lists. In the latter approach, a trusted authority manages a whitelist of valid credentials or blacklist of revoked ones, requiring users to prove their credential status with respect to the list.

The challenge becomes more complex in privacy-preserving systems as users must be able to prove revocation status without revealing the credential or its attributes. Furthermore, the revocation list should not leak information about which credentials are valid or revoked. 

\subsubsection{Revocation Scheme}
A revocation scheme enables efficient proofs of credential validity while maintaining privacy of the revocation status. The scheme consists of a revocation authority that manages the revocation state, protocols for revoking credentials, and methods for users to prove their credentials remain valid. A privacy-preserving revocation scheme must satisfy several properties:

\begin{itemize}
    \item Privacy: Users can prove their credential's status without revealing the credential
    \item Unlinkability: Multiple proofs by the same user cannot be linked
    \item Efficiency: Proofs should be succinct and verification efficient
    \item Dynamic Updates: The system supports real-time credential revocation
\end{itemize}

\paragraph{Syntax}
A revocation scheme consists of the following algorithms:

\begin{itemize}
    \item $\revsetup(\secparam) \torand (\ppar, \sk, \pk, \vt):$ Given security parameter $\secparam$, generates system parameters $\ppar$, authority's secret key $\sk$, public key $\pk$, and initial revocation state $\vt$
    
    \item $\revrevoke(\sk, \vt, \cred) \to (\vt', \text{RI}):$ Revokes credential $\cred$, updates revocation state from $\vt$ to $\vt'$, and outputs revocation information RI
    
    \item $\revtokengen(\cred, \vt, \text{RI}) \to \rt:$ Generates a revocation token $\rt$ for credential $\cred$ using the current revocation state $\vt$ and revocation information RI
    
    \item $\revtokenver(\vt, \cred, \rt) \to \bit:$ Verifies revocation token $\rt$ for credential $\cred$ against revocation state $\vt$
\end{itemize}

\subsubsection{Accumulator}
An accumulator allows for compact representation of a set while enabling efficient proofs of membership. Our construction uses a universal accumulator that supports both membership and non-membership proofs. The accumulator maintains a constant-size value regardless of the number of elements in the set, while allowing elements to be dynamically added and removed. For each element, the system can generate succinct witnesses that prove either membership or non-membership in the accumulated set.

\subsubsection{Syntax}
An accumulator $\acu$ is a set of $\PPT$ algorithms $\acu = \mathsf{Setup, Add, Del, VerMem, VerNonMem}$. 
\begin{itemize}
    \item $\acusetup(\secparam) \torand \ppar, \sk, \pk, \vt:$ generates system parameters, takes security parameter $\secparam$ as input, outputs system parameters $\ppar$, secret key $\sk$, public key $\pk$, and initial accumulator value $\vt$
    
    \item $\acuadd(\sk, \vt, \x) \to (\vt', \wx):$ adds element $\x$, takes secret key $\sk$, current accumulator value $\vt$, element $\x$ as input. Outputs updated accumulator value $\vt'$, and membership witness $\wx$
    
    \item $\acudel(\sk, \vt, \x) \to (\vt', \wxhat):$ Deletes element $\x$, takes secret key $\sk$, current accumulator value $\vt$, element $\x$ as input. Outputs updated accumulator value $\vt'$, non-membership witness $\wxhat$ 
    
    \item $\acuvermem(\vt, \x, \wx) \to \bit:$ verifies membership, takes current accumulator value $\vt$, element $\x$, witness $\wx$ as input. Outputs accept/reject
    
    \item $\acuvernonmem(\vt, \x, \wxhat) \to \bit:$ Verifies non-membership, takes current accumulator value $\vt$, element $\x$, non-member witness $\wxhat$ as input. Outputs accept/reject
\end{itemize}

 with additional witness operations $\mathsf{MemWitUpOnAdd/Del, NonMemWitUpOnAdd/Del}$ 


 \subsection{Discussion}
 
The Internet Identity Workshop discussed a problem space summarised by the following problems:
\begin{enumerate}
    \item issuing credentials that are both government and privately issued
    \item retaining accountability in derived credentials, ensuring derived credentials are fit for purpose and have revocation (Proveable Provenance, Linked Data)
    \item combining traditional digital identity with decentralized identity
\end{enumerate}

A user has an Identity linked to multiple credentials, such as a driver's license and university card. Users want to authenticate with various Relying Parties (Verifiers) without being linked between multiple uses of the same service (e.g. a user verifying multiple credentials with 1 service such as a bank requiring proof of multiple credentials linked to an identity), and between uses of different services (e.g. a user presenting their drivers license for age verification on multiple services).

Current decentralized identity systems either don't provide this functionality or provide it at the expense of either accountability or privacy. CanDID stores a map between users multi-layered credentials providing a solution to the problem at the expense of the user's privacy. Other credential systems and pseudonym systems prove equality of hidden attributes in a credential such as name or id, which can more-easily be forged and does not support the hierarchical structure leveraging a highly secure and accountable government identity with not-so secure private credentials.


\noindent \textbf{Credential Chaining}


\noindent \textbf{Pseudonym Systems}
There are 2 main models for Pseudonyms. One where the user has a Master Credential and derives pseudonym, or context credentials from the Master Credential. The applications differ; for example, in \textbf{Model 1}, a user may have their Passport as their Master Credential and wish to use it in a different scenario, such as voting for an election. The user will derive, by themselves, a new credential with the context "voting-2024," which will be verified in the same way as the master credential.
\textbf{Model 2} differs in application scenarios. A context credential represents a credential from a different issuer, for example, a driver's license. During Context Credential issuance, a user will present their Master Credential which will be used to verify the identity of a user and to link the 2 credentials together. During context credential verification, the user may be requested to present just their Context Credential, or perhaps in a high-security verification setting, where a user may need to prove attributes in multiple credentials both Master and Context will need to be presented together. We optimize for this setting while \emph{preserving privacy.}



\noindent \textbf{Pseudonym Model 1: Master Credential, One Issuer, derived Pseudonyms}

SyRA and TACT optimize for Non-Interactivity
They also define context differently to us. Which isn't what CanDID defines context as and doesn't work for the same usescases and CanDID was defined for. 

Previous Methods

\noindent SyRA: Sybil-Resilient Anonymous Signatures  with Applications to Decentralized Identity \cite{crites_syra_2024}
1. enables users to "derive" unlinkable, sybil resistant pseudonyms (signatures) for a context e.g. PRF(sk, ctx) without interacting with the issuer
2. does not store a mapping on the issuer
3. Security properties: Sybil resistance in the context. Anonymity: no information is leaked through their nyms or signatures. Proves UC security for unforgeability, Sybil resilience, privacy, and unlinkability
4. SyRA leaves support for Identity Attributes for future work.

Summary: First, a protocol with issuer creates a user with secret key $s$. $s$ generates a context specific pseudonym, or tag $T$ "that attaches itself to a signature"?

\begin{itemize}
    \item Level 1: $Issue_{isk}(s)$: $VRF_{isk}(s) \to T, \pi_{prf}$ such that $\pi_{prf}$ generates the users keys and is symmetric across $\G_1, \G_2$: This algorithm is computed by the issuer with their secret key $isk$ on identity string $s$ Outputs $T = e(g, \tilde{g})^{1/(s + isk)}$ and $\pi_{prf}$ is $usk = g^{1/(s + isk)} \in \G_1$ and $\widehat{usk} = \tilde{g}^{1/(s + isk)} \in \G_2$. Their verify algorithm is the same as the Dodis Yampolskiy and also verifies the asymmetric keys with bilinear pairing.
    \item Level 2: $Sign_{usk, \widehat{usk}}(ctx, m, ivk)$: $VUF_{usk}(ctx) \to T = e(H(ctx), \widehat{usk})$: This is the "sybil resistant signature". Proof of correctness comes from sigma protocol. During the verify protocol, the 
\end{itemize}

Conclusion: SyRA creates a signature scheme where a user can "sign" on $ctx, m$ from their secret key based on a VRF of their identity and the issuer's key. This does not account for Attribute-based credentials.

Attribute-Based Threshold Issuance Anonymous Counting Tokens \cite{rabaninejad_attribute-based_nodate}
What don't they do that we do?
We avoid Groth Sahai proofs - page 26 they refer to proving the signature scheme with GS proofs. 
They use Naor Pinkas Reingold PRF and verify signature with GS proofs. 
They focus only on deriving credentials / pseudonyms from their

\noindent \textbf{Pseudonym Model 2: Master Credential, Multiple Issuers, Different Pseudonyms}
The Pseudonym Model \cite{goos_pseudonym_2000} presents as an interaction between a User, a Certificate Authority (CA), and a Pseudonym Organisation (O). The user's identity is registered to the CA with their keypair $skU, pkU$, receiving a Master Credential to act as a trust anchor for all pseudonyms. With their Master Credential, Users request \emph{unlinkable} Pseudonyms for other organizations by first proving the knowledge of a Master Credential that verifies with the CA, and the pseudonym requested has the same keypair as the Master Credential. Organizations \emph{blindly} issue Pseudonym credentials on the same keypair as the Master Credential.


\begin{itemize}
    \item \textbf{$MasterCredIssue(skU, pkU, identity, skCA) \to CredM$} is an interactive algorithm run by a user and a credential authority with keypair $skCA, pkCA$. The user is known to the CA and shares their identity and a keypair $skU, pkU$. The $CA$ checks the $skU, pkU$ relation and issues $CredM$, a signature $\sigma_{CA} \gets Sign_{skCA}(pkU)$
    
    \item \textbf{$NymGeneration(CredM, pkCA, Nym, skO) \to CredNym$} is an interactive algorithm run by a user and an organization the user wishes to create a pseudonym with. 
    $Nym1$ is a commitment $Com(skU, pkU, r)$ with randomness $r$, $r$ should be unique per pseudonym. 
    $U$ generates a zero-knowledge proof of knowledge of a new pseudonym $Nym1$ with $skU, pkU$ corresponding to $CredM$, $CredM$ verifies correctly, and $pkU, skU$ are related. 
    \[
    \begin{aligned}
    ZKP
    \{ 
        (skU, pkU, r): Nym &= Com(skU, pkU, r) \; \wedge \\
        Verify_{pkCA}(CredM) &= 1 \; \wedge \\ 
        pkU &= g^{skU}
     \}
    \end{aligned}
    \]
    On successful ZKP verification, algorithm outputs $CredNym \gets Sign_{skO}(Nym)$

    \item \textbf{$NymVerify(CredNym, pkO) \to \bit $} is an interactive algorithm run by a user and a verifier. Recall $CredNym$ is a signature over a commitment $Sign_{skO}(Nym)$. The user randomizes $CredNym' \gets CredNym$ and $Nym' \gets Com(skU, pkU, r)$, and in zero knowledge, proves $CredNym$ verifies correctly with respect to the original signature, and the organisation public key
        \[
        \begin{aligned}
        ZKP
        \{  
            (skU, pkU, r, r'): Nym' &= Com(skU, pkU, r') \; \wedge \\
            \exists \; Nym \text{ such that } Verify_{pkO}(Nym) &= 1 \; \wedge \\ 
            Nym &= Com(skU, pkU, r) \; \wedge \\
            pkU &= g^{skU}
        \}
        \end{aligned}
        \]
\end{itemize}




\newpage
\subsection{NIZK for Sybil Resistant Issuance}
We have $g^{\frac{1}{m}}$ and $g^m$. We want to prove their relationship is reciprocal. We will use this later when proving the output of the Dodis Yampolskiy VRF $g^{\frac{1}{sk + x}}$
Let $m_1 = m$, and $m_2 = \frac{1}{m}$. Therefore, we can prove that $m_1 \cdot m_2 = 1$ 
\[ 
    \begin{aligned}
        C_1 &= g^{m_1}h^{r_1} \\
        C_2 &= g^{m_2}h^{r_2} \\
        C_3 &= C_1^{m_2}h^{r_3} \\ 
        C_4 &= h^{r_1m_2 + r_3} \\ 
    \end{aligned}
\]

We use $C_1, C_2$ in a zero-knowledge proof protocol to prove the relation with public elements $C_1, C_2, g, h$

\[
ZKP
    \left\{ 
    (m_1, m_2, r_1, r_2): C_1 = g^{m_1}h^{r_1} \wedge C_2 = g^{m_2}h^{r_2} \wedge m_1 \cdot m_2 = 1
    \right\}
\]

\pcb{
\prover[m_1, m_2, r_1, r_2] \< \< \verifier[C_1, C_2, g, h]  \\[0.1\baselineskip][\hline]
\<\< \\[-0.5\baselineskip]
\pclinecomment{$C_1 = g^{m_1}h^{r_1}, C_2 = g^{m_2}h^{r_2}$} \\
{\{\rho_i\}_{i=1}^4, \{\beta_i\}_{i=1}^2}  \sample \mathbb{Z}_q^6 \<\< \\
T_1 \gets g^{\beta_1}h^{\rho_1} \<\< \\
T_2 \gets g^{\beta_2}h^{\rho_2} \<\< \\
\pclinecomment{generate interim elements} \\
C_3 \gets C_1^{m_2}h^{r_3} \<\< \\
T_3 \gets C_1^{\beta_2}h^{\rho_3} \<\< \\
r_4 \gets r_1m_2 + r_3 \<\<  \\
C_4 \gets h^{r4} \<\< \\
T_4 \gets h^{\rho_4} \<\< \\
\< \sendmessageright* {\{C_i, T_i\}_{i=1}^4} \< \\
\< \sendmessageleft*{e} \< e \sample \mathbb{Z}_q \\
z_{m1} = \beta_1 + e \cdot m_1 \<\< \\
z_{r1} = \rho_1 + e \cdot r_1 \<\< \\
z_{m2} = \beta_2 + e \cdot m_2 \<\< \\
z_{r2} = \rho_2 + e \cdot r_2 \<\< \\
z_{r3} = \rho_3 + e \cdot r_3 \<\< \\
z_{r4} = \rho_4 + e \cdot r_4 \<\< \\
\< \sendmessageright*{\{z_{mi}\}_{i=1}^2, \{z_{ri}\}_{i=1}^4 } \< \\
\<\< C_1^e \cdot T_1 \stackrel{?}{=} g^{z_{m1}} h^{z_{r1}}\\
\<\< C_2^e \cdot T_2 \stackrel{?}{=}  g^{z_{m2}} h^{z_{r2}}\\
\<\< C_3^e \cdot T_3 \stackrel{?}{=}  C_1^{z_{m2}} h^{z_{r3}}\\
\<\< C_4^e \cdot T_4 \stackrel{?}{=}  h^{z_{r4}}\\
\<\< C_3/C_4 = g \\
}


% \begin{construction}{Opening Proof($C$)}{test}
%     \vspace{1em}
%     \textbf{Public parameters:} $g, h \in \G$

%     \textbf{Inputs:} $C$ such that $C = g^mh^r$, $\Prover$ knows $m, r \in \Z_q$.
%     \vspace{1em}
%     \begin{enumerate}
%         \item $\Prover$ samples $\alpha_1, \rho_1 \sample [q-1]$ and sends $T \gets g^{\alpha_1}h^{\rho_1}$
        
%         \item $\Verifier$ sends challenge $c \sample [q-1].$
    
%         \item $\Prover$ sends $s_1 \gets \alpha_1 + cm, s_2 \gets \rho_1 + cr$
    
%         \item $\Verifier$ verifies that $g^{s_1}h^{s_2} = C^cT$
%     \end{enumerate}
% \end{construction}

% \begin{theorem}
%     Construction \ref{construct:openproof} is a $\Sigma-$protocol for the relation
%     \[
%     \mathcal{R} = \left\{ (C,g,h,q),(m,r) \; | \; C = g^{m}h^r \right\}
%     \]
    
% \end{theorem}
% \begin{proof}
%     It follows from \cite{wahby_doubly-efficient_2018, schnorr_efficient_1991}
% \end{proof}