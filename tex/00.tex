\section{Introduction}\label{sec:intro}
Digital Identity systems form the foundation of online trust and authentication, processing billions of verifications daily \cite{noauthor_happy_2021, pang_zanzibar_nodate}. Traditional centralized systems, while effective for regulatory compliance \cite{eltayeb_crucial_2024}, suffer from significant privacy and security vulnerabilities. Ongoing data breaches \cite{zhang_data_2022} affect billions of users, demonstrating the risks of storing identity data and centralizing systems. Decentralized Identity (DID) is a loosely defined framework (W3C specification) having evolved over the past 2 decades, offering users greater control over their credentials \cite{soltani_survey_2021}, many concrete implementations struggle to balance privacy with accountability \cite{maram2021candid} for the required feature set. 


\noindent Anonymous Credential Systems (ACS) \cite{chaum1985security,hutchison_signature_2004, hutchison_constant-size_2006, sako_short_2016, fuchsbauer_structure-preserving_2019} address privacy concerns but face challenges balancing privacy with accountability, orthogonally, unconditionally anonymous payment systems have demonstrated how unconditional anonymity can enable system abuse. Current systems focus on protecting against sybil attacks \cite{crites_syra_2024, rabaninejad_attribute-based_nodate}, enabling revocation \cite{goos_dynamic_2002, robshaw_uc_2016, camenisch_scalable_2016, baldimtsi_accumulators_2017}, rich attribute-based credential authentication \cite{rosenberg_zk-creds_2022, babel_bringing_2023} but very few implement all. The tension between privacy and accountability has become increasingly critical as governments worldwide, particularly the EU's Digital Identity Framework \cite{noauthor_regulation_2024}, move toward privacy-preserving digital identity wallets. These challenges motivate the need for a comprehensive identity system that achieves privacy, accountability, and practical deployment requirements simultaneously.

\subsection{Organization}

Short Summary: We build a new anonymous credential building block for multi-issuer, multi-credential systems. We use it to build a new private digital identity system with sybil resistance and revocation.


\begin{enumerate}
    \item section \ref{sec:mimc} is the new anonymous credential system building block for multi-issuer, multi-credential
    \item section \ref{sec:sigmaproofs} outlines all sigma zkp's used
    \item section \ref{sec:idsys} builds a private identity system from the building block in section \ref{sec:mimc} and proofs in \ref{sec:sigmaproofs}
    \item section \ref{sec:evaluation} shows privacy and sybil resistance can be low-overhead, also shows our benchmarks for proving complex statements about credentials is more efficient than SOTA
\end{enumerate}


\subsection{Related Work}

\subsubsection{Decentralized Identity (DID)}
enables entities to create and manage digital identities without relying on a central authority. W3C specifications for DID and Verifiable Credentials define standards for globally unique, publicly verifiable credentials, allowing a user to prove claims (information) about their identity attributes. DID typically uses Distributed Ledgers and public key cryptography to establish a "web of trust" and maintain revocation registries. 

The DID model consists of 
\begin{enumerate}
    \item \textbf{Holders} Identities with Decentralized Identifiers (DID's) who manage their own keys, and credentials, and request access to resources
    
    \item \textbf{Issuers} create and sign credentials about identity holders
    
    \item \textbf{Verifiers} validate credentials by checking the presented cryptographic information against the registry

    \item  \textbf{Verifiable Data Registry}, often a DLT, is the root of trust, maintaining DID records, keys, and credential schemas, but doesn't store credential data
    
    \item \textbf{Identity Wallet}: the user interface for storing, managing, and presenting verifiable credentials
\end{enumerate}
 
Citations
- U-Prove, U-Port, Connect.me, Sovrin, PingID, w3c

While the W3C DID specifications outline core functionalities such as cryptographic verification, privacy preservation, selective disclosure, and revocation, it requires a formal security definition and proofs to achieve these properties. Anonymous Credential Systems provide well-established formal security definitions for many properties that DID aims to achieve. Specifically, Correctness, Unforgeability, Anonymity, Sybil Resistance, and Revocation. By building DID systems on top of Anonymous Credential primitives, DID systems can inherit these formal security guarantees. 

\subsubsection{Multi Attribute Anonymous Credentials} 
Anonymous Credentials are a long line of orthogonal work with the goal of providing privacy/anonymity to online interactions, These are now deployed in a number of real-world systems (U-Prove, Idemix, PrivacyPass).  
The line of work has improved with features, efficiency, and expressiveness throughout time. 
Abstractly, they provide private protocols to prove information on committed attributes. 
Pairing-based blind signatures enabled efficient multi-show credentials (CL, PS, BBS+).
Other constructions are based on (chase's MAC's, etc) 
Further work was done to the Anonymous Credential primitive to support delegation, update, and pseudonyms and may also require incorporating other cryptographic primitives to enable revocation, auditing, tracing, and sybil resistance. 

\subsubsection{Anonymous Credential Systems (ACS)} 
Anonymous Credential Systems implement primitives together in ways that preserve privacy and offer additional functionality required by systems. The combination of multiple primtiives to be used together in a privacy preserving way is complex it itself. 

\noindent \textbf{Accountable Privacy}
In a parallel industry, fully private financial systems like zcash, monero, and tornado cash where blockchain users can exploit and misuse the system is a big problem and will prevent governments and organisations to deploy private preserving techniques. Innovations in Identity often follow those in financial systems, (Chaum's e-cash and blind signatures, DAC and ZCash for example) as they share similar motivations and infrastructure, spending a coin anonymously is analogous to using an identity anonymously. Therefore, advancements in the field of Accountable Privacy (UTT, other examples), a series of techniques and protocols that balance the tradeoffs between privacy and accountability in financial systems, can inspire and motivate private identity systems.

\noindent \textbf{Privacy Preserving Decentralized Identity Systems}
CanDID proposed a privacy-preserving decentralized identity system achieving Sybil Resistance, Accountability. 
They defined a system architecture that has been extended in many different directions, such as \cite{wang2023hades, rathee_zebra_2022} optimising for blockchain performance and additional private-accountability features. \cite{crites_syra_2024, rabaninejad_attribute-based_nodate} optimize for non-interactivity and minimal stored state with the CanDID threshold committee

CanDID leaves integrating Decentralized Identity with Anonymous Credentials as open work.

\noindent \textbf{Decentralized Identity with Anonymous Credentials}
The strawman approach to combining Decentralized Identity with Anonymous Credentials replaces the existing credential, usually in the form of a signature over attributes, signed by an identity provider and verifiable with their public key, with a blind signature over attributes, which introduces the accountable privacy problems such as how to issue and verify a credential to an anonymous user, and how to retain accountability of an anonymous user, such are the real-world identity system requirements. 
Compatibility for a decentralized architecture requires decentralized cryptography which has propelled the use of threshold cryptography in anonymous credential schemes and other settings e.g. (Coconut, Threshold BBS+, ...). 


\newpage

\subsection{Contributions}

We present a privacy-preserving decentralized identity system for multi-issuer environments. Our system combines anonymous credential primitives with decentralized identity architecture, achieving security and privacy properties that are challenging to realize when naively combining these building blocks. Our main contributions are:

\begin{enumerate}
    
    \item  A privacy-preserving identity system that enables secure credential chaining and complex anonymous identity verification across multiple issuers.

    \item A novel zero-knowledge building block that enables private proofs of VRF derivations from committed messages.
    
    \item  A complete system implementation using PS Signatures over commitments that achieves sybil resistance and revocation while enabling multi-issuer credential chaining - validated through concrete implementations, benchmarks, and formal security analysis.

\end{enumerate}

\subsection{Gap Analysis}

Digital identity is undergoing a fundamental transformation, evolving across three frontiers: decentralization, mandatory institutional adoption, and the emergence of attestation services.    
Identity systems are evolving from trusted, single-issuer models where a user authenticates with a single authority toward a decentralized paradigm where users publicly verify any multitude of credentials, manage multiple credentials for diverse issuers with their digital wallets.

\noindent As traditional organizations increasingly adopt decentralized identity capabilities and while it's also being mandated in the EU, they seek solutions that minimize changes to their existing infrastructure while enabling new DID capabilities and maintaining regulatory compliance. Beyond traditional organisations, a new frontier of credential issuance is emerging through automated attestation services like TLS Notary, Chainlink's DECO, Brave Browser's distefano, and Sui Labs zkLogin which enable verifiable data to become a credential. This transformation, while powerful, introduces challenges to identity systems run by governments and trusted organisations  who require sybil resistance protecation and revocation while maintaining privacy in a system where traditional infrastructure assumptions such as ease of revocation no longer hold.

\noindent \textbf{Core Challenges} Evolving from single-issuer to multi-issuer, multi-credential environments introduces several challenges. While existing solutions support private identity systems with anonymity, sybil resistance and revocation for single issuers. The introduction of multiple credentials and their sources transforms solved problems into new challenges. A decentralized system for the frontier of credentials must maintain anonymity across credential presentations, implement cross credential sybil resistance and efficient revocation checks without centralized trust.

\noindent Additionally, composing privacy-preserving primitives together to achieve the properties we require introduces complexity. While individual primitives for anonymous credentials, Sybil resistance, and revocation are well understood in isolation, the integration highlights the trilemma of accountable privacy systems - the tension between privacy, accountability, and functionality. The core challenge lies in designing efficient zero knowledge proof systems that combine these primitives in protocols that maintain the security and privacy properties of our system with practical efficiency.

\noindent Thirdly arises when users verify attributes from multiple credentials. Secure credential composition is required, while allowing flexible zero knowledge proof attribute attestations and selective disclosure. Lastly, users with multiple credentials require to privately prove their credentials are not revoked, introducing a scaling challenge - enabling efficient zero-knowledge batch proofs of non-membership while maintaining privacy and practical verification times. 




\subsection{Technical Challenges}

Building a privacy-preserving decentralized identity system requires balancing competing requirements: adhereing to strong security and privacy properties while retaining accountability measures and providing efficient verification of complex identity statements. While individual cryptographic primitives exist for many of these properties in isolation, combining them while maintaining security and efficiency introduces technical challenges, we identity three fundamental challenges below: 

\todonote{Rewrite this - start with rerand sigs over commitments, then extending that for multi-issuer, multi-cred, then using that for identity system}

\begin{enumerate}

    \item \textbf{Efficient Rerandomizable Signatures over Commitments} A key technical challenge was designing a signature scheme that efficiently supports both rerandomization and zero-knowledge proofs over-committed attributes. While existing schemes like BBS+, CL, and standard PS provide these properties, we use a customized PS signature with the lowest overhead in the randomization step. %what I want to say here is that after the randomization step, we are given a commitment in G1 which is easy and efficient to work with, rather than some other construction which needs custom proofs and new security proofs for each system built with it. 
    Unlike BBS+ and CL04, we maintain compatibility with standard Pedersen Commitments, enabling efficient proofs from standard techniques in the literature.
    

    \item \textbf{Sybil-Resistant Context Credential Construction} Designing an efficient mechanism to link context credentials to a master credential while preserving privacy, our solution uses a novel building block that combines a VRF with committed attributes - the user's Master Credential contains a commitment with their VRF key and generates a context credential nullifier with a VRF parameterized by the key and input the context string. 
    The complexity lies in efficiently proving in zero knowledge this nullifier was correctly derived from the committed key present in a valid, unrevoked master credential. This construction enables strong sybil resistance while maintaining unlinkability between presentations.


    \item \textbf{Efficient Multi-Credential Proofs and Revocation} enabling efficient proofs over multiple credentials while ensuring practical revocation. Our construction leverages Sigma protocols and Pedersen commitments, which, although they scale linearly with the credential attributes, they are extremely efficient in practice and support the most expressive statements. We integrate existing efficient revocation mechanisms that support batch non-membership proofs, allowing multiple credentials to be efficiently verified simultaneously while maintaining anonymity through zero-knowledge proof protocols. 

\end{enumerate}


\subsubsection{Comparison}


\begin{table}
\begin{center}
\caption{Comparison of our construction over previous work.}
\label{tab:comparison}
\begin{tabular}{l|cccccc}
Features    									& Multi Issuer & Sybil Resistance  & Revocation & Efficient Cred. Chaining$\footnotemark[1]$ & M-ABC$\footnotemark[2]$   & Anonymity$\footnotemark[3]$   \\
\hline

CanDID \cite{maram2021candid}     				& \ding{51}     & \ding{51} 	& \ding{51}  &  \ding{55}     & \ding{55}                     & \ding{55}		\\
SyRA \cite{crites_syra_2024}     				& \ding{55}     & \ding{51}    	& \ding{55}  &  \ding{55}     & \ding{55}                     & \ding{51}		\\
S3ID \cite{rabaninejad_attribute-based_nodate}  & \ding{51}     & \ding{51}    	& \ding{55}  &  \ding{51}     & \ding{55}\footnotemark[4]     & \ding{51}		\\
Our Work  										& \ding{51}     & \ding{51}    	& \ding{51}  &  \ding{51}     & \ding{51}                     & \ding{51}		\\
\end{tabular}
\end{center}

\vspace{1em}
\footnotesize
$\footnotemark[1]$ Credential Chaining is a user presenting multiple credentials to be verified together for a complex identity statement.

\footnotesize
$\footnotemark[2]$ M-ABC is a Multi-Show Attribute Based Credential, allowing a user to satisfy rich, attribute-based identity statements 

\footnotesize
$\footnotemark[3]$ Anonymity is defined in the Anonymous Credential model, no verifier and issuer (collaborating together) may learn more about the user or their credentials other than what the user discloses and what their credentials verify. Multiple credential verifications are unlinkable.

\footnotesize
$\footnotemark[4]$ While possible in S3ID, they mention 

\footnotesize
$\footnotemark[5]$ Multi-issuer means supporting credentials from different authorities that can be cryptographically linked while preserving privacy
\end{table}

\todonote{S3ID is inefficient for attribute-based verification, this table doesn't show that}







\section{Preliminaries}\label{sec:preliminaries}


\section{Rerandomizable Signatures on Commitments}\label{sec:sigs}
\subsection{Commitment}
\subsubsection{Syntax}
\begin{itemize}
    \item $CM.Setup(BG, \secparam, 1^n) \to ck$: Sample $g \sample \G_1, \tilg \sample \G_2$. Sample $\yb \sample \Z_p^{n}$ and compute $(\gb, \tilgb) \gets (g^{\yb}, \tilg^{\yb})$. Output $ck \gets (g, \gb, \tilg, \tilgb)$
    
    \item $CM.Com_{ck}(\mb, r) \to (\cm, \tilcm):$ Parse $ck$ as $(g, \gb, \tilg, \tilgb)$ and $\mb$ as $(m_1, \dots, m_{\ell})$, return $(\cm, \tilcm)$ as $(\gb^{\mb}g^r, \tilgb^{\mb}\tilg^r)$

    \item $CM.Rerand_{ck}((\cm, \tilcm), \rd) \to (\cm', \tilcm'):$ Parse $ck$ as $(g, \gb, \tilg, \tilgb)$. Compute $(g^{\rd}, \tilg^{\rd})$ and return $(\cm', \tilcm')$ as $(\cm \cdot g^{\rd}, \tilcm' \cdot \tilg^{\rd})$
\end{itemize}

\subsubsection{Construction}

\begin{itemize}
    \item $CM.Setup(\secparam, n) \to ck:$ The setup Algorithm generates the commitment key $ck$. Samples $(g, \tilg) \sample \G_1^* \times \G_2^*$ and $n$ scalars $y_i \gets \Z_p$, $Y_i \gets g^{y_i}$, and $\tily_i \gets \tilg^{y_i}$ $\forall \; 1 \leq i \leq n;$ such that $Y_i = g_1^{y_1}\dots g_n^{y_n}$ and $\tily_i = \tilg_1^{y_1}\dots \tilg_n^{y_n}$. Outputs $ck$ a tuple $(g, Y_i, \tilg, \tily_i)$ with commitment keys in both $\G_1$ and $\G_2$ where $e(Y_i,\tilg) = e(g,\tily_i)$

    \item $CM.Com_{ck}(\{m_i\}^n_{i=1}) \to (cm, \tilcm):$ to commit to $n$ messages $m_1, \dots, m_n$, the committer samples $r \sample \Zp$, and parses $ck$ as $(g, Y_i, \tilg, \tily_i)$ and commits to $\{m_i\}^n_{i=1}$ over dual commitments in $\G_1$ and $\G_2$. Computes $g^r, \tilg^r$, Commits to $\{m_i\}^n_{i=1}$ with respect to $ck$ such that $\cm \gets g_1^{m_1}\dots g_n^{m_n} g^r$ and $\tilcm \gets \tilg_1^{m_1} \dots \tilg_n^{m_n}\tilg^r$ Then outputs $(\cm, \tilcm)$ where the equality of commitments can be verified by pairing $e(\cm, \tilg) = e(g, \tilcm)$
    
    \item $CM.Rerand_{ck}((\cm, \tilcm), \rd) \to (\cm', \tilcm'):$ To rerandomize the commitment, the last element $g, \tilg$ is randomized with $\rd$. Compute $g^{\rd}, \tilg^{\rd}$, Compute $\cm'$ = $\cm \cdot g^{\rd}$ as $g_1^{m_1}\dots g_n^{m_n} g^r \cdot g^{\rd}$ which will equal $g_1^{m_1}\dots g_n^{m_n} g^{r + \rd}$ and equivalently for $\tilcm'$. Return the rerandomized commitments $(\cm', \tilcm')$
    
\end{itemize}

\subsubsection{Security}


\subsection{PS Signature}
\subsubsection{Syntax}
\begin{itemize}
    \item $PS.KeyGen(\secparam, \ck) \to (\sk, \vk):$ Parse $\ck$ as $ck \gets (g, \gb, \tilg, \tilgb)$. Sample $x \sample \Zp$, set $(\sk, \vk) \gets (g^x, \tilg^x)$

    \item $PS.Sign_{ck}(\sk, \cm) \to \sigma:$ Parse $\ck$ as $\gets (g, \cdot, \tilg, \cdot)$ Sample $u \sample \Zp$, compute $\sigma_1 \gets g^u$, $\sigma_2 \gets (\sk \cdot \cm)^u$
     and return $\sigma \gets (\sigma_1, \sigma_2)$

     \item $PS.Rerand(\sigma, \rd, \ud) \to \sigma': $ Parse $\sigma$ as $(\sigma_1, \sigma_2)$. Compute $\sigma_1' \gets \sigma_1^{\ud}$ and $\sigma_2' \gets (\sigma_2 \cdot \sigma_1^{\rd})^{\ud}$. Return $\sigma' \gets (\sigma_1', \sigma_2')$

     \item $PS.Verify_{ck, vk}(\sigma, (\cm, \tilcm)) \to \bit: $ Verify $ZKPoK.Open_{ck}(\cm)$. Parse $\ck$ as $(g, \cdot, \tilg, \cdot)$ and $\sigma$ as $(\sigma_1, \sigma_2)$. Assert $e(\cm, \tilg) = e(g, \tilcm)$ and $e(\sigma_2, \tilg) = e(\sigma_1, \vk \cdot \tilcm)$
     
\end{itemize}
\subsubsection{Construction}
\begin{itemize}
    \item $PS.KeyGen_{\ck}(\secparam) \to (\sk, \vk):$ The PS Signature KeyGen algorithm is parameterized by the corresponding commitment key $\ck$. The Signer retreives $(g, \cdot, \tilg, \cdot)$ from $\ck$, samples secret $x \sample \Zp$, sets $X \gets g^x$ and $\tilx \gets \tilg^x$, sets $\sk$ as $(g, X)$ and the public verification key $\vk$ as $(\ck, \tilx)$ and returns $(\sk, \vk)$

    \item $PS.Sign_{\sk}(\cm) \to \sigma: $ The signing algorithm signs the commitment. Retreives $(g, \cdot, \tilg, \cdot)$ from $\ck$, Samples $u \sample \Zp$, Computes $\sigma_1$ as $g^u$ and $\sigma_2 \gets (X \cdot \cm)^u$ both are notably in $\G_1$ and thus $(X \cdot \cm)^u$ = $(g_1^{m_1u}\dots g_n^{m_nu}g^{xu+ru})$. Returns $\sigma \gets (\sigma_1, \sigma_2)$    

    \item $PS.Rerand(\sigma, \rd, \ud) \to \sigma':$ Parse $\sigma$ as $(\sigma_1, \sigma_2)$. Compute $\sigma_1' \gets \sigma_1^{\ud}$ and $\sigma_2' \gets (\sigma_2 \cdot \sigma_1^{\rd})^{\ud}$. Return $\sigma' \gets (\sigma_1', \sigma_2')$

    \item $PS.Verify(\sigma, (\cm, \tilcm)) \to \bit:$ Verify $ZKPoK.Open_{ck}(\cm)$. Parse $\ck$ as $(g, \cdot, \tilg, \cdot)$ and $\sigma$ as $(\sigma_1, \sigma_2)$. Assert $e(\cm, \tilg) = e(g, \tilcm)$ and $e(\sigma_2, \tilg) = e(\sigma_1, \vk \cdot \tilcm)$

\end{itemize}

\subsubsection{Security}


\subsection{PS Signature over Commitment Construction}
\begin{itemize}
    \item $PS.Rerand_{ck,vk}(\sigma, \rd, \ud) \to \sigma'$: Rerandomization of the signature must preserve the algebraic properties of the commitment itself to allow the commitment to be used for zero knowledge proof protocols. To do so, the commitment is re-randomized with the random factor $\rd$ such that a commitment and signature pair 

\end{itemize}






\cleardoublepage
\section{Multi Issuer Multi Credential Anonymous Credentials (MIMC-ABC)}\label{sec:mimc}

We base our Multi Issuer, Multi Credential Multi-show Attribute based Anonymous Credentials off the model in \cite{fuchsbauer_structure-preserving_2019}


\subsection{Syntax}
\begin{itemize}
    \item $\mathsf{Setup}(\secparam) \to (\ppar)$ Takes security parameter $\lambda$ in unary, outputs public parameters $\ppar$.

    \item $\mathsf{OrgKeygen}(\ppar, n) \torand (\osk, \opk)$: is a probabilistic algorithm that takes public parameters $\ppar$ and $n$ the upper bound of credential attributes. Outputs organisations keypair $(\osk, \opk)$

    \item $\mathsf{UserKeygen}(\secparam) \torand (\usk)$ is a probabilistic algorithm. Outputs user secret key $\usk$ consisting of PRF key $k$ and identity string $s$

    \item $(\mathsf{Obtain Master}(usk_m, \textbf{m}, aux), \mathsf{IssueMaster}(osk_m, cm, aux)) \to Cred_m:$ An interactive protocol. $Obtain Master$ is a probabilistic algorithm run by a user, inputs secret key, credential attribute vector $\textbf{m}$, and auxiliary info. $Issue Master$ is a probabilistic algorithm run by an issuing organization that takes a commitment $cm$, issuer secret key $osk_m$, and auxiliary info. Outputs a master credential $Cred_m$ binding $cm$ to the issuer signature.
    
    \item $(\mathsf{Obtain Context}(usk_c, \textbf{m}, Cred_m, aux), \mathsf{Issue Context}(opk_m, Cred_m', osk_c, cm, aux)) \to Cred_c:$ An interactive protocol. $Obtain Context$ is a probabilistic algorithm run by a user, inputs master credential $Cred_m$ and corresponding organisation public key $opk_m$, the users new secret key $usk_c$, credential attribute vector $\textbf{m}$, and auxiliary info. $Issue Context$ is a probabilistic algorithm run by an issuing organization that takes a commitment $cm$, issuer secret key $osk_c$, and auxiliary info. Outputs a credential $Cred_c$ binding $cm$ to the issuer signature.

    \item $(\mathsf{Show}(\{usk_i, cred_i\}_{i=1}^n, \phi), \mathsf{Verify}(\{cred'_i, opk_i\}_{i=1}^n, \pi)) \to \bit$ An interactive protocol. $Show$ is a probabilistic algorithm run by a user. Takes $n$ secret keys, $n$ credentials, and predicate statement $\phi$. $Verify$ is a deterministic algorithm run by a verifier, takes $n$ randomized credentials $cred'$ and associated public keys $opk$ and proof $\pi$. Outputs 1 if verification succeeds, otherwise 0.

\end{itemize}


\subsection{Security Model}

We extend the security model from \cite{fuchsbauer_structure-preserving_2019} which considers malicious organization keys.
We extend it by supporting multiple organisations (issuers) for unforgeability and anonymity.
We add the Credential Binding property. 
 
\subsubsection{Security Properties}
Our Multi Issuer, Multi Credential Anonymous Credential system satisfies the following security and privacy properties:
\begin{enumerate}
    \item \textbf{Correctness: } For any honestly generated credentials and valid witness values, verification accepts if and only if (1) the credentials were legitimately issued by the credential issuer. (2) the credentials satisfy the verification predicate $\phi$. (3) all commitments are well-formed with respect to their corresponding signed credentials. 
    
    \item \textbf{Unforgeability}: No probabilistic polynomial time adversary can (1) forge valid credentials for honest users. (2) use credentials belonging to other users. (3) combine multiple credentials to create new ones. (4) replay a credential show from a different user. (5) present a valid multi-credential proof without controlling all constituent credentials. (6) Mix credentials from different users in a single proof.
    
    \item \textbf{Anonymity:} Given polynomial-time adversary views of credential verification, no adversary can (1) learn information beyond the public predicate $\phi$. (2) link multiple showings of the same credential. (3) For any set of credentials $\{Cred_1,\dots,Cred_n\}$ satisfying a predicate $\phi$, the adversary cannot distinguish whether they belong to the same or different users.

    \item \textbf{Credential Binding}: For any polynomial-time adversary $\Adv$, given a set of credentials $\{cred_1, \dots, cred_n \}$, producing a valid proof $\pi$ for a statement $\phi$ that links the credentials is negligible unless (1) all credentials were legitimately issued to the same user with master secret key $s$, (2) the user knows the opening of all credential commitments, (3) The proof $\pi$ must demonstrate consistency of $s$ across all credential combinations used

\end{enumerate}

\section{Model and Definitions}
We begin by presenting a model for privacy-preserving credential systems that supports multiple issuers and credential composition, extending the anonymous credential framework pioneered by \cite{hutchison_signature_2004}, extended in group signatures \cite{hutchison_foundations_2005} and modelled in an Attribute Based Anonymous Credential System \cite{fuchsbauer_structure-preserving_2019}.

\subsection{Global Variables}
At the beginning of each experiment, the following state is maintained:

\noindent \textbf{System Parameters:} For each issuer $i$, either the experiment computes an issuer keypair $(\mathsf{osk}_i, \mathsf{opk}_i)$ or the adversary outputs $\mathsf{opk}_i$. In the anonymity game, there is a challenge bit $b$, which the adversary must guess.

\noindent \textbf{User Management:} The system maintains:
\begin{itemize}
\item Sets $\mathsf{HU}$ and $\mathsf{CU}$ of honest and corrupted users
\item Lists $\mathsf{UPK}$, $\mathsf{USK}$ tracking user keypairs
\item Lists $\mathsf{CRED}$, $\mathsf{COM}$, $\mathsf{OWNR}$ recording credentials, their commitments, and ownership
\end{itemize}

\noindent \textbf{Challenge State:} For the anonymity game, sets $\mathcal{J}_{\mathsf{LoR}}$ and $\mathcal{I}_{\mathsf{LoR}}$ track credential tuples and corresponding users during challenge phases.

\noindent  Our model extends traditional ABC systems in two crucial ways:
\begin{enumerate}
    \item \textit{Multi-Issuer Support:} Users can obtain and compose credentials from different issuers while maintaining privacy across contexts
    \item \textit{Credential Composition:} Users can prove statements about multiple credentials while preserving unlinkability both within and across showings
\end{enumerate}

\noindent  \textbf{The Oracles.} The security properties are defined via experiments where an adversary $\mathcal{A}$ interacts with the following oracles:

\noindent $\mathcal{O}_{\mathsf{HU}}(i)$ - By calling this honest user oracle with identity $i \in \mathbb{N}$, $\mathcal{A}$ can add $i$ to the set $\mathsf{HU}$ of honest users. The oracle generates $(\mathsf{usk}[i], \mathsf{upk}[i]) \sample \mathsf{UserKeyGen}(\mathsf{opk})$, adds $i$ to $\mathsf{HU}$, and returns $\mathsf{upk}[i]$.

\noindent $\mathcal{O}_{\mathsf{CU}}(i, \mathsf{upk})$ - By calling this corrupt user oracle with identity $i$ and optional public key $\mathsf{upk}$, $\mathcal{A}$ can either register a new corrupt user (if $i \notin \mathsf{HU}$) or corrupt an honest user (if $i \in \mathsf{HU}$). In the latter case, $\mathcal{A}$ receives $\mathsf{usk}[i]$ and all credentials.

\noindent $\mathcal{O}_{\mathsf{ObtIss}}(i, \mathbf{attrs}, aux)$ - By calling this obtain-issue oracle with identity $i$, attribute vector $\mathbf{attrs}$, and auxiliary information $aux$, $\mathcal{A}$ initiates an honest credential issuance. If $i \notin \mathsf{HU}$, returns $\bot$. Otherwise, computes $(\mathsf{cm}, r) \sample \mathsf{Com}(\mathbf{attrs})$ and runs:
\[
(\mathsf{cred}, \top) \sample (\mathsf{Obtain}(\mathsf{usk}[i], \mathsf{opk}, \mathsf{cm}, r), \mathsf{Issue}(\mathsf{upk}[i], \mathsf{osk}, \mathsf{cm}))
\]
If $\mathsf{cred} = \bot$, returns $\bot$. Else appends $(i, \mathsf{cred}, \mathsf{cm})$ to $(\mathsf{OWNR}, \mathsf{CRED}, \mathsf{COM})$.

\noindent  $\mathcal{O}_{\mathsf{Obtain}}(i, \mathsf{cm})$ - Models a malicious issuer interacting with an honest user $i \in \mathsf{HU}$. Takes a commitment $\mathsf{cm}$ to attributes. If $i \notin \mathsf{HU}$, returns $\bot$. Runs:
\[
(\mathsf{cred}, \cdot) \sample (\mathsf{Obtain}(\mathsf{USK}[i], \mathsf{opk}, \mathsf{cm}), \cdot)
\]
where Issue is executed by $\mathcal{A}$. On success, appends $(i, \mathsf{cred}, \mathsf{cm})$ to $(\mathsf{OWNR}, \mathsf{CRED}, \mathsf{COM})$.

\noindent  $\mathcal{O}_{\mathsf{Issue}}(i, \mathsf{cm})$ - Models a malicious user interacting with an honest issuer. Takes identity $i$ and commitment $\mathsf{cm}$. If $i \notin \mathsf{CU}$, returns $\bot$. Runs:
\[
(\cdot, I) \sample (\cdot, \mathsf{Issue}(\mathsf{UPK}[i], \mathsf{osk}, \mathsf{cm}))
\]
where Obtain is executed by $\mathcal{A}$. If $I$ = $\bot$, it returns $\bot$. Else, it appends $(i, \bot, \mathsf{cm}$ to $(\mathsf{OWNR}, \mathsf{CRED}, \mathsf{COM})$ and returns $\bot$.

\noindent  $\mathcal{O}_{\mathsf{Show}}(\mathsf{cred}, \phi)$ - Models credential verification with malicious verifier. Takes credential $\mathsf{cred}$ and predicate $\phi$. Let $i \gets \mathsf{OWNR}[\mathsf{cred}]$. If $i \notin \mathsf{HU}$, returns $\bot$. Runs:
\[
(S, \cdot) \sample (\mathsf{Show}(\mathsf{opk}, \phi, \mathsf{cred}), \cdot)
\]
where Verify is executed by $\mathcal{A}$.

\noindent $\mathcal{O}_{\mathsf{LoR}}(\mathsf{Creds}_0, \mathsf{Creds}_1, \phi)$ - By calling this challenge oracle, $\mathcal{A}$ attempts to distinguish between two credential sets in an anonymous showing. Each $\mathsf{Creds}_b = (\mathsf{cred}_{b,1},\ldots,\mathsf{cred}_{b,n})$ represents a tuple of credentials, where each credential contains a commitment to its attributes. The oracle enforces that credentials within each tuple belong to the same user (binding) while maintaining unlinkability across showings. The predicate $\phi: \mathsf{COM}^n \rightarrow \{0,1\}$ validates statements over committed attributes. If $\mathcal{J}_{\mathsf{LoR}} \neq \emptyset$ and $\mathcal{J}_{\mathsf{LoR}} \neq \{\mathsf{Creds}_0, \mathsf{Creds}_1\}$, returns $\bot$. Otherwise, verifies single ownership and honest user conditions, then executes:
$(S, \cdot) \sample (\mathsf{Show}(\mathsf{opk}, \phi, \mathsf{Creds}_b), \cdot)$

\begin{definition}[MIMC-ABC Correctness]
A Multi-Issuer Multi-Credential Anonymous Credential system (MIMC-ABC) is correct if for all security parameters $\lambda > 0$, the following properties hold for all honestly generated credentials where attributes are committed using commitment scheme $\mathsf{Com}$

\begin{enumerate}
    \item Individual Validity: For each credential $cred_i $with commitment $cm_i$ = $Com(attrs_i; r_i)$, the credential verifies independently under its issuer's public key $opk_i$

    \item Multi-Issuer Composition: For any set of credentials ${cred_1,...,cred_n}$ with corresponding commitments ${cm_1,...,cm_n} $belonging to the same user, any valid predicate $\phi$ over their committed attributes verifies successfully

    \item Commitment Binding: The showing protocol preserves the binding between credentials and their committed attributes while maintaining zero-knowledge
\end{enumerate}

\noindent More formally:
\[
        \Pr
            \left [
            \begin{array}{l}
                (osk_i, opk_i) \sample OrgKeyGen(\secparam \text{ for } i \in [n]),\\
                (usk, upk) \sample UserKeyGen(opk),\\
                (cm_i, r_i) \sample Com(\mathbf{attrs}_i) \text{ for } i \in [n],\\
                (\mathsf{cred}_i, \top) \sample (Obtain(usk, opk_i, cm_i),\\
                \quad Issue(upk, osk_i, cm_i)) \text{ for } i \in [n],\\
            \end{array}
                : 
                \begin{array}{l}
                    (\top, 1) \sample (Show(opk, \phi, \{\mathsf{cred}_i\}_{i \in [n]}),\\
                    \quad Verify(opk, \phi))
                \end{array}
                \right ]
             = 1
\]
\end{definition}


\newpage
\begin{definition}[MIMC-ABC Unforgeability]
A Multi-Issuer Multi-Credential Anonymous Credential system provides unforgeability if no probabilistic polynomial-time adversary $\mathcal{A}$ can:
\begin{enumerate}
    \item forge valid credentials for honest users
    \item use credentials belonging to other users
    \item combine multiple credentials to create new ones
    \item replay a credential showing from a different user
\end{enumerate}

\noindent More formally, for any PPT adversary $\mathcal{A}$, the following probability is negligible in $\lambda$:
\[ \Pr[\mathsf{Exp}^{\mathsf{unf}}_{\mathsf{MIMC\mbox{-}ABC},\mathcal{A}}(1^\lambda) = 1] \leq \mathsf{negl}(\lambda) \]
\end{definition}

\begin{definition}[MIMC-ABC Unforgeability]
The experiment $\mathsf{Exp}^{\mathsf{unf}}_{\mathsf{MIMC\mbox{-}ABC},\mathcal{A}}(1^\lambda)$ proceeds as follows:

\begin{enumerate}
    \item Setup Phase:
    \begin{itemize}
        \item For each issuer $i \in [n]$: $(osk_i, opk_i) \sample \mathsf{OrgKeyGen}(1^\lambda)$
        \item Initialize $\mathsf{HU, CU} \gets \emptyset$
        \item Initialize $\mathsf{CRED, COM, OWNR} \gets \emptyset$
    \end{itemize}

    \item Query Phase: $\mathcal{A}^{\mathcal{O}}(1^\lambda, \{opk_i\}_{i \in [n]})$ where $\mathcal{O}$ includes:
    \begin{itemize}
        \item $\mathcal{O}_{\mathsf{HU}}, \mathcal{O}_{\mathsf{CU}}$ (user management)
        \item $\mathcal{O}_{\mathsf{ObtIss}}, \mathcal{O}_{\mathsf{Obtain}}, \mathcal{O}_{\mathsf{Issue}}$ (credential operations)
        \item $\mathcal{O}_{\mathsf{Show}}$ (showing protocol)
    \end{itemize}

    \item Forgery Phase: $\mathcal{A}$ outputs $(\{\mathsf{cred}_i\}_{i \in [k]}, \phi, \pi)$

    \item The experiment returns 1 if:
    \begin{itemize}
        \item $\mathsf{Verify}(opk, \phi, \{\mathsf{cred}_i\}_{i \in [k]}, \pi) = 1$ and
        \item At least one of the following holds:
            \begin{enumerate}
                \item $\exists i: \mathsf{cred}_i \notin \mathsf{CRED}$ (credential forgery)
                \item $\exists i,j: \mathsf{OWNR}(\mathsf{cred}_i) \neq \mathsf{OWNR}(\mathsf{cred}_j)$ (mixed ownership)
                \item $\mathsf{OWNR}(\mathsf{cred}_1) \in \mathsf{HU}$ (honest user credential misuse)
            \end{enumerate}
    \end{itemize}
\end{enumerate}
\end{definition}


\newpage
\begin{definition}[MIMC-ABC Anonymity]
A Multi-Issuer Multi-Credential Anonymous Credential system provides anonymity if no probabilistic polynomial-time adversary $\mathcal{A}$ can:

\begin{enumerate}
    \item learn any information beyond the public information
    \item link multiple showings of the same credential
    \item correlate different credentials belonging to the same user
    \item identify which credentials were issued by the same issuer
\end{enumerate}

More formally, for any PPT adversary $\mathcal{A}$, the following advantage is negligible in $\lambda$:
\[ \mathsf{Adv}^{\mathsf{anon}}_{\mathsf{MIMC\mbox{-}ABC},\mathcal{A}}(\lambda) := |\Pr[\mathsf{Exp}^{\mathsf{anon\mbox{-}1}}_{\mathsf{MIMC\mbox{-}ABC},\mathcal{A}}(1^\lambda) = 1] - \Pr[\mathsf{Exp}^{\mathsf{anon\mbox{-}0}}_{\mathsf{MIMC\mbox{-}ABC},\mathcal{A}}(1^\lambda) = 1]| \leq \mathsf{negl}(\lambda) \]
\end{definition}


\noindent \textbf{MIMC-ABC Anonymity Experiment.} 
The experiment $\mathsf{Exp}^{\mathsf{anon\mbox{-}b}}_{\mathsf{MIMC\mbox{-}ABC},\mathcal{A}}(1^\lambda)$ proceeds as follows:

\begin{enumerate}
    \item Setup Phase:
    \begin{itemize}
        \item For each issuer $i \in [n]$: $(osk_i, opk_i) \sample \mathsf{OrgKeyGen}(1^\lambda)$
        \item Initialize $\mathsf{HU, CU} \gets \emptyset$
        \item Initialize $\mathsf{CRED, COM, OWNR} \gets \emptyset$
        \item Initialize $\mathcal{J}_{\mathsf{LoR}}, \mathcal{I}_{\mathsf{LoR}} \gets \emptyset$
        \item Sample challenge bit $b \sample \{0,1\}$
    \end{itemize}

    \item Query Phase: $\mathcal{A}^{\mathcal{O}}(1^\lambda, \{opk_i\}_{i \in [n]})$ where $\mathcal{O}$ includes:
    \begin{itemize}
        \item $\mathcal{O}_{\mathsf{HU}}, \mathcal{O}_{\mathsf{CU}}$ (user management)
        \item $\mathcal{O}_{\mathsf{ObtIss}}, \mathcal{O}_{\mathsf{Obtain}}, \mathcal{O}_{\mathsf{Issue}}$ (credential operations)
        \item $\mathcal{O}_{\mathsf{Show}}$ (showing protocol)
        \item $\mathcal{O}_{\mathsf{LoR}}$ (challenge oracle)
    \end{itemize}

    \item Challenge Phase: 
    $\mathcal{A}$ can query $\mathcal{O}_{\mathsf{LoR}}(\mathsf{Creds}_0, \mathsf{Creds}_1, \phi)$ where:
    \begin{itemize}
        \item $\mathsf{Creds}_b = (\mathsf{cred}_{b,1},...,\mathsf{cred}_{b,n})$ for $b \in \{0,1\}$
        \item Credentials in each tuple must belong to the same user
        \item Both credential sets must satisfy predicate $\phi$
    \end{itemize}

    \item $\mathcal{A}$ outputs a guess $b' \in \{0,1\}$

    \item The experiment returns 1 if $b = b'$
\end{enumerate}











\newpage
\noindent \textbf{Credential Binding.} For any PPT adversary $\mathcal{A}$, given a set of credentials $\{\mathsf{cred}_1,...,\mathsf{cred}_n\}$, the probability of producing a valid proof $\pi$ for statement $\phi$ is negligible unless:

\begin{enumerate}
    \item all credentials were legitimately issued to the same user with master secret key $s$
    \item the user knows the opening of all credential commitments
    \item the linking proof demonstrates the same $s$ value across all credentials
\end{enumerate}

More formally, for any PPT adversary $\mathcal{A}$, we define the experiment $\mathsf{Exp}^{\mathsf{bind}}_{\mathsf{MIMC\mbox{-}ABC},\mathcal{A}}(1^\lambda)$ as follows:

The challenger generates $(osk_i, opk_i) \sample \mathsf{OrgKeyGen}(1^\lambda)$ for each issuer $i \in [n]$. Sets $\mathsf{HU, CU} \gets \emptyset$, $\mathsf{CRED, COM, OWNR} \gets \emptyset$. 

$\mathcal{A}$ receives $\{opk_i\}_{i \in [n]}$ and access to oracles $\mathcal{O}_{\mathsf{HU}}$, $\mathcal{O}_{\mathsf{CU}}$, $\mathcal{O}_{\mathsf{ObtIss}}$, $\mathcal{O}_{\mathsf{Obtain}}$, $\mathcal{O}_{\mathsf{Issue}}$, and $\mathcal{O}_{\mathsf{Show}}$.

Finally, $\mathcal{A}$ outputs $(\{\mathsf{cred}_i\}_{i \in [n]}, \phi, \pi)$. The experiment returns 1 if:
\begin{itemize}
    \item $\mathsf{Verify}(opk, \phi, \{\mathsf{cred}_i\}_{i \in [n]}, \pi) = 1$ and
    \item $\exists i,j: \mathsf{OWNR}(\mathsf{cred}_i) \neq \mathsf{OWNR}(\mathsf{cred}_j)$ or
    \item $\exists i: \mathsf{cred}_i \notin \mathsf{CRED}$
\end{itemize}

The advantage of $\mathcal{A}$ is defined as:
\[ \mathsf{Adv}^{\mathsf{bind}}_{\mathsf{MIMC\mbox{-}ABC},\mathcal{A}}(\lambda) := \Pr[\mathsf{Exp}^{\mathsf{bind}}_{\mathsf{MIMC\mbox{-}ABC},\mathcal{A}}(1^\lambda) = 1] \leq \mathsf{negl}(\lambda) \]




\newpage
\subsection{Intuition of our Construction}
\subsubsection{Example}
\subsubsection{Outline}
\subsubsection{Freshness}
\subsubsection{Malicious Organization Keys}
\subsubsection{ZKPoKs and Concurrent Security}





\newpage
\subsection{Master Credential Issuance}
The master credential issuance protocol enables a user to obtain their root credential from the Master Credential Oracle $\MCO$ while preserving the privacy of their VRF key $k$ and ensuring accountability. The protocol combines verifiable encryption, Verifiable Random Function, Zero Knowledge Proofs, and Rerandomizable PS Signatures over commitments to achieve Sybil Resistance, Revocation, and Anonymity.

\begin{center}
\begin{tabular}{l@{\hspace{12em}}c@{\hspace{12em}}l}
\multicolumn{3}{l}{$\underline{Setup(1^{\lambda}, 1^n)}$:} \\[0.5em]
\multicolumn{3}{l}{System: $(\G_1, \G_2, e, g, \tilg ) \gets BG.Gen(\secparam, p), \; ck_m \gets CM.Setup(BG, \secparam, n)$} \\[1em]
\multicolumn{3}{l}{Credential Oracle: $(SK_m, PK_m) \gets PS.KeyGen(ck_m)$} \\[1em]
\multicolumn{3}{l}{Auditor: $(SK_A, PK_A) \gets TPKE.KeyGen(ck_m)$} \\[1em]
\multicolumn{3}{l}{Auditor setup Revocation List} \\[1em]
\underline{User($s$)} && \underline{MCO($SK_M$)} \\[0.5em]
\multicolumn{3}{l}{$k_1 \gets \Z_p$, \; $C_1 \gets Com([0,k_1,0,0],r)$}\\[1em]
\multicolumn{3}{l}{$\Pi_1 \gets ZKPoK.Prove_{Zeros}(C_1)(k_1, r)$} \\[1em]
& $\xrightarrow{C_1, \Pi_1}$ & \\[1em]
\multicolumn{3}{r}{If $ZKPoK.Verify_{Zeros}(\Pi_1, C_1) = 0, $ return $ \bot$} \\[1em]
\multicolumn{3}{r}{$k_2 \gets \Z_p, \; C_2 \gets Com([s, k_2, "master", attrs], 0)$} \\[1em]
\multicolumn{3}{r}{$C_m \gets C_1 \cdot C_2 = Com([s,k_1+k_2,"master", attrs], r)$} \\[1em]
& $\xleftarrow{C_2, C_m, s, k_2}$ & \\[1em]
\multicolumn{3}{l}{$k \gets k_1 + k_2$} \\[1em]
\multicolumn{3}{l}{$\Pi_2 \gets ZKPoK.Prove_{addition}(C_1, C_2, C_m)(k_1, k_2, k, r)$} \\[1em]
\multicolumn{3}{l}{$\tau \gets Enc(PK_A, k)$} \\[1em]
\multicolumn{3}{l}{$\Pi_3 \gets ZKPOK.Prove_{enc}(C_m)(\tau, k, r)$} \\[1em]
& $\xrightarrow{C_1, C_2, C_m, \Pi_2, \Pi_3, \tau}$ &\\[1em]
\multicolumn{3}{r}{If $ZKPOK.Verify_{addition}(\Pi_2, C_1, C_2, C_m) = 0, \;$ return $\bot$} \\[0.5em]
\multicolumn{3}{r}{If $ZKPOK.Verify_{enc}(C_m)(\Pi_3, PK_A, \tau)  = 0, \;$ return $\bot$} \\[0.5em]
\multicolumn{3}{r}{$\sigma_m \gets PS.Sign(SK_M, C_1)$} \\[0.5em]
\multicolumn{3}{r}{Store Data Record MCO $(C_m, \sigma_m, \tau, \Pi_2, \Pi_3, C_1, C_2, k_2)$ } \\[1em]
& $\xleftarrow{\sigma_m}$ & \\[1em]
\multicolumn{3}{l}{If $PS.Verify(PK_A, \sigma_m, C_m) = 1$, Store $Cred_m(\sigma_m, C_m)$} \\[1em]
\end{tabular}
\end{center}

\paragraph{Informal Security Analysis}

The two-party process between the user and master credential oracle ensures sybil resistance of unique identifier $s$; the oracle has access to the user information and checks duplicate issuance within their own identity system. 
During VRF key issuance, the anonymity of the master credential is preserved via the secrecy of the VRF key $k$. During the two-party computation, the user's share $k_1$ remains hidden to $\MCO$ via the hiding property of the commitment $C_1$, and malicious commitment usage is prevented by the soundness property of $\Pi_1$. 

\noindent The user combines  $k_1 + k_2$ to form their VRF key, $\Pi_2$ proves $k_1$ is correctly derived from $C_1$, $k_2$ is derived from $C_2$ and $k$ combines $k_1 + k_2$, $\MCO$'s input to $k$ prevents forgery attempts on the key $k$. The hiding property of the commitments and zero-knowledge property of the proofs ensures correct protocol adherence while maintaining private computation. Revocation is enabled by encryption of the VRF key $k$ with the public key of the Auditor $PK_A$. $\Pi_3$ proves that $\tau$ is an encryption of the committed key $k$. $\tau$ is stored with the credential oracle maintaining privacy during normal operation. Finally, the protocol prevents replay attacks by using interactive zero-knowledge proofs requiring a challenge from the verifier, fresh commitment randomness, and $\MCO$'s input of their share of the VRF key $k_2$ preventing existing transcript reuse.



\newpage
\subsection{Create Context Credential}
Context Credential Issuance enables a user to obtain a context-specific credential while proving ownership of a valid master credential. The user first constructs a commitment to their context credential attributes, including their identity $s$ and a deterministic nullifier derived from their VRF key $k$ and the credential context $ctx$. Through zero-knowledge proofs, the user demonstrates their master credential is valid and unrevoked, and proves the context commitment is well-formed with the same identity $s$. The nullifier $\tau$ = $VRF(k,ctx)$ prevents multiple credentials for the same context while maintaining privacy. Upon successful verification, the Context Credential Oracle signs the commitment and records the nullifier.

\begin{center}
\begin{tabular}{l@{\hspace{12em}}c@{\hspace{12em}}l}
\multicolumn{3}{l}{$\underline{Setup(1^{\lambda}, 1^n)}$:} \\[0.5em]
\multicolumn{3}{l}{System: $(\G_1, \G_2, e, g, \tilg ) \gets BG.Gen(\secparam, p), \; ck_c \gets CM.Setup(BG, \secparam, n)$} \\[1em]
\multicolumn{3}{l}{Credential Oracle: $(SK_c, PK_c) \gets PS.KeyGen(ck_c)$} \\[1em]
\underline{User($Cred_m, s, k$)} && \underline{CCO($SK_c$)} \\[0.5em]
\multicolumn{3}{l}{$\delta \gets VRF(k, ctx)$} \\[1em]
\multicolumn{3}{l}{$r* \sample Z_p, \; C_c \gets Com([s,\delta,ctx,attrs],r*)$} \\[1em]
\multicolumn{3}{l}{$\Pi_4 \gets ZKPoK.Prove_{selective-disclosure}(C_c,\delta,ctx,attrs)(s, r*)$} \\[1em]
\multicolumn{3}{l}{$r' \sample \Z_p, Cred_{m}' \gets Cred.Rerand(Cred_{m}, r')$} \\[1em]
\multicolumn{3}{l}{$\Pi_5 \gets ZKSoK.Prove(Cred_m')(s,k,master,attrs,r')$} \\[1em]
\multicolumn{3}{l}{Parse $Cred_m'$ as $C_m', \sigma_m'$} \\[1em]
\multicolumn{3}{l}{$\Pi_6 \gets ZKPoK.Prove_{reciprocal}(C_m', C_c,ctx)(s,k,r',r*)$}  \\[1em]
\multicolumn{3}{l}{$\Pi_7 \gets ZKPoK.Prove_{equality}(C_m', C_c)(s, r)$} \\[1em]
& $\xrightarrow{Cred_m', C_c, \Pi_4, \Pi_5, \Pi_6, \Pi_7}$ & \\[1em]
\multicolumn{3}{r}{If} \\[1em]
\multicolumn{3}{r}{$ZKPok.Verify_{selective-disclosure}(\Pi_4, C_c)(\delta, ctx, attrs)$ = 1 $\; \wedge$} \\[1em]
\multicolumn{3}{r}{$ZKSoK.Verify(\Pi_5, Cred_m')$ = 1 $\; \wedge$} \\[1em]
\multicolumn{3}{r}{$ZKPoK.Verify_{reciprocal}(\Pi_6, C_m', C_c, ctx)$ = 1 $\; \wedge$} \\[1em]
\multicolumn{3}{r}{$ZKPoK.Verify_{equality}(\Pi_7, C_m', C_c)$ = 1 $\; \wedge$} \\[1em]
\multicolumn{3}{r}{$\sigma_c \gets PS.Sign(SK_c, C_c)$} \\[1em]
\multicolumn{3}{r}{Store Data Record CCO $(C_c, \sigma_c, \delta, \Pi_4, \Pi_5, \Pi_6, \Pi_7 )$} \\[1em]
& $\xleftarrow{\sigma_c}$& \\[1em]
\multicolumn{3}{l}{If $PS.Verify(PK_c,\sigma_c, C_c) = 1$, Store $Cred_c(\sigma_c, C_c)$} \\[1em]
\end{tabular}
\end{center}


\subsubsection{Informal Security Analysis}
Sybil Resistance: The deterministic nullifier $\delta \gets VRF(k,ctx)$ binds each context credential to a unique (user, context) pair, preventing multiple credentials for the same context. The reciprocal proof $\Pi_6$ ensures correct nullifier derivation from the master key $k$. 
Credential Binding: Context Credentials are bound to master credentials through shared identity $s$ and $\Pi_7$. The selective disclosure proof $\Pi_4$ ensures correct commitment structure without revealing private values. 
Privacy: The protocol only reveals $ctx$ and $attrs$ to CCO to allow identity verification while hiding $s$. The Master Credential $Cred_m$ remains unlinkable by being  rerandomized and proven in zero knowledge it verifies with the Master Credential Oracles public key.






\subsubsection{Verification}
A user $user$ wants to prove to any relying party $rely$ they have a valid credential that satisfies a verification statement $\phi$.
The protocol takes as input $(rcd, ccd, \phi, rpk, acc, n)$ and outputs success or failure.
$rely$ starts by sending $(\phi, n, acc)$ to $user$ where $\phi$ is a statement that specifies the requirements for a successful verification and $acc$ is the current accumulator value of revoked nullifiers.
$user$ starts by randomizing their credentials $rcd' = psrerand(rcd)$ and $ccd' = psrerand(ccd)$ and verifies $psverify_{ck_{rcd}}(rcd')$ and $psverify_{ck_{ccd}}(ccd')$. $user$ generate their nullifiers $nullif_{pid} \gets PRF_s(pid)$ and $nullif_{ctx} \gets PRF_s(ctxid)$ and obtains non-membership witnesses $wpid$, $wctx$ for nullifiers against $acc$.
$user$ generates a zero-knowledge proof $\pi$ showing 1) their credentials are valid, 2) they're not expired $(expiry > current_time)$, 3) their nullifiers are correctly formed from $s$, 4) their nullifiers are not in $acc$ using witnesses $wpid, wctx$, 5) the credential attributes satisfy $\phi$, 6) proof freshness using $n$.
$user$ sends $(\pi, attrs_{\phi})$ to $rely$, $rely$ verifies $\pi$ against $acc$ and validates $attrs_{\phi}$ satisfies $\phi$. Returns accept if all checks pass, reject otherwise.



\subsection{Security Experiments}





\newpage






\section{Construction of $\Sigma$-protocols}\label{sec:sigmaproofs}
% Recall definitions and introduction here: https://infoscience.epfl.ch/server/api/core/bitstreams/fc1cfb22-d943-4c96-a942-d715b76e6cc4/content#page=6.31


Preliminaries: Let $\G$ be a cyclic group of prime order $q$ with generators $g, g_1, \dots, g_n$

\begin{enumerate}
    \item Completeness: an honest prover who knows the opening will always convince the verifier.
    
    \item Special Soundness: Show that given two accepting transcripts $(T, c, \{s\}_{i=1}^n, u)$ and $(T, c', \{s'\}_{i=1}^n, u')$ for $c \neq c'$ we can extract a valid witness.
    
    \item Honest Verifier Zero Knowledge: construct a simulator that given a challenge $c$, produces transcripts indistinguishable from real protocol runs.
\end{enumerate}










\newpage

\begin{construction}{ZKPoK for Pedersen Commitment Opening}{openproof}
    \vspace{1em}
    \textbf{Public parameters:}  $g_1, \dots, g_n, h \in \G$

    \textbf{Inputs:} $\cm$ such that $\cm = \prod_{i=1}^ng_i^{m_i}h^r$, \;    $\Prover$ knows $\{m\}_{i=1}^n, r \in \Z_q^{n+1}$.

    \vspace{1em}

    \begin{enumerate}
        \item $\Prover$ samples $\alpha_i \sample \Z_p$ for $i \in [1,n]$, $\rho \sample \Z_p$, computes $T \gets (\prod_{i=1}^ng_i^{\alpha_i})\cdot h^{\rho}$, sends $T$ to $\Verifier$
        
        \item $\Verifier$ sends challenge $c \sample \Z_p$
    
        \item $\Prover$ computes responses $s_i \gets \alpha_i + cm_i$ for $i \in [1,n]$, and $u \gets \rho + cr$. Sends $\{s_i\}_{i=1}^n$ and $u$ to $\Verifier$
    
        \item $\Verifier$ verifies that $ (\prod_{i=1}^ng_i^{s_i})\cdot h^u = \cm^cT$
    \end{enumerate}
\end{construction}

\begin{theorem}[Perfect Completeness]
    Construction \ref{construct:openproof} is a $\Sigma-$protocol for the relation $\mathcal{R}$
    \[
        \mathcal{R} = \left\{ (\cm,g_1,\dots,g_n,h),(m_1,\dots,m_n,r) \; | \; \cm = \prod_{i=1}^ng_i^{m_i}h^r \right\}
    \]
    with perfect completeness: 
\end{theorem}


\begin{proof}
    We prove completeness by showing that for any valid inputs and witnesses, when both $\Prover$ and $\Verifier$ follow the protocol, $\Verifier$ accepts with $\Pr$ = 1.
    Consider an execution of the protocol where:
    \begin{enumerate}
        \item $\Prover$ samples $\alpha_i \sample \Z_p$ for $i \in [1,n]$, $\rho \sample \Z_p$ and sends $T \gets (\prod_{i=1}^n g_i^{\alpha_i})h^{\rho}$
        \item $\Verifier$ sends challenge $c \sample \Z_p$
        \item $\Prover$ responds with $s_i \gets \alpha_i + cm_i$ for $i \in [1,n]$, $u \gets \rho + cr$
    \end{enumerate}
    Verification holds by 
    \begin{align}
        (\prod_{i=1}^n g_i^{s_i})h^u &\stackrel{?}{=} \cm^cT \notag \\
        (\prod_{i=1}^n g_i^{\alpha_i + cm_i})h^{\rho + cr} &\stackrel{?}{=} (\prod_{i=1}^n g_i^{m_i}h^r)^c(\prod_{i=1}^n g_i^{\alpha_i})h^{\rho} \notag  \\
        (\prod_{i=1}^n g_i^{\alpha_i + cm_i})h^{\rho + cr} &= (\prod_{i=1}^n g_i^{cm_i + \alpha_i})h^{cr + \rho} \notag 
    \end{align}
    Thus, an honest verifier always accepts an honest prover's proof.
\end{proof}




\begin{theorem}[Special Soundness]
    Construction 1 satisfies the special soundness of relation $\mathcal{R}$. 
\end{theorem}
\begin{proof}
    Let $Tr_1 = (T, c, \{s_i\}_{i=1}^n, u)$ and $Tr_2 = (T, c', \{s'_i\}_{i=1}^n, u')$ be two accepting transcripts for the same initial commitment $T$ where $c \neq c'$. We construct a knowledge extractor $\Extractor$ that extracts the witness $w = (\{m_i\}_{i=1}^n,r)$ as follows:
    \begin{enumerate}
        \item Since both transcripts are accepting, they satisfy: 
        $(\prod_{i=1}^n g_i^{s_i})h^u = \cm^cT$ and $(\prod_{i=1}^n g_i^{s'_i})h^{u'} = \cm^{c'}T$
        
        \item Evaluate as a system of linear equations:
             \begin{align}
               \frac{(\prod_{i=1}^n g_i^{s_i})h^u}{(\prod_{i=1}^n g_i^{s'_i})h^{u'}} &= \frac{\cm^c}{\cm^{c'}} \notag \\
               (\prod_{i=1}^n g_i^{s_i-s'_i})h^{u-u'} &= (\prod_{i=1}^n g_i^{m_i(c-c')})h^{r(c-c')} \notag
            \end{align}
            
       \item By the homomorphic property of the exponents and the uniqueness of discrete logarithm representations, we obtain the system of equations:
       \[
       s_i-s'_i = m_i(c-c') \text{ for } i \in [1,n] \qquad u-u' = r(c-c')
       \] 
       therefore $\Extractor$ extracts: 
       \[
       m_i = \frac{s_i-s'_i}{c-c'} \text{ for } i \in [1,n] \qquad r = \frac{u-u'}{c-c'}
       \]
       Which satisfies the commitment construction $\cm = (\prod_{i=1}^n g_i^{m_i})h^r$
    \end{enumerate}
    This shows that if $\Prover$ can respond correctly to 2 different challenges for the commitment $T$, they must "know" all messages $\{m_i\}_{i=1}^n$ and the randomness $r$.
\end{proof}



\begin{remark}
    The special soundness property of our protocol relies on the same discrete logarithm assumption as the binding property of Pedersen commitments. Specifically, if an adversary could find two different openings $(\{m_i\}_{i=1}^n, r) \neq (\{m'_i\}_{i=1}^n, r')$ for the same commitment $\cm$, they could use these to compute discrete logarithms between the generators $(g_1,\ldots,g_n,h)$. Our extractor demonstrates that producing two valid transcripts for different challenges is equivalent to breaking this binding property.
\end{remark}



\begin{theorem}[Honest-Verifier Zero-Knowledge]
    Construction 1 is honest-verifier zero-knowledge.
\end{theorem}
\begin{proof}
    We construct a simulator $\Simulator$ that, given only public input $\cm$ and a challenge $c$, produces transcripts that are identically distributed to those of real protocol executions. $\Simulator$ works as follows:
    \begin{enumerate}
        \item On input $(\cm, c)$, $\Simulator$ samples:
            \begin{itemize}
                \item $s_i \sample \Z_p$ for $i \in [1,n]$
                \item $u \sample \Z_p$
            \end{itemize}
            
        \item Computes $T \gets (\prod_{i=1}^n g_i^{s_i})h^u\cm^{-c}$
        
        \item Outputs transcript $(T, c, \{s_i\}_{i=1}^n, u)$
    \end{enumerate}

    To show perfect HVZK, we prove the distribution of simulated transcripts is identical to real transcripts:
    \begin{itemize}
        \item In real protocol: 
            \begin{itemize}
                \item $s_i = \alpha_i + cm_i$ where $\alpha_i \sample \Z_p$
                \item $u = \rho + cr$ where $\rho \sample \Z_p$
            \end{itemize}
        \item Since $\alpha_i, \rho$ are uniform in $\Z_p$, the real $s_i, u$ are uniformly distributed in $\Z_p$
        \item In simulation, $s_i, u$ are sampled uniformly from $\Z_p$
        \item Therefore, $(s_i, u)$ have identical distributions in both cases
        \item Given fixed $(s_i, u)$, $T$ is uniquely determined by the verification equation in both real and simulated transcripts
    \end{itemize}
    Thus, the simulated transcripts are perfectly indistinguishable from real protocol transcripts.
\end{proof}


\begin{corollary}[Proof of Zero Values]
    Let $I \subseteq [1,n]$ be a set of indices. Given a commitment $\cm$ and commitment key $\ck$, we construct modified public parameters $\ck'$ by removing the generators $g_i$ for all $i \in I$ from $\ck$. Using $\ck'$ with Construction 1 proves that $m_i = 0$ for all $i \in I$ while maintaining the properties of a $\Sigma$-protocol.
\end{corollary}

\begin{proof}
    Consider commitment $\cm = (\prod_{i=1}^n g_i^{m_i})h^r$. When proving with modified generators, the prover must demonstrate knowledge of opening $(\{m_i\}_{i \notin I}, r)$ such that:
    \[
    \cm = (\prod_{i \notin I} g_i^{m_i})h^r
    \]
    
    If this equation holds and $\cm$ was constructed using all generators, then necessarily $m_i = 0$ for all $i \in I$, as otherwise the verification would fail.

    We now show the protocol maintains all properties of a $\Sigma$-protocol:

    Completeness: For any valid commitment $\cm$ where $m_i = 0$ for all $i \in I$, the protocol succeeds with probability 1. The prover samples $\alpha_i \sample \Z_p$ for $i \notin I$ and $\rho \sample \Z_p$, computes $T = (\prod_{i \notin I} g_i^{\alpha_i})h^{\rho}$, and responds to challenge $c$ with $s_i = \alpha_i + cm_i$ for $i \notin I$ and $u = \rho + cr$. Verification holds because:
    \[
    (\prod_{i \notin I} g_i^{s_i})h^u = (\prod_{i \notin I} g_i^{\alpha_i + cm_i})h^{\rho + cr} = \cm^c \cdot T
    \]

    Special Soundness: Given two accepting transcripts $(T, c, \{s_i\}_{i \notin I}, u)$ and $(T, c', \{s'_i\}_{i \notin I}, u')$ with $c \neq c'$, the extractor from Theorem 1 works on the reduced generator set to extract valid openings $m_i = \frac{s_i-s'_i}{c-c'}$ for $i \notin I$ and $r = \frac{u-u'}{c-c'}$. Since these values must satisfy the verification equation with the full generator set, all omitted indices must correspond to zero values.

    HVZK: The simulator from Theorem 1 operates identically on the reduced generator set, producing perfectly indistinguishable transcripts.
\end{proof}



\begin{corollary}[Equality of Committed Values]
    Construction 1 can be used to prove equality of messages in two Pedersen commitments. Specifically, for commitments $\cm_1 = g_1^m h_1^{r_1}$ and $\cm_2 = g_2^m h_2^{r_2}$, we can prove knowledge of $(m, r_1, r_2)$ satisfying the relation:
    \[
    \mathcal{R} = \left\{ ((\cm_1, \cm_2, g_1, g_2, h_1, h_2), (m,r_1,r_2)) \; | \; \cm_1 = g_1^{m}h_1^{r_1} \; \wedge \; \cm_2 = g_2^{m}h_2^{r_2} \right\}
    \]    
\end{corollary}

\begin{proof}
    We instantiate Construction 1 with generators $(g_1, g_2, h_1, h_2)$ and prove knowledge of opening:
    \[
    \cm = (g_1^m h_1^{r_1}, g_2^m h_2^{r_2})
    \]
    
\noindent    The protocol runs as follows:
    \begin{enumerate}
        \item $\Prover$ samples $\alpha, \rho_1, \rho_2 \sample \Z_p$ and sends $T_1 \gets g_1^{\alpha}h_1^{\rho_1}, T_2 \gets g_2^{\alpha}h_2^{\rho_2}$
        \item $\Verifier$ sends challenge $c \sample \Z_p$
        \item $\Prover$ sends $s \gets \alpha + cm, u_1 \gets \rho_1 + cr_1, u_2 \gets \rho_2 + cr_2$
        \item $\Verifier$ checks $g_1^s h_1^{u_1} = \cm_1^c T_1 \wedge g_2^s h_2^{u_2} = \cm_2^c T_2$
    \end{enumerate}

\noindent Security follows from Theorem 1:
    \begin{itemize}
        \item Completeness: Inherits directly as this is a specific instantiation
        \item Special Soundness: The extractor obtains a single $m$ from $s$ and corresponding $r_1, r_2$ from $u_1, u_2$
        \item HVZK: The simulator from Theorem 1 extends naturally by sampling a single $s$ for both equations
    \end{itemize}
    
    Crucially, using the same $\alpha$ for both $T_1$ and $T_2$ ensures the extracted message $m$ must be identical in both commitments.
\end{proof}

\begin{corollary}[Proof of Multiplicative Inverse]
    Construction 1 can be used to prove that two committed values are multiplicative inverses. Specifically, for commitments $\cm_1 = g^{m_1}h^{r_1}$ and $C_2 = g^{m_2}h^{r_2}$, we can prove knowledge of $(m_1, m_2, r_1, r_2)$ satisfying the relation:
    \[
    \mathcal{R} = \left\{ ((C_1, C_2, g, h), (m_1, m_2, r_1, r_2)) \; | \; C_1 = g^{m_1}h^{r_1} \; \wedge \; C_2 = g^{m_2}h^{r_2} \; \wedge \; m_1 \cdot m_2 = 1 \right\}
    \]    
\end{corollary}

\begin{corollary}[Proof of Reciprocal Exponents]
    Construction 1 can be used to prove that two committed values are multiplicative inverses. Specifically, for commitments $C_1 = g^{m_1}h^{r_1}$ and $C_2 = g^{m_2}h^{r_2}$, we can prove knowledge of $(m_1, m_2, r_1, r_2)$ satisfying the relation:
    \[
    \mathcal{R} = \left\{ ((C_1, C_2, g, h), (m_1, m_2, r_1, r_2)) \; | \; C_1 = g^{m_1}h^{r_1} \; \wedge \; C_2 = g^{m_2}h^{r_2} \; \wedge \; m_1 \cdot m_2 = 1 \right\}
    \]    
\end{corollary}

\begin{proof}
    The protocol runs as follows:
    \begin{enumerate}
        \item $\Prover$ samples $\alpha_1, \alpha_2, \rho_1, \rho_2, \rho_3, \rho_4 \sample \Z_q$ and computes:
            \begin{itemize}
                \item $T_1 \gets g^{\alpha_1}h^{\rho_1}$, $T_2 \gets g^{\alpha_2}h^{\rho_2}$
                \item $C_3 \gets C_1^{m_2}h^{\rho_3}$, $C_4 \gets h^{\rho_4}$
                \item $T_3 \gets C_1^{\alpha_2}h^{\rho_3}$, $T_4 \gets h^{\rho_4}$
            \end{itemize}
        
        \item $\Verifier$ sends challenge $c \sample \Z_q$
        
        \item $\Prover$ responds with:
            \begin{itemize}
                \item $s_1 \gets \alpha_1 + cm_1$, $s_2 \gets \alpha_2 + cm_2$
                \item $u_1 \gets \rho_1 + cr_1$, $u_2 \gets \rho_2 + cr_2$
                \item $u_3 \gets \rho_3 + cr_3$, $u_4 \gets \rho_4 + cr_4$
            \end{itemize}
            
        \item $\Verifier$ checks:
            \begin{align*}
                g^{s_1}h^{u_1} &= C_1^cT_1 \\
                g^{s_2}h^{u_2} &= C_2^cT_2 \\
                C_1^{s_2}h^{u_3} &= C_3^cT_3 \\
                h^{u_4} &= C_4^cT_4 \\
                C_3/C_4 &= g
            \end{align*}
    \end{enumerate}

    Security follows from Theorem 1 as we are effectively running multiple instances of the base protocol with additional algebraic constraints. The final check $C_3/C_4 = g$ ensures $m_1 \cdot m_2 = 1$ because:
    \begin{itemize}
        \item $C_3 = C_1^{m_2}h^{\rho_3} = g^{m_1m_2}h^{r_1m_2 + \rho_3}$
        \item $C_4 = h^{\rho_4}$
        \item Therefore $C_3/C_4 = g^{m_1m_2}h^{r_1m_2 + \rho_3 - \rho_4}$
        \item If this equals $g$, then $m_1m_2 = 1$
    \end{itemize}
\end{proof}






















\begin{construction}{Proof of reciprocal exponents equals 1($C_1, C_2$)}{recipexpproof}
    \vspace{1em}
    \textbf{Public Parameters:} $g, h \in \G$

    \textbf{Inputs:} $C_1, C_2$ such that $C_1 = g^{m_1}h^{r_1}$, $C_2 = g^{m_2}h^{r_2}$. $\Prover$ knows $m_1, m_2, r_1, r_2 \in \Z_q$.
    \vspace{1em}
        \begin{enumerate}
        \item $\Prover$ samples $\alpha_1, \alpha_2, \rho_1, \dots, \rho_4 \sample [q-1]$ and computes blinding commitments for $C_1, C_2$

        $T_1 \gets g^{\alpha_1}h^{\rho_1}$ \qquad $T_2 \gets g^{\alpha_2}h^{\rho_2}$
        
        \vspace{1em}

        and interim commitments $C_3, C_4$ and their blinding commitments $T_3, T_4$

        $C_3 \gets C_1^{m_2}h^{r_3}$ \qquad $C_4 \gets h^{r_4}$ \qquad $T_3 \gets C_1^{\alpha_2}h^{\rho_3}$ \qquad $T_4 \gets h^{\rho_4}$

        \vspace{1em}

        \item $\Verifier$ sends challenge $c \sample [q-1]$

        \item $\Prover$ responds with 

        $s_1 \gets \alpha_1 + cm_1$  \qquad $s_2 \gets \alpha_2 + cm_2$

        $u_1 \gets \rho_1 + cr_1$ \qquad $u_2 \gets \rho_2 + cr_2$ \qquad  $u_3 \gets \alpha_3 + cr_3$ \qquad  $u_4 \gets \alpha_4 + cr_4$

        \item $\Verifier$ verifies that 
        
        $g^{s_1}h^{u_1} = C_1^c T_1$ \qquad $g^{s_2}h^{u_2} = C_2^c T_2$ \qquad $C_1^{s_2}h^{u_3} = C_3^c T_3$
        
        $h^{u_4} = C_4^c T_4$ \qquad  $C_3/C_4 = g$
    \end{enumerate}
\end{construction}
    

\begin{theorem}
    Protocol~\ref{construct:recipexpproof} is a $\Sigma-$protocol for the relation: 
     \[
    \mathcal{R} = \left\{ (C_1, C_2, g, h, q),(m_1, m_2, r_1, r_2) \; | \; C_1 = g^{m_1}h^{r_1} \wedge C_2 = g^{m_2}h^{r_2} \wedge m_1 \cdot m_2 = 1 \right\}
    \]  
\end{theorem}

\begin{proof}
    Completeness. 
\end{proof}













\subsubsection{Completeness}
Proof of knowledge of exponents $m1, r1$ by opening $C_1$ 
\begin{align}
    C_1^e \cdot T_1 &\stackrel{?}{=} g^{z_{m1}} h^{z_{r1}} \notag \\
    (g^{m1}h^{r_1})^e \cdot g^{\beta_1}h^{\rho_1} &= g^{\beta_1 + e \cdot m_1} h^{\rho_1 + e \cdot r_1} \notag \\
    g^{e \cdot m1 + \beta_1}h^{e \cdot r_1 + \rho_1} &= g^{\beta_1 + e \cdot m_1} h^{\rho_1 + e \cdot r_1} \notag 
\end{align}

Proof of knowledge of exponents $m2, r2$ by opening $C_2$ 
\begin{align}
    C_2^e \cdot T_2 &\stackrel{?}{=} g^{z_{m2}} h^{z_{r2}} && \label{eq:ver1} \\
    (g^{m2}h^{r_2})^e \cdot g^{\beta_2}h^{\rho_2} &= g^{\beta_2 + e \cdot m_2} h^{\rho_2 + e \cdot r_2} \notag \\
    g^{e \cdot m2 + \beta_2}h^{e \cdot r_2 + \rho_2} &= g^{\beta_2 + e \cdot m_2} h^{\rho_2 + e \cdot r_2} \notag 
\end{align}


Equality of $m2 \in \{C_2, C_3\}$ proven by equality of responses $g^{z_{m2}}$ used in \eqref{eq:ver1} and \eqref{eq:ver2}
\begin{align}
    C_3^e \cdot T_3 &\stackrel{?}{=} C_1^{z_{m2}} h^{z_{r3}} \notag \\
    (C_1^{m2}h^{r_3})^e \cdot C_1^{\beta_2}h^{\rho_3} &= C_1^{\beta_2 + e \cdot m_2} h^{\rho_3 + e \cdot r_3} \label{eq:ver2} \\
    C_1^{m2 \cdot e + \beta_2}h^{e \cdot r_3 + \rho_3} &= C_1^{\beta_2 + e \cdot m_2} h^{\rho_3 + e \cdot r_3} \notag
\end{align}

Proof of knowledge of exponent $r4$ by opening $C_4$ 
\begin{align}
    C_4^e \cdot T_4 &\stackrel{?}{=} h^{z_{r4}} \notag \\
    (h^{r_4})^e \cdot h^{\rho_4} &\stackrel{?}{=} h^{\rho_4 + e \cdot r_4} \notag \\
    h^{e \cdot r_4 + \rho_4} &= h^{\rho_4 + e \cdot r_4} \notag
\end{align}

Prove that $C_3/C_4 = g$ implies $g^{\frac{m1}{m2}} = 1$ which proves their inverse relation. Recall $C_1 = g^{m_1}h^{r_1}, r_4 = r_1m_2 + r_3$
\begin{align}
    \dfrac{C_3}{C_4} = \dfrac{C_1^{m2}h^{r_3}}{h^{r_4}} = \dfrac{(g^{m_1}h^{r_1})^{m2}h^{r_3}}{h^{r_1 \cdot m_2 + r_3}} = \dfrac{g^{m_1\cdot m2}h^{r_1\cdot m2 + r_3}}{h^{r_1 \cdot m_2 + r_3}} = \dfrac{g}{1} = g \notag \\
\end{align}

\subsubsection{Soundness}
\todonote{Sam todo}

\subsubsection{Zero Knowledge}
\todonote{Sam todo}

\subsubsection{Analysis G1 Method}
\begin{itemize}
    \item \textbf{Prover:} 11 $\G_1$ exponentiations, 4 $\G_1$ additions, 6 $\F_p$ multiplications, 6 $\F_p$ additions
    \item \textbf{Verifier:} 11 $\G_1$ exponentiations, 7 $\G_1$ additions/subtractions, 
\end{itemize}

\subsection{NIZK for Credential Chaining}
\subsection{NIZK for equality of commitments in different groups}
\todonote{sam to do}




\subsection{Proof of NIZK}


\cleardoublepage
\section{Private Identity System from MIMC-ABC}\label{sec:idsys}

Our identity system establishes a secure framework for issuing and managing privacy-preserving credentials across multiple authorities while maintaining accountability. The system involves four key entities: users, credential oracles (which verify and attest to user attributes), auditor (who manage revocation), and credential verifiers.

\noindent At the core of our system is a master credential issued by a government credential oracle, which serves as a root of trust. This credential contains two crucial committed elements: a secret identifier $s$ that enables secure credential linking, and a committed VRF key $k$ that generates context-specific nullifiers. These nullifiers serve dual purposes: preventing Sybil attacks at credential oracles and enabling efficient revocation. During master credential issuance, the VRF key is verifiably encrypted, the ciphertext is stored in the government system which associates a plaintext user profile to their ciphertext for revocation.


\noindent Users can obtain context credentials from various credential oracles by proving possession of a valid, unrevoked master credential and deriving a unique nullifier using their VRF key and the credential context. This design allows credential oracles to restrict issuance to users with trusted government-issued credentials, ensuring their credentials are only issued to verified identities. The system supports expressive verification statements that can combine attributes across multiple credentials. Since master credentials are government-issued and require stringent security checks, verifiers can leverage this trust by incorporating master credential validity, expiration, and revocation checks into their verification statements, inheriting the strong security properties of government-issued credentials. This enables credential oracles to maintain trust by ensuring their credentials become unusable if the underlying government credential is revoked.


\noindent The system supports flexible revocation through two mechanisms: targeted revocation of specific credentials via their nullifiers, and complete revocation of all user credentials by recovering their VRF key through the auditors. Government systems can initiate revocation by using plaintext identifiers, with auditors managing the conversion to the appropriate nullifiers. This approach maintains privacy while enabling practical accountability and administration.

We use the Multi Issuer Multi Credential Anonymous Credential system to implement a privacy-preserving digital identity system

\subsection{Entities}
Our identity system involves users, credential issuers, auditors, and credential verifiers.

\noindent \textbf{User} ($\User$) holds a master credential $Cred_{master}$ and any number of context credentials $Cred_{ctx}$ in their identity wallet. The master credential contains a unique identifier $s$, a VRF key $k$, and additional attributes, and is issued by a government entity. Context credentials are issued by participating organizations like universities or licensing authorities.

\noindent \textbf{Credential Oracle} ($\MCO, \CCO$) verifies user identity and issues digital credentials. The Master Credential Oracle $\MCO$ operates with keypair $(SK_{m}, PK_{m})$ for issuing "root" credentials, while Context Credential Oracles $\CCO$ use $(SK_{c}, PK_{c})$ for issuing domain-specific credentials.

\noindent \textbf{Auditor} ($\Auditor$) consists of a threshold of nodes holding encryption and accumulator keypairs; for simplicity, we refer to both as $(sk_A, pk_A)$. Users encrypt their VRF keys under the auditors' public key, as in key escrow schemes. Auditors can decrypt this key during revocation. The Auditor updates the revocation list. 

\noindent \textbf{Verifier} ($\Verifier$) represents any party wishing to verify a user's credentials.

\subsection{Data Objects}

We now describe the data objects that form our privacy-preserving decentralized identity system. At its core, a Master Credential serves as a root of trust, from which Context Credentials can be derived. During Context Credential issuance, users generate a deterministic nullifier unique to each context using their Master Credential's secrets and the context string, enabling privacy-preserving credential linking.

\subsubsection{Master Credential $Cred_m$}: 
A master credential is a high-security root credential issued by a government entity containing:

\begin{itemize}
    \item Identity string $s$: a unique identifier
    \item VRF key $k$: used to generate context-specific nullifiers
    \item Context type $ctx$: always set to "master" for master credentials
    \item Additional attributes $attrs$: including expiry date, date of birth, etc.
    \item Credential Structure:
    \begin{itemize}
        \item Master Commitment $C_m = Com([s, k, ctx, attrs],r)$: A Pedersen commitment to the credential attributes using randomness $r$
        \item Oracle signature $\sigma_m$: A rerandomizable signature over $C_m$, verifiable under $PK_m$
    \end{itemize}
\end{itemize}

\subsubsection{Master Credential Oracle Data Record:} Following successful master credential issuance, the oracle maintains a record containing:
\begin{itemize}
    \item Commitment-Signature Pair $(C_m, Cred_m)$:
    \begin{itemize}
        \item Master commitment $C_m = Com([s,k,ctx,attrs],r)$: the Pedersen commitment over credential attributes
        \item Oracle Signature $Cred_m$ The signature over commitment $C_m$
    \end{itemize}
    \item Key Encryption and Proof:
    \begin{itemize}
        \item Encrypted VRF Key $CT_k$: the encryption of the user's VRF key, encrypted with the Auditor's public key $Enc_{PK_a}(k)$
        \item Consistency proof $\Pi_{CT}$: The zero-knowledge proof that $CT_k$ encrypts the committed key $k$
    \end{itemize}
\end{itemize}


\subsubsection{Context Credential $Cred_c$}: 
A user interacts with the Context Credential oracle to obtain a context-specific credential, which contains:
\begin{itemize}
    \item Identity string $s$: The user's unique identifier from their master credential
    \item Nullifier $\tau$: A deterministic value generated from $(s, ctx)$
    \item Context string $ctx$: A hashed identifier of the credential type (e.g., $dmv$, $universityofsydney$)
    \item Attribute list $attrs$: Additional credential-specific information such as expiry date
    \item $\sigma_c$ the rerandomizable signature over $C_c$ from the context credential oracle that proves the user has been issued $Cred_c$ over $C_c$
    \item Credential Structure:
    \begin{itemize}
        \item Context commitment $C_c$: A Pedersen commitment $Com([s, \tau, ctx, attrs],r')$ to the credential attributes using randomness $r'$
        \item Oracle signature $\sigma_c$: A rerandomizable signature over $C_c$, verifiable under $PK_c$
    \end{itemize}
    
\end{itemize}


\subsubsection{Context Credential Oracle Data Record:} During credential issuance, the oracle maintains a record of the interaction containing:
\begin{itemize}
    \item Master Credential Verification: 
        \begin{itemize}
            \item Randomized credential $Cred_m'$: a rerandomized version of the master credential
            \item Randomized commitment $C_m'$: the corresponding rerandomized commitment
            \item Opening proof $\Pi_{ComOpen}$: Zero-knowledge proof of correct commitment opening
            \item Revocation proof $\Pi_{NonRevoked}$:  Zero-knowledge proof that the credential has not been revoked
        \end{itemize}
    \item Nullifier Components:
    \begin{itemize}
        \item Context nullifier $\tau$: The value $VRF(k,ctx)$ derived from the user's committed VRF key and credential context
        \item Derivation proof $\Pi_{\tau}$: Zero-knowledge proof establishing that
        \begin{itemize}
            \item The VRF computation is correct
            \item The key $k$ matches the one committed in $Cred_m$
            \item The context string $ctx$ is correctly incorporated
        \end{itemize}
    \end{itemize}
\end{itemize}

\subsubsection{Revocation List:} 
\begin{itemize}
    \item Accumulator Structure:
    \begin{itemize}
        \item Accumulator value $A$: The current state of the accumulator representing non-revoked credentials
        \item Secret key $sk_A$: The accumulator manager's key for updates
        \item Auxiliary information $aux$: Additional data needed for witness updates
    \end{itemize}
    \item Revoked Elements:
    \begin{itemize}
        \item Master revocations $k$: VRF keys of revoked master credentials
        \item Context revocations $\tau$: Nullifiers of revoked context credentials
        \item Timestamp $t$: Time of revocation
        \item Reason code $rc$: Justification for revocation
    \end{itemize}
    \item Witness Management:
    \begin{itemize}
        \item Non-membership witness $w$: Proof that a credential is not in the revocation set
        \item Update information $upd$: Data for users to update their witnesses after accumulator changes
    \end{itemize}
\end{itemize}

\betteridea{Notes on Threat/Trust model: threat model has issuer/verifier, trust model has credd oracle, auditor, etc. Keep consistent. Also, state what's out of scope e.g. network, physical, side-channel. domain in arke = context}

\subsubsection{Trust Model}
\begin{itemize}
    \item Credential Oracles: trusted to verify real-world identity before issuing credentials, they aren't trusted for privacy and may be compromised but can't issue credentials without the user participating in their protocol

    \item Auditors: are trusted to only decrypt user keys for legitimate revocation requests

    \item Network: communication assumed to be over encrypted channels, any storage is not trusted for credential contents
\end{itemize}

\subsubsection{Threat Model}
We assume the auditor maintaining the revocation cannot be corrupted.

\begin{itemize}
    \item Malicious Credential Oracle: A malicious credential oracle could "falsely issue attestations and impersonate any user it desires. Fortunately, recent work on authenticating web data has shown privacy-preserving, untrusted and correct credential oracles can be realized in practice [DECO, distefano, etc]. Additionally, we mitigate the threat level by confining each credential oracle to a unique domain." - from Arke. 
    \item Malicious User: attempts to obtain multiple credentials for the same context, tries to forge credentials or share them with others, attempts to link credentials with other credentials not issued to the same master secret key
    \item Malicious Issuer: attempts to link multiple showing, collude with issuers to deanonymize users, stores presentation proofs to track users
    \item Malicious Verifier: issue credentials without proper verification, attempts to track credential usage, colludes with issuers or other verifiers
\end{itemize}



\subsection{Syntax}
\todonote{Sam to update this to include master and context cred and revocation}

Syntax of Anonymous Identity System with Sybil Resistance and Revocation
\begin{itemize}
    \item $\mathsf{Setup}(\secparam) \to (\ppar, \UL, \RL)$ Takes security parameter $\lambda$ in unary, outputs public parameters $\ppar$, empty user list $\UL$ and revocation list $\RL$.

    \item $\mathsf{OrgKeygen}(\ppar, n) \torand (\osk, \opk)$: is a probabilistic algorithm that takes public parameters $\ppar$ and $n$ the upper bound of credential attributes. Outputs organisations keypair $(\osk, \opk)$

    \item $\mathsf{UserKeygen}(\secparam) \torand (\usk)$ is a probabilistic algorithm. Outputs user secret key $\usk$ consisting of PRF key $k$ and identity string $s$

    \item $(\mathsf{Obtain Master}(usk, \textbf{m}, aux), \mathsf{Issue Master}(osk, cm, aux)) \to cred:$ An interactive protocol. $Obtain$ is a probabilistic alrogithm run by a user, inputs secret key, credential attribute vector $\textbf{m}$ and auxiliary info. $Issue$ is a probabilistic algorithm run by an issuing organization that takes a commitment $cm$, issuers secret key $osk$, and auxiliary info. Outputs a credential $cred$ binding $cm$ to the issuer signature.

    \item $(\mathsf{Obtain Context}(usk, \textbf{m}, aux), \mathsf{Issue Context}(osk, cm, aux)) \to cred:$ An interactive protocol. $Obtain$ is a probabilistic alrogithm run by a user, inputs secret key, credential attribute vector $\textbf{m}$ and auxiliary info. $Issue$ is a probabilistic algorithm run by an issuing organization that takes a commitment $cm$, issuers secret key $osk$, and auxiliary info. Outputs a credential $cred$ binding $cm$ to the issuer signature.

    \item $(\mathsf{Show}(usk, cred, \phi), \mathsf{Verify}(cred', cm, \pi)) \to \bit$ An interactive protocol. $Show$ is a probabilistic algorithm run by a Prover. Takes secret key, credential, and predicate statement $\phi$. $Verify$ is a deterministic algorithm run by a verifier, takes a randomized credential and commitment $cred', cm'$ and proof $\pi$. Otuputs 1 if verification succeeds, otherwise 0.

    \item $\mathsf{Revoke}(\RL, k') \to \RL'$ revoke is a deterministic algorithm, updates revocation list with revoked key $k'$
\end{itemize}

\subsection{Security Model}
\begin{itemize}
    \item \textbf{Sybil resistance}: For any given context, no probabilistic polynomial time adversary can obtain more than 1 valid credential with non-negligible probability 
    
    \item \textbf{Revocability}: For any given context, no probabilistic polynomial time adversary use a revoked credential 
\end{itemize}

\subsubsection{Sybil Resistance}

\subsubsection{Revocation}
When $ra$ needs to revoke a user's credential/s (due to user request or credential provider request), $ra$ finds $escrow$ based on the user's $pid$, recall $ra$ has a user list $ul$ = $(pid, escrow)$ and requests the auditor $audit$ to decrypt $s \gets tpkdec_{ask}(escrow)$. $audit$ computes the nullifiers to add to the revocation accumulator. $nullif_{rcd} \gets PRF_s(pid)$ and for each context credential to revoke, $nullif_{ctxid} \gets PRF_s(ctxid)$. $audit$ updates the accumulator $acc' \gets Acc.Add(acc)$
If the registration credential requires revocation, $audit$ can compute each $nullif \gets PRF_{s}(ctxid) ; \forall ; ctxid ; \in ; ctxl$ and add $(nullif, timestamp, reason)$ to $rl$. For record-keeping, $ra$ stores Revocation Information $ri = (nullif, timestamp, reason)$ allowing $ra$ to track which credentials are revoked and why, $nullif$ in $rl$ ensures revoked credentials can't be verified.
During credential verification, verifiers check if a credential's nullifier appears in $rl$, if present, the verification fails.














\newpage
\section{Performance Evaluation}\label{sec:evaluation}
What is the takeaway message from the evaluation?
\begin{itemize}
    \item For non-private system, we enable privacy with little overhead. Our building block sigma protocol for private sybil resistance adds negligible overhead. 
    \item For private system, but better efficiency, we have a SOTA paper TACT/S3ID (in the comparison table). Their paper does multi-attribute/multi-issuer credentials (they issue 1 credential per attribute), but their benchmarks don't show the complexity in verifying credentials together, or proving statements about their credential which they say would have non-negligible impact and theirs is lower bound. For us, by using simpler and well-known construction, we are more efficient (need to test this but I think so due to their construction) and better functionality. 
\end{itemize}


















\cleardoublepage
\section{Appendix, Old Writings}
\newpage


\subsection{Zero Knowledge Proof}
\begin{itemize}
    \item $ZKP.ComOpen_{ck}(cm, m_i, r) \to \Pi^{cm}$
    \item $ZKP.ComOpenVfy_{ck}(cm, \Pi^{cm}) \to \bit$
\end{itemize}

\subsection{Anonymous Credential}


\begin{center}
\begin{tabular}{l@{\hspace{8em}}c@{\hspace{8em}}l}
\multicolumn{3}{l}{$\underline{OrgKeyGen(1^{\lambda}, 1^n)}$:  Given $\lambda, n > 0$, compute $BG = (p, \G_1, \G_2, \G_T, e, g, \tilg) $}.\\[0.5em]
\multicolumn{3}{l}{Run $ck \gets CM.Setup(BG, 1^{\lambda}, 1^n)$ which defines $(g, g^{\yb}, \tilg, \tilg^{\yb})$ with $ \yb_{\in[n]}$} \\[0.5em]
\multicolumn{3}{l}{Run $(sk, vk) \gets PS.KeyGen(ck, 1^{\lambda}, 1^n)$ which defines $sk = X \in \G_1$ and $vk = \tilx \in \G_2$}\\[0.5em]
\multicolumn{3}{l}{$osk = (g, X), opk = (ck, \tilx, BG)$, return $(osk, opk)$}\\[2em]
\underline{Obtain(opk, $\mathbf{m}$)} && \underline{Issue(osk, $cm$)} \\[1em]
\multicolumn{3}{l}{Parse $opk = (ck, \tilx, BG)$, sample $r \sample \Z_p$} \\[0.5em]
\multicolumn{3}{l}{Compute $(cm, \widehat{cm}) \gets CM.Com(ck, \mathbf{m}, r)$} \\[0.5em]
\multicolumn{3}{l}{Run $\Pi^{cm} \gets ZKP.ComOpen(ck, cm, \mathbf{m}, r)$} \\[0.5em]
& $\xrightarrow{\Pi^{cm}}$ & \\[1em]
\multicolumn{3}{r}{If $ZKP.ComOpenVfy(\Pi^{cm},cm) = 0$, return $\bot$} \\[1em]
& $\xleftarrow{\sigma = (\sigma_1, \sigma_2)}$ & $\sigma \gets \mathsf{PS.Sign}(osk, cm)$ \\[1em]
\multicolumn{3}{l}{If $\mathsf{PS.Verify}(opk, cm, \sigma) = 0$, return $\bot$} \\[1em]
\multicolumn{3}{l}{$Cred \gets (\sigma = (\sigma_1, \sigma_2), opk, cm, \widehat{cm})$} \\[1em]
\end{tabular}
\end{center}

\noindent \underline{(Show, Verify)}: Using ..... Show, and Verify interact as follows



\begin{center}
    \begin{tabular}{l@{\hspace{8em}}c@{\hspace{8em}}l}
    \underline{Show($opk, cm, Cred$)} && \underline{Verify($osk, Cred' $)} \\[1em]
    \end{tabular}
\end{center}

\subsection{Old Intro}

\textbf{Privately Linked Context Credentials}
The Internet Identity Workshop discussed a problem space summarised by the following problems:
1. issuing credentials that are both government and privately issued
2. retaining accountability in derived credentials, ensuring derived credentials are fit for purpose and have revocation (Proveable Provenance, Linked Data)
3. combining traditional digital identity with decentralized identity




As digital wallets are gradually introduced, one notable problem involves combining 
As digital identities are introduced, there must be methods to combine the old world and the new world with respect to identities. 
One problem use-case is organisations such as a university issuing certificates as credentials. 
Universities want to start issuing credentials to users 

A university, a credential provider, and wants to issue a credential to a user sam.

The University is not yet using decentralized identity but would like to issue a credential to Sam's digital identity wallet. 
Sam's logged in to the university portal with his classical login. Sam presses "Issue Credential" and starts the credential-issuing process. 

The university wants to check a few things before issuing this credential.
1. make sure their national credential is valid, that is, it verifies
2. as it's an anonymous credential, the university wants to make sure the user that's logged into their portal is the same user with the registration credential. The user may selectively disclose their attributes, or prove equality of attributes in zero knowledge, or may have another proof.

The university generates a credentialId and stores it in their system and carries out the following protocol with Sam

Sam wants to keep as many details as secret as possible, and thus, he carries out the following protocol
1. Sam creates a new commitment Com([pid, 0]r), proves opening of the commitment and equality of pid between rcm and this commitment.
2. The university generates Com([0,credId]0) and homomorphically creates ccm([pid, credId]r) = Com([pid, 0]r) x Com([0,credId]0). The university then signs ccm([pid, credId]r) with their own signature scheme.
3. Sam can now take rcm and ccm, sigma(ccm) to the blockchain of nodes.
4. Sam runs a protocol with the blockchain to be issued a Decentralied version of this credential with full private accountability. 


\subsection{ZKP Sigma Protocol for proving PRF output with pairing}

\[
ZKP
    \left\{ 
    (m_1, m_2, r_1, r_2): C_1 = g_1^{m_1}h_1^{r_1} \in \G_1 \wedge C_2 = g_2^{m_2}h_2^{r_2} \in \G_2 \wedge m_1 \cdot m_2 = 1
    \right\}
\]


\pcb{
\prover[m_1, m_2, r_1, r_2] \< \< \verifier[C_1, C_2, g, h]  \\[0.1\baselineskip][\hline]
\<\< \\[-0.5\baselineskip]
\pclinecomment{$C_1 = g_1^{m_1}h_1^{r_1}, C_2 = g_2^{m_2}h_2^{r_2}$ } \\
{\{\rho_i\}_{i=1}^2, \{\beta_i\}_{i=1}^2, \{\gamma_i\}_{i=1}^4}  \sample \mathbb{Z}_q^8 \<\< \\
T_1 \in \G_1 \gets g_1^{\beta_1}h_1^{\rho_1} \<\< \\
T_2 \in \G_2 \gets g_2^{\beta_2}h_2^{\rho_2} \<\< \\
\pclinecomment{generate interim elements} \\
\alpha_1 \gets m_1 \cdot m_2 \<\< \\
\alpha_2 \gets m_1 \cdot t_2 \<\< \\
\alpha_3 \gets t_1 \cdot m_2 \<\< \\
\alpha_4 \gets t_1 \cdot t_2 \<\< \\
A_1 \gets e(g_1, g_2) \<\< \\
A_2 \gets e(g_1, h_2) \<\< \\
A_3 \gets e(h_1, g_2) \<\< \\
A_4 \gets e(h_1, h_2) \<\< \\
\pclinecomment{$C_3 = e(C_1, C_2)$} \\
C_3 \in \G_T \gets A_1^{\alpha_1} A_2^{\alpha_2} A_3^{\alpha_3}  A_4^{\alpha_4}\<\< \\
T_3 \in \G_T \gets  A_1^{\gamma_1} A_2^{\gamma_2} A_3^{\gamma_3} A_4^{\gamma_4} \<\< \\
\< \sendmessageright* {\{C_i, T_i\}_{i=1}^3, \{A_i\}_{i=1}^4} \< \\
\< \sendmessageleft*{e} \< e \sample \mathbb{Z}_q \\
\{z_{mi} = \beta_i + e \cdot m_i \}_{i=1}^2 \<\< \\
\{z_{ri} = \rho_i + e \cdot r_i \}_{i=1}^2 \<\< \\
\{z_{ai} = \gamma_i + e \cdot \alpha_i \}_{i=1}^4 \<\< \\
\< \sendmessageright*{\{z_{mi}, z_{ri}\}_{i=1}^2, \{z_{ai}\}_{i=1}^4 } \< \\
\<\< C_1^e \cdot T_1 \stackrel{?}{=} g_1^{z_{m1}} h_1^{z_{r1}}\\
\<\< C_2^e \cdot T_2 \stackrel{?}{=}  g_2^{z_{m2}} h_2^{z_{r2}}\\
\<\< C_3^e \cdot T_3 \stackrel{?}{=}  A_1^{z_{a1}}A_2^{z_{a2}}A_3^{z_{a3}}A_4^{z_{a4}}\\
\<\< 
}


\newpage
\subsubsection{Completeness}
Proof of knowledge of exponents $m1, r1$ by opening $C_1$
    \begin{align}
    C_1^e \cdot T_1 &\stackrel{?}{=} g^{z_{m1}} h^{z_{r1}} \notag \\
    (g^{m1}h^{r_1})^e \cdot g^{\beta_1}h^{\rho_1} &= g^{\beta_1 + e \cdot m_1} h^{\rho_1 + e \cdot r_1} \notag \\
    g^{e \cdot m1 + \beta_1}h^{e \cdot r_1 + \rho_1} &= g^{\beta_1 + e \cdot m_1} h^{\rho_1 + e \cdot r_1} \notag
    \end{align}

    
Proof of knowledge of exponents $m2, r2$ by opening $C_2$
\begin{align}
    C_2^e \cdot T_2 &\stackrel{?}{=} \tilg^{z_{m2}} \tilh^{z_{r2}} && \label{eq:ver2} \\
    (\tilg^{m2}\tilh^{r_2})^e \cdot \tilg^{\beta_2}\tilh^{\rho_2} &= \tilg^{\beta_2 + e \cdot m_2} \tilh^{\rho_2 + e \cdot r_2} \notag \\
    \tilg^{e \cdot m2 + \beta_2}\tilh^{e \cdot r_2 + \rho_2} &= \tilg^{\beta_2 + e \cdot m_2} \tilh^{\rho_2 + e \cdot r_2} \notag
    \end{align}

    
\begin{align}
    C_3 = e(C_1, \tilde{C_2}) = e(g^{m1} h^{r1}, \tilg^{m2} \tilh^{r2}) \notag \\
    = e(g^{m1}, \tilg^{m2}) \cdot e(g^{m1},\tilh^{r2}) \cdot e(h^{r1}, g^{m2}) \cdot e(h_1^{r1}, \tilh^{r2})  \notag \\
    = e(g, \tilg)^{m1\cdot m2} \cdot e(g,\tilh)^{m1 \cdot r2} \cdot e(h, \tilg)^{r1 \cdot m2} \cdot e(h, \tilh)^{r1 \cdot r2}  \notag \\
\end{align}



\begin{itemize}
    \item Prove knowledge of exponents $(m1 \cdot r2), (r1 \cdot m2), (r1 \cdot r2)$ for $C_3$/$e(g,\tilg)$  with respect to base points $e(g,\tilh) e(h, \tilg) e(h, \tilh)$
    \item $C_3$/$e(g,\tilg)$ 
    \item 
\end{itemize}


Prove that $e(g, \tilg)^{(m1 \cdot m2)} = e(g, \tilg)$ by computing $C_4 = e(g,\tilh)^{m1 \cdot r2} \cdot e(h, \tilg)^{r1 \cdot m2} \cdot e(h, \tilh)^{r1 \cdot r2}$, proving the opening and equality of $(m1 \cdot r2), (r1 \cdot m2), (r1 \cdot r2)$ with $C_3$, then proving $C_3/C_4 = e(g, \tilg) \cdot e(g,\tilh) \cdot e(h, \tilg) \cdot e(h, \tilh) $

\newpage
\subsubsection{Analysis Pairing Method}
\begin{itemize}
    \item \textbf{Prover:} 2 $\G_1$ exp, 2 $\G_2$ exp, 8 $\G_T$ exp, 1 $\G_1$ add, 1 $\G_2$ add, 6 $\G_T$ mul, 12 $\F_p$ mul, 8 $\F_p$ add, 4 pairing
    
    \item \textbf{Verifier:} 3 $\G_1$ exp, 3 $\G_2$ exp, 5 $\G_T$ exp, 2 $\G_1$ add, 2 $\G_2$ add, 4 $\G_T$ mul
\end{itemize}

\subsubsection{Soundness}
\todonote{Sam todo}

\subsubsection{Zero Knowledge}
\todonote{Sam todo}



\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Operation} & \textbf{Prover} & \textbf{Verifier} \\
\hline
\multicolumn{3}{|l|}{\textbf{Commitment Equality Method}} \\
\hline
G1 exponentiations & 4 & 5 \\
G1 additions & 2 & 4 \\
Fp multiplications & 3 & 0 \\
Fp additions & 3 & 0 \\
\hline
\multicolumn{3}{|l|}{\textbf{G1 VRF Method}} \\
\hline
G1 exponentiations & 11 & 11 \\
G1 additions & 4 & 7 \\
Fp multiplications & 6 & 0 \\
Fp additions & 6 & 0 \\
\hline
\multicolumn{3}{|l|}{\textbf{Pairing + VRF Method}} \\
\hline
G1 exponentiations & 2 & 3 \\
G2 exponentiations & 2 & 3 \\
G1 additions & 1 & 2 \\
G2 additions & 1 & 2 \\
Fp multiplications & 12 & 0 \\
Fp additions & 8 & 0 \\
GT exponentiations & 8 & 5 \\
GT multiplications & 6 & 4 \\
Pairings & 4 & 4 \\
\hline
\end{tabular}
\caption{Comparison of computational operations between G1 and Pairing methods}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{|l|r|}
\hline
\textbf{Operation} & \textbf{Time} \\
\hline
Full Pairing & 1.6218 ms \\
Miller Loop & 0.6931 ms \\
Final Exponentiation & 0.9287 ms \\
G1 Mixed Addition (Affine + Jacobian) & 672 ns \\
G1 Point Doubling (2P) & 414 ns \\
G2 Mixed Addition (Affine + Jacobian) & 2143 ns \\
G2 Point Doubling (2P) & 1302 ns \\
\hline
Estimated G1 Scalar Mult (255-bit) & 191.59 $\mu$s \\
\emph{\small(255 doublings + ~128 additions)} & \\
Estimated G2 Scalar Mult (255-bit) & 606.01 $\mu$s \\
\emph{\small(255 doublings + ~128 additions)} & \\
\hline
\end{tabular}
\caption{Performance metrics for arkworks BLS12-381 implementation. Scalar multiplication estimates assume naive double-and-add implementation without optimizations.}
\label{tab:arkworks-performance}
\end{table}
\footnotetext{The G1 and G2 scalar multiplication estimates are derived using a naive double-and-add implementation analysis for 255-bit scalars. For a random scalar $k$, we assume approximately 255 doubling operations (one per bit) and 128 addition operations (corresponding to an expected Hamming weight of $\frac{255}{2}$ for a random scalar). The G1 estimate of 191.59$\mu$s is computed as $(255 \times 414\text{ns}) + (128 \times 672\text{ns})$ using the measured doubling and mixed addition timings. Similarly, the G2 estimate of 606.01$\mu$s is computed as $(255 \times 1302\text{ns}) + (128 \times 2143\text{ns})$. These estimates represent upper bounds as they do not account for common optimizations such as windowing methods, NAF (Non-Adjacent Form) representations, or parallel computation strategies.}


\newpage
\subsection{Research Questions}
\textbf{Main Research Question: }

\textit{How can credential systems be designed to maintain accountability and sybil resistance with privacy and unlinkability. }

\noindent \textbf{Sub Research Questions}

\textit{How can we design a privacy-preserving credential system that enables hidden linking of government and private credentials while maintaining provable provenance and revocability?}

\textit{How can we efficiently combine credentials for verification while retaining their security properties}


\subsection{Methods}

\subsubsection{Notation}
Let $a : \N \mapsto \N \bigcup \{*\}$ and $b : \N \mapsto \N$ be any functions for which $a(\lambda)$ and $b(\lambda)$ are computable in $poly(\lambda)$ time (expect when $a$ takes value $*$).
\begin{definition}
    A function family $F_{(\cdot)}(\cdot) : \bit^{a(\lambda)} \mapsto \bit^{b(\lambda)}$ is a family of $VRFs$ if there exists a PPT algorithm $Gen$ and deterministic algorithms $Prove$ and $Ver$ such that $Gen(\secparam)$ outputs a pair of keys $(sk, pk)$, $Prove_{sk}(x)$ computes $(y, \pi)$ where $\pi$ is the proof of correctness, and $Ver_{pk}(x,y,\pi)$ verifies that $y = e(g,g)^{1/x+sk}$ using the proof $\pi = g^{1/x+sk}$
\end{definition}

\subsubsection{Notation - another version}
A probabilistic polynomial time algorithm $\algo(\ins) \rightarrow \out$ receives an input $\ins$ and returns an output $\out$. $r \getsrand \Zp$ r is sampled uniformly from the set of field elements modulo $p$,  $h \gets y$ is a deterministic assignment. $[n]$ denotes a sample space of $\{1,\dots,n\}$. We assume type 3 bilinear pairings, $e: \G_1 \times \G_2 \to \G_t$ over groups of prime order $p$, $g, \tilde{g}$ are uniformly chosen generators for $\G_1, \G_2$ such that $e(g, \tilde{g}) = g_t$. We use bold variables to denote vectors as \vect{m} = $[m_1, \dots, m_{\ell}]$, \textbf{g} $\in \G^{\ell}$, \textbf{x} $\in \Z_p^{\ell}$, $\textbf{g}^{\textbf{x}}$ = $\sum\nolimits_{i=1}^\ell g_i^{x_i}$. We use multiplicative notation for $\G$ points i.e. $g^k = g \cdot g \;  (k \text{ times})$

\subsubsection{Pseudo Random Function}
We use the properties of a pseudo-random function to derive the relationship between a master and context credential. The pseudorandomness property ensures the output $y$ is computationally indistinguishable from random and thus hides the relationship between the user's secret key $sk$ and an input $x$ which could be the context of the new credential we want to privately link to.
\[
    PRF_{sk}(x) \to y
\]

\begin{definition}[Pseudo Random Function]
    A PRF is a couple of algorithms $(PRF.Gen, f)$ with key space $\setK$, input space $\setX$ and output space $\setY$ such that 
    \begin{itemize}
        \item $Gen(\secparam) \to (sk): s \sample S$, sets $sk = s$
        \item $f:$ $\mathcal{K} \times \mathcal{X} \to \mathcal{Y}$ is a keyed function family
    \end{itemize}
\end{definition}

The main security property of a $PRF$ is pseudorandomness, which informally states the output should appear random and not be able to be guessed. Formally, defined as

\begin{definition}[Pseudorandomness]
    A couple of PPT algorithms $(PRF.Gen, f)$ is a \textit{Pseudo Random Function} if, for any $\PPT$ adversary $\adv$ there exists a negligible function $\epsilon$ such that 
    \[
    \advantage{}{}[(\adv)] := 
        \left|
    \Pr     \left[ 
                \mathsf{Exp}^{\mathsf{prf}}(\adv) = 1
            \right] - \frac{1}{2}
        \right| \leq \epsilon(\lambda)
    \]
\end{definition}

\begin{figure}
\begin{pchstack}[boxed, center, space=1em]
    \procedure[]{$\mathrm{Exp}^{\mathsf{prf}}(\adv)$}{%
        b \sample \bit \\
        \text{Sample } k \sample PRF.Gen(1^{\lambda}) \\
        \text{Sample } f^* \sample \{g : g : \mathcal{X} \to \mathcal{Y}\} \\
        \text{Run } b' \gets \adv^{\oracle_{\mathsf{prf}}}(1^{\lambda}) \\
        \pcreturn b == b'
    }
    \procedure[]{$\oracle_{\mathsf{prf}(x)}$}{%
        \pcif b = 1 \\
        \t \pcreturn f_k(x) \\
        \pcelse \\
        \t \pcreturn f^*(x)
    }
\end{pchstack}
  \caption{The pseudorandomness game with adversary $\adv$ and PRF $(PRF.Gen, f)$}
  \label{fig:prf}
\end{figure}


\begin{definition}[Computational Indistinguishability] \\
    Let $X = \{X(a,n)\}_{a \in \{0,1\}^*; n \in \mathbb{N}}$ and $Y = \{Y(a,n)\}_{a \in \{0,1\}^*; n \in \mathbb{N}}$ be two probability ensembles, where:
    \begin{itemize}
        \item Each ensemble is an infinite sequence of random variables
        \item $a \in \{0,1\}^*$ represents parties' inputs
        \item $n \in \mathbb{N}$ represents the security parameter
    \end{itemize}
    
    $X$ and $Y$ are said to be computationally indistinguishable, denoted by $X \stackrel{c}{\equiv} Y$, if for every non-uniform polynomial-time algorithm $D$ (called a distinguisher), there exists a negligible function $\mu(\cdot)$ such that for every $a \in \{0,1\}^*$ and every $n \in \mathbb{N}$:
    
    \[ |\Pr[D(X(a,n)) = 1] - \Pr[D(Y(a,n)) = 1]| \leq \mu(n) \]
    
    \end{definition}
    
    \begin{remark}
    This definition captures the idea that no efficient algorithm can tell the difference between samples from $X$ and samples from $Y$ with non-negligible probability. The term "non-uniform" allows the distinguisher $D$ to have hard-coded advice that may depend on the input length, potentially making it more powerful.
    \end{remark}

\begin{definition}[Bilinear map]
    Let $\mathbb{G}_1$, $\mathbb{G}_2$ and $\mathbb{G}_T$ be cyclic groups of prime order $p$, where $\mathbb{G}_1$ and $\mathbb{G}_2$ are multiplicative and $\mathbb{G}_T$ is multiplicative. Let $g$ and $h$ be generators of $\mathbb{G}_1$ and $\mathbb{G}_2$, respectively. We call $e : \mathbb{G}_1 \times \mathbb{G}_2 \rightarrow \mathbb{G}_T$ a bilinear map or pairing if it is efficiently computable and the following holds:
    
    \textbf{Bilinearity:} $e(g^a, \tilde{g^b}) = e(g, \tilde{g})^{ab} \quad \forall a,b \in \mathbb{Z}_p$.
    
    \textbf{Non-degeneracy:} $e(g, \tilde{g}) \neq 1_{\mathbb{G}_T}$, i.e., $e(g, \tilde{g})$ generates $\mathbb{G}_T$.
    
   \noindent If $\mathbb{G}_1 = \mathbb{G}_2$, then $e$ is symmetric (Type-1) and asymmetric (Type-2 or 3) otherwise. For Type-2 pairings, there is an efficiently computable isomorphism $\Psi : \mathbb{G}_2 \rightarrow \mathbb{G}_1$ but none from $\mathbb{G}_1 \rightarrow \mathbb{G}_2$; for Type-3 pairings, no efficiently computable isomorphisms between $\mathbb{G}_1$ and $\mathbb{G}_2$ are known. Type-3 pairings are currently the optimal choice in terms of efficiency for a given security level.
\end{definition}

\begin{definition}[Commitment scheme]
    A commitment scheme is a tuple $(\mathsf{Setup}, \mathsf{Commit}, \mathsf{Open})$ of PPT algorithms where:
    
    \begin{itemize}
        \item $\mathsf{Setup}(1^\lambda) \to \mathsf{ck}$ takes security parameter $\lambda$ (in unary) and generates the commitment key $\mathsf{ck}$;
        
        \item $\mathsf{Commit}_{\mathsf{ck}}(m) \to (\cm, r)$ obtains commitment $\cm$ from secret message $m$ and an opening key $r$ which may be the randomness used in the computation.
        
        \item $\mathsf{Open}_{\mathsf{ck}}(\cm; m, r) \to b \in \{0, 1\}$ verifies the opening of the commitment $\cm$ to the message $m$ provided with the opening hint $r$, outputting a decision as to whether $\cm$ commits to $m$. 
    \end{itemize}
\end{definition}

\begin{definition}[Secret Sharing]
    A $(t,n)$ secret sharing scheme $\mathsf{SS}$ is a tuple of $\PPT$ algorithms $(\mathsf{Share}, \mathsf{Combine})$ over message space $x \in X$:
    \begin{itemize}
        \item $\mathsf{Share}^{t,n}(x, r) \torand ([x]_1, \dots, [x]_n)$ takes input $x \in X$, randomness $r$ and outputs $n$ shares $([x]_1, \dots, [x]_n)$
        \item $\mathsf{Combine}^{t,n}([x]_i, \dots, [x]_t) \to x'$ takes a threshold of secret shares $[x]_i$ for $i > t$ as input and combines to form $x'$ the representation of the original message $x' \in X$
    \end{itemize}
\end{definition}

\begin{definition}[Threshold Public-Key Encryption]
A Threshold Public-Key Encryption Scheme $\mathsf{TPK}$ is a set of $\PPT$ algorithms $\mathsf{(KeyGen, Enc, Dec, Verify, Combine)}$ over $\messagespace$: 
    \begin{itemize}
        \item $\mathsf{TPK.Setup}(\secparam, n, t) \torand \{\pk, \vk, (\sk_1, \dots, \sk_n)\}:$ input the $t$ of $n$ threshold, output $\pk$ the public key, $\vk$ the verification key, and $\sk_i$ the shared secret key for each party.
        \item $\mathsf{TPK.Enc}(\pk, m, \rho) \torand \beta:$ input message $m$ and randomness $\rho$, output encryption $\beta$
        \item $\mathsf{TPK.Dec}(\beta, \sk_i)) \to m_i:$ each party decrypts $\beta$ with their shared secret key $\sk_i$
        \item $\mathsf{TPK.Verify}(\pk, \vk , m_i) \to  \bit:$ input $\pk, \vk$ and share of $m_i$, verify $m_i$ was computed correctly from $\pk, \vk$
        \item $\mathsf{TPK.Combine}(\pk, \vk, {m_i}_{i \in \setspace \subseteq [n] s.t. |\setspace| \geq t + 1}) \to m:$ recovers message $m$ given $t + 1$ partial decryptions which verify successfully
    \end{itemize}
\end{definition}


\begin{definition}[Homomorphism]
    Let $G$ and $H$ be groups. A function $\phi: G \to H$ is called a \textit{homomorphism} if it preserves the group operation. Specifically, for any elements $a, b \in G$, the following equation holds:
    
    \[\phi(a \ast b) = \phi(a) \circ \phi(b)\]
    
    where $\ast$ denotes the group operation in $G$ and $\circ$ denotes the group operation in $H$.
    \end{definition}
    
    \begin{remark}
    Note that $\phi$ is not required to be injective (one-to-one) or surjective (onto).
    \end{remark}
    
    \begin{definition}
    For a homomorphism $\phi: G \to H$, the \textit{image} of $\phi$ is defined as:
    
    \[\operatorname{Im}(\phi) = \phi(G) = \{\phi(g) : g \in G\} \subseteq H\]
    \end{definition}

    \begin{definition}[Image of homomorphism]
        For a homomorphism $\phi: G \to H$, the \textit{image} of $\phi$ is defined as:
        
        \[\operatorname{Im}(\phi) = \{h \in H \mid \exists g \in G \text{ such that } \phi(g) = h\}\]
        
        \end{definition}

        \begin{remark}
            The image of a homomorphism $\phi: G \to H$ can be thought of as the "landing spot" in $H$ for elements coming from $G$. It's the subset of $H$ that includes all possible outputs when $\phi$ is applied to any element in $G$. In essence, $\operatorname{Im}(\phi)$ tells us which elements of $H$ are "reachable" through $\phi$ from some element in $G$.
        \end{remark}





\newpage
\subsubsection{Verifiable Random Function}

\subsubsection{Syntax}
\begin{itemize}
    \item $Gen(\secparam) \to (sk, pk):$ samples $s \sample \Zp^*$, sets $sk = s$ and $pk \gets g^s$, returns $(sk, pk)$
    \item $Prove_{sk}(x) \to (y, \pi):$ $y \gets e(g,g)^{1/(x+sk)}$, $\pi \gets g^{1/(x+sk)}$ where $y$ is the $PRF$ output and $\pi$ is the proof of correctness
    \item $Verify_{pk}(x, y, \pi) \to \bit$ to verify $y$ was computed correctly, verify $e(g^x \cdot pk, \pi) = e(g,g)$ and $y = e(g, \pi)$, output 1 for success, 0 for fail
\end{itemize}

\begin{definition}[Verifiable Random Function]

    A PRF is a triplet of $\PPT$ algorithms $(VRF.Gen, VRF.Eval, VRF.Vfy)$ satisfying:
    \begin{enumerate}
        \item Correctness: For any $(pk, sk)$ in the image of $VRF.Gen(\secparam)$ and any $x \in \setX$
        \[
        \begin{aligned}
            (y, \pi) &\gets VRF.Eval_{sk}(x) \\
            1 &\gets VRF.Vfy_{pk}(x, y, \pi)
        \end{aligned}
        \]


    \item Unique Provability: For any $pk$ (not necessarily in the range of $VRF.Gen$, any input $x \in \setX$, pair of outputs $y_0, y_1 \in \setY$ and pair of proofs $\pi_0, \pi_1$ the following holds
    \[
        \begin{aligned}
            1 &\gets VRF.Vfy_{pk}(x,y_0,\pi_0) \\
            1 &\gets VRF.Vfy_{pk}(x,y_1,\pi_1) \\
            y_0 &= y_1
        \end{aligned}
    \]

    \item Pseudorandomness: For any $\PPT$ adversary $\adv$ running the VRF Experiment, there exists a negligible function $\epsilon$ such that 
    \[
         \advantage{}{}[(\adv)] := 
            \left|
        \Pr     \left[ 
                    \mathsf{Exp}^{\mathsf{rnd}}(\adv) \to 1
                \right] - \frac{1}{2}
            \right| \leq \epsilon(\lambda)
    \]
    
    \end{enumerate}

\end{definition}

\begin{figure}
\begin{pchstack}[boxed, center, space=1em]
    \procedure[]{$\mathrm{Exp}^{\mathsf{eval}}(\adv)$}{%
        \text{Sample } b \sample \bit \\
        pk, sk \sample VRF.Gen(1^{\lambda}) \\
        \text{set } x^* = \bot \\
        x^* \gets \adv^{\oracle_{\mathsf{eval}}}(pk) \\
        \pcif x^* \text{was previously queried:} \\
        \t \pcreturn 0 \\
        y_0 \sample \setY \\
        (y_1, \pi) \gets VRF.Eval(pk, x^*) \\
        \adv^{\oracle_{\mathsf{eval}}}(sk, y_b) \to b' \\
        \pcreturn b == b'
    }
    \procedure[]{$\oracle_{\mathsf{eval}(x)}$}{%
        \pcif x \neq x^* \\
        \t (y, \pi) \gets VRF.Eval_{sk}(x) \\
        \t \pcreturn (y, \pi) \\
        \pcelse: \pcreturn \bot \\
    }
\end{pchstack}
  \caption{The pseudorandomness game with adversary $\adv$ and PRF $(PRF.Gen, f)$}
  \label{fig:prf}
\end{figure}



% \newcommand{\vt}{\mathsf{vt}}
% \newcommand{\wx}{\mathsf{wx}}
% \newcommand{\wxone}{\mathsf{w_1x}}
% \newcommand{\wxtwo}{\mathsf{w_2x}}
% \newcommand{\wxhat}{\mathsf{\hat{w}x}}
% % \newcommand{\x}{\mathsf{x}}

% \newcommand{\acu}{\mathsf{ACU}}
% \newcommand{\acusetup}{\mathsf{ACU.Setup}}
% \newcommand{\acuadd}{\mathsf{ACU.Add}}
% \newcommand{\acudel}{\mathsf{ACU.Del}}
% \newcommand{\acuvermem}{\mathsf{ACU.VerMem}}
% \newcommand{\acuvernonmem}{\mathsf{ACU.VerNonMem}}


% \newcommand{\rev}{\mathsf{REV}}
% \newcommand{\revsetup}{\mathsf{REV.Setup}}
% \newcommand{\revrevoke}{\mathsf{REV.Revoke}}
% \newcommand{\revtokengen}{\mathsf{REV.TokenGen}}
% \newcommand{\revtokenver}{\mathsf{REV.TokenVer}}

% \newcommand{\rt}{\mathsf{rt}}

\subsection{Revocation}
Credential revocation is a fundamental challenge in identity management systems. While credentials grant users access to services, there must be mechanisms to invalidate them when necessary. Since the introduction of public key infrastructure, numerous solutions have been proposed to handle certificate revocation such as time-based expiration, usage limits (k-times use), and revocation lists. In the latter approach, a trusted authority manages a whitelist of valid credentials or blacklist of revoked ones, requiring users to prove their credential status with respect to the list.

The challenge becomes more complex in privacy-preserving systems as users must be able to prove revocation status without revealing the credential or its attributes. Furthermore, the revocation list should not leak information about which credentials are valid or revoked. 

\subsubsection{Revocation Scheme}
A revocation scheme enables efficient proofs of credential validity while maintaining privacy of the revocation status. The scheme consists of a revocation authority that manages the revocation state, protocols for revoking credentials, and methods for users to prove their credentials remain valid. A privacy-preserving revocation scheme must satisfy several properties:

\begin{itemize}
    \item Privacy: Users can prove their credential's status without revealing the credential
    \item Unlinkability: Multiple proofs by the same user cannot be linked
    \item Efficiency: Proofs should be succinct and verification efficient
    \item Dynamic Updates: The system supports real-time credential revocation
\end{itemize}

\paragraph{Syntax}
A revocation scheme consists of the following algorithms:

\begin{itemize}
    \item $\revsetup(\secparam) \torand (\ppar, \sk, \pk, \vt):$ Given security parameter $\secparam$, generates system parameters $\ppar$, authority's secret key $\sk$, public key $\pk$, and initial revocation state $\vt$
    
    \item $\revrevoke(\sk, \vt, \cred) \to (\vt', \text{RI}):$ Revokes credential $\cred$, updates revocation state from $\vt$ to $\vt'$, and outputs revocation information RI
    
    \item $\revtokengen(\cred, \vt, \text{RI}) \to \rt:$ Generates a revocation token $\rt$ for credential $\cred$ using the current revocation state $\vt$ and revocation information RI
    
    \item $\revtokenver(\vt, \cred, \rt) \to \bit:$ Verifies revocation token $\rt$ for credential $\cred$ against revocation state $\vt$
\end{itemize}

\subsubsection{Accumulator}
An accumulator allows for compact representation of a set while enabling efficient proofs of membership. Our construction uses a universal accumulator that supports both membership and non-membership proofs. The accumulator maintains a constant-size value regardless of the number of elements in the set, while allowing elements to be dynamically added and removed. For each element, the system can generate succinct witnesses that prove either membership or non-membership in the accumulated set.

\subsubsection{Syntax}
An accumulator $\acu$ is a set of $\PPT$ algorithms $\acu = \mathsf{Setup, Add, Del, VerMem, VerNonMem}$. 
\begin{itemize}
    \item $\acusetup(\secparam) \torand \ppar, \sk, \pk, \vt:$ generates system parameters, takes security parameter $\secparam$ as input, outputs system parameters $\ppar$, secret key $\sk$, public key $\pk$, and initial accumulator value $\vt$
    
    \item $\acuadd(\sk, \vt, \x) \to (\vt', \wx):$ adds element $\x$, takes secret key $\sk$, current accumulator value $\vt$, element $\x$ as input. Outputs updated accumulator value $\vt'$, and membership witness $\wx$
    
    \item $\acudel(\sk, \vt, \x) \to (\vt', \wxhat):$ Deletes element $\x$, takes secret key $\sk$, current accumulator value $\vt$, element $\x$ as input. Outputs updated accumulator value $\vt'$, non-membership witness $\wxhat$ 
    
    \item $\acuvermem(\vt, \x, \wx) \to \bit:$ verifies membership, takes current accumulator value $\vt$, element $\x$, witness $\wx$ as input. Outputs accept/reject
    
    \item $\acuvernonmem(\vt, \x, \wxhat) \to \bit:$ Verifies non-membership, takes current accumulator value $\vt$, element $\x$, non-member witness $\wxhat$ as input. Outputs accept/reject
\end{itemize}

 with additional witness operations $\mathsf{MemWitUpOnAdd/Del, NonMemWitUpOnAdd/Del}$ 


 \subsection{Discussion}
 
The Internet Identity Workshop discussed a problem space summarised by the following problems:
\begin{enumerate}
    \item issuing credentials that are both government and privately issued
    \item retaining accountability in derived credentials, ensuring derived credentials are fit for purpose and have revocation (Proveable Provenance, Linked Data)
    \item combining traditional digital identity with decentralized identity
\end{enumerate}

A user has an Identity linked to multiple credentials, such as a driver's license and university card. Users want to authenticate with various Relying Parties (Verifiers) without being linked between multiple uses of the same service (e.g. a user verifying multiple credentials with 1 service such as a bank requiring proof of multiple credentials linked to an identity), and between uses of different services (e.g. a user presenting their drivers license for age verification on multiple services).

Current decentralized identity systems either don't provide this functionality or provide it at the expense of either accountability or privacy. CanDID stores a map between users multi-layered credentials providing a solution to the problem at the expense of the user's privacy. Other credential systems and pseudonym systems prove equality of hidden attributes in a credential such as name or id, which can more-easily be forged and does not support the hierarchical structure leveraging a highly secure and accountable government identity with not-so secure private credentials.


\noindent \textbf{Credential Chaining}


\noindent \textbf{Pseudonym Systems}
There are 2 main models for Pseudonyms. One where the user has a Master Credential and derives pseudonym, or context credentials from the Master Credential. The applications differ; for example, in \textbf{Model 1}, a user may have their Passport as their Master Credential and wish to use it in a different scenario, such as voting for an election. The user will derive, by themselves, a new credential with the context "voting-2024," which will be verified in the same way as the master credential.
\textbf{Model 2} differs in application scenarios. A context credential represents a credential from a different issuer, for example, a driver's license. During Context Credential issuance, a user will present their Master Credential which will be used to verify the identity of a user and to link the 2 credentials together. During context credential verification, the user may be requested to present just their Context Credential, or perhaps in a high-security verification setting, where a user may need to prove attributes in multiple credentials both Master and Context will need to be presented together. We optimize for this setting while \emph{preserving privacy.}



\noindent \textbf{Pseudonym Model 1: Master Credential, One Issuer, derived Pseudonyms}

SyRA and TACT optimize for Non-Interactivity
They also define context differently to us. Which isn't what CanDID defines context as and doesn't work for the same usescases and CanDID was defined for. 

Previous Methods

\noindent SyRA: Sybil-Resilient Anonymous Signatures  with Applications to Decentralized Identity \cite{crites_syra_2024}
1. enables users to "derive" unlinkable, sybil resistant pseudonyms (signatures) for a context e.g. PRF(sk, ctx) without interacting with the issuer
2. does not store a mapping on the issuer
3. Security properties: Sybil resistance in the context. Anonymity: no information is leaked through their nyms or signatures. Proves UC security for unforgeability, Sybil resilience, privacy, and unlinkability
4. SyRA leaves support for Identity Attributes for future work.

Summary: First, a protocol with issuer creates a user with secret key $s$. $s$ generates a context specific pseudonym, or tag $T$ "that attaches itself to a signature"?

\begin{itemize}
    \item Level 1: $Issue_{isk}(s)$: $VRF_{isk}(s) \to T, \pi_{prf}$ such that $\pi_{prf}$ generates the users keys and is symmetric across $\G_1, \G_2$: This algorithm is computed by the issuer with their secret key $isk$ on identity string $s$ Outputs $T = e(g, \tilde{g})^{1/(s + isk)}$ and $\pi_{prf}$ is $usk = g^{1/(s + isk)} \in \G_1$ and $\widehat{usk} = \tilde{g}^{1/(s + isk)} \in \G_2$. Their verify algorithm is the same as the Dodis Yampolskiy and also verifies the asymmetric keys with bilinear pairing.
    \item Level 2: $Sign_{usk, \widehat{usk}}(ctx, m, ivk)$: $VUF_{usk}(ctx) \to T = e(H(ctx), \widehat{usk})$: This is the "sybil resistant signature". Proof of correctness comes from sigma protocol. During the verify protocol, the 
\end{itemize}

Conclusion: SyRA creates a signature scheme where a user can "sign" on $ctx, m$ from their secret key based on a VRF of their identity and the issuer's key. This does not account for Attribute-based credentials.

Attribute-Based Threshold Issuance Anonymous Counting Tokens \cite{rabaninejad_attribute-based_nodate}
What don't they do that we do?
We avoid Groth Sahai proofs - page 26 they refer to proving the signature scheme with GS proofs. 
They use Naor Pinkas Reingold PRF and verify signature with GS proofs. 
They focus only on deriving credentials / pseudonyms from their

\noindent \textbf{Pseudonym Model 2: Master Credential, Multiple Issuers, Different Pseudonyms}
The Pseudonym Model \cite{goos_pseudonym_2000} presents as an interaction between a User, a Certificate Authority (CA), and a Pseudonym Organisation (O). The user's identity is registered to the CA with their keypair $skU, pkU$, receiving a Master Credential to act as a trust anchor for all pseudonyms. With their Master Credential, Users request \emph{unlinkable} Pseudonyms for other organizations by first proving the knowledge of a Master Credential that verifies with the CA, and the pseudonym requested has the same keypair as the Master Credential. Organizations \emph{blindly} issue Pseudonym credentials on the same keypair as the Master Credential.


\begin{itemize}
    \item \textbf{$MasterCredIssue(skU, pkU, identity, skCA) \to CredM$} is an interactive algorithm run by a user and a credential authority with keypair $skCA, pkCA$. The user is known to the CA and shares their identity and a keypair $skU, pkU$. The $CA$ checks the $skU, pkU$ relation and issues $CredM$, a signature $\sigma_{CA} \gets Sign_{skCA}(pkU)$
    
    \item \textbf{$NymGeneration(CredM, pkCA, Nym, skO) \to CredNym$} is an interactive algorithm run by a user and an organization the user wishes to create a pseudonym with. 
    $Nym1$ is a commitment $Com(skU, pkU, r)$ with randomness $r$, $r$ should be unique per pseudonym. 
    $U$ generates a zero-knowledge proof of knowledge of a new pseudonym $Nym1$ with $skU, pkU$ corresponding to $CredM$, $CredM$ verifies correctly, and $pkU, skU$ are related. 
    \[
    \begin{aligned}
    ZKP
    \{ 
        (skU, pkU, r): Nym &= Com(skU, pkU, r) \; \wedge \\
        Verify_{pkCA}(CredM) &= 1 \; \wedge \\ 
        pkU &= g^{skU}
     \}
    \end{aligned}
    \]
    On successful ZKP verification, algorithm outputs $CredNym \gets Sign_{skO}(Nym)$

    \item \textbf{$NymVerify(CredNym, pkO) \to \bit $} is an interactive algorithm run by a user and a verifier. Recall $CredNym$ is a signature over a commitment $Sign_{skO}(Nym)$. The user randomizes $CredNym' \gets CredNym$ and $Nym' \gets Com(skU, pkU, r)$, and in zero knowledge, proves $CredNym$ verifies correctly with respect to the original signature, and the organisation public key
        \[
        \begin{aligned}
        ZKP
        \{  
            (skU, pkU, r, r'): Nym' &= Com(skU, pkU, r') \; \wedge \\
            \exists \; Nym \text{ such that } Verify_{pkO}(Nym) &= 1 \; \wedge \\ 
            Nym &= Com(skU, pkU, r) \; \wedge \\
            pkU &= g^{skU}
        \}
        \end{aligned}
        \]
\end{itemize}




\newpage
\subsection{NIZK for Sybil Resistant Issuance}
We have $g^{\frac{1}{m}}$ and $g^m$. We want to prove their relationship is reciprocal. We will use this later when proving the output of the Dodis Yampolskiy VRF $g^{\frac{1}{sk + x}}$
Let $m_1 = m$, and $m_2 = \frac{1}{m}$. Therefore, we can prove that $m_1 \cdot m_2 = 1$ 
\[ 
    \begin{aligned}
        C_1 &= g^{m_1}h^{r_1} \\
        C_2 &= g^{m_2}h^{r_2} \\
        C_3 &= C_1^{m_2}h^{r_3} \\ 
        C_4 &= h^{r_1m_2 + r_3} \\ 
    \end{aligned}
\]

We use $C_1, C_2$ in a zero-knowledge proof protocol to prove the relation with public elements $C_1, C_2, g, h$

\[
ZKP
    \left\{ 
    (m_1, m_2, r_1, r_2): C_1 = g^{m_1}h^{r_1} \wedge C_2 = g^{m_2}h^{r_2} \wedge m_1 \cdot m_2 = 1
    \right\}
\]

\pcb{
\prover[m_1, m_2, r_1, r_2] \< \< \verifier[C_1, C_2, g, h]  \\[0.1\baselineskip][\hline]
\<\< \\[-0.5\baselineskip]
\pclinecomment{$C_1 = g^{m_1}h^{r_1}, C_2 = g^{m_2}h^{r_2}$} \\
{\{\rho_i\}_{i=1}^4, \{\beta_i\}_{i=1}^2}  \sample \mathbb{Z}_q^6 \<\< \\
T_1 \gets g^{\beta_1}h^{\rho_1} \<\< \\
T_2 \gets g^{\beta_2}h^{\rho_2} \<\< \\
\pclinecomment{generate interim elements} \\
C_3 \gets C_1^{m_2}h^{r_3} \<\< \\
T_3 \gets C_1^{\beta_2}h^{\rho_3} \<\< \\
r_4 \gets r_1m_2 + r_3 \<\<  \\
C_4 \gets h^{r4} \<\< \\
T_4 \gets h^{\rho_4} \<\< \\
\< \sendmessageright* {\{C_i, T_i\}_{i=1}^4} \< \\
\< \sendmessageleft*{e} \< e \sample \mathbb{Z}_q \\
z_{m1} = \beta_1 + e \cdot m_1 \<\< \\
z_{r1} = \rho_1 + e \cdot r_1 \<\< \\
z_{m2} = \beta_2 + e \cdot m_2 \<\< \\
z_{r2} = \rho_2 + e \cdot r_2 \<\< \\
z_{r3} = \rho_3 + e \cdot r_3 \<\< \\
z_{r4} = \rho_4 + e \cdot r_4 \<\< \\
\< \sendmessageright*{\{z_{mi}\}_{i=1}^2, \{z_{ri}\}_{i=1}^4 } \< \\
\<\< C_1^e \cdot T_1 \stackrel{?}{=} g^{z_{m1}} h^{z_{r1}}\\
\<\< C_2^e \cdot T_2 \stackrel{?}{=}  g^{z_{m2}} h^{z_{r2}}\\
\<\< C_3^e \cdot T_3 \stackrel{?}{=}  C_1^{z_{m2}} h^{z_{r3}}\\
\<\< C_4^e \cdot T_4 \stackrel{?}{=}  h^{z_{r4}}\\
\<\< C_3/C_4 = g \\
}


% \begin{construction}{Opening Proof($C$)}{test}
%     \vspace{1em}
%     \textbf{Public parameters:} $g, h \in \G$

%     \textbf{Inputs:} $C$ such that $C = g^mh^r$, $\Prover$ knows $m, r \in \Z_q$.
%     \vspace{1em}
%     \begin{enumerate}
%         \item $\Prover$ samples $\alpha_1, \rho_1 \sample [q-1]$ and sends $T \gets g^{\alpha_1}h^{\rho_1}$
        
%         \item $\Verifier$ sends challenge $c \sample [q-1].$
    
%         \item $\Prover$ sends $s_1 \gets \alpha_1 + cm, s_2 \gets \rho_1 + cr$
    
%         \item $\Verifier$ verifies that $g^{s_1}h^{s_2} = C^cT$
%     \end{enumerate}
% \end{construction}

% \begin{theorem}
%     Construction \ref{construct:openproof} is a $\Sigma-$protocol for the relation
%     \[
%     \mathcal{R} = \left\{ (C,g,h,q),(m,r) \; | \; C = g^{m}h^r \right\}
%     \]
    
% \end{theorem}
% \begin{proof}
%     It follows from \cite{wahby_doubly-efficient_2018, schnorr_efficient_1991}
% \end{proof}