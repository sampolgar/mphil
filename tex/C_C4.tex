\mychapter{Credential Relationship Binding Nullifier: Problem and Motivation}

\section{Sybil Resistant Anonymous Credentials}
Anonymous Credentials are employed in Identity Systems and Private Payment systems where the credential owner requires privacy, but the system requires resistance against Sybil Attacks. Privacy and Sybil Resistance are paradoxical in nature as privacy demands the system know as little about the credential as possible, and protecting against Sybil Resistance requires the system to be accountable for the credentials, for example, to prevent multiple credentials for the same attributes be issued, preventing system misuse. 

In non-private systems, a user with a credential would have a credential identifier representing the unique issuance of the credential to the user. Similarly, a cheque or bank transfer has an identifier associated with it to prevent fraudulent multi-time use. In privacy-based systems, nullifiers are used in the same context. Nullifiers are deterministic functions based on the credential or credential attributes that are used to improve privacy. For example, a nullifier generated from a credential can be used 

 Verifiable Random Functions (VRFs) offer a promising solution by enabling the generation of verifiably pseudorandom and deterministic nullifiers from user-specific information, suitable for presentation to an issuer or for revocation lists. Existing VRF-based schemes often rely on computationally intensive bilinear pairings or reveal user attributes, introducing overhead or privacy risks.


\subsection{Contributions}

\noindent We improve the state of the art by creating a lightweight VRF construction tailored for Anonymous Credential systems with 3 contributions:
\begin{enumerate}
        \item \textbf{Pairing-Free VRF in Prime-Order Groups:} We adapt the Dodis-Yampolskiy VRF structure to function efficiently in standard prime-order groups, achieving provable pseudorandomness under the $q$-Diffie-Hellman Inversion ($q$-DHI) assumption. We show that VRF evaluation is 33\% faster and verification is 60\% faster than previous constructions.

        \item \textbf{Zero-Knowledge Proof of Multiplicative Inverse:} We introduce a novel $\Sigma$-protocol that proves the multiplicative inverse relation between committed values $m_1 = k + \textsf{ctx}$ and $m_2 = 1/m_1$, we use it in our scheme to verify the correctness of the VRF nullifier without revealing user secrets. We show it generalizes naturally for similar requirements in $\Sigma$-protocols, especially those needing to prove the q-DHI.

         \item \textbf{Formal Security Guarantees:} maintains \emph{Pseudorandomness} of the VRF outputs in the indistinguishable outputs, \emph{uniqueness} in one nullifier per $(k, \ctx)$ pair preventing sybil attacks

\end{enumerate}


We first present the preliminaries and foundations of our VRF for committed inputs, the design of our $\Sigma$-protocol, and demonstrate how the integration achieves sybil resistance in anonymous credential systems.

\begin{definition}[Sybil-Resistant Issuance]
For any context $\ctx$, a Context Credential issuer must be able to detect if a user with master credential containing identifier $\id$ has previously obtained a context credential for $\ctx$, without learning $\id$ itself or linking this issuance request to other credential presentations.
\end{definition}

\subsection{Problem}
To understand how we use the VRF within our application, we introduce the application: 
Within our anonymous credential system, a user has a Master Credential with a VRF key $k$ and Context Credential with $\textsf{ctx}$, where $\textsf{ctx}$ is the context, such as $\mathcal{H}(\textit{"dmv"})$ where $\mathcal{H}$ hashes a string to $\Z_p$

\begin{figure}
        \begin{pchstack}[boxed, center, space=4em]
            \begin{pcvstack}
                \procedure[space=auto]{Master}{%
                \id: 12345, \\
                \k: 54321, \\
                \ctx: "master", \\
                \exp: "10/11/2026", \\
                }
            \end{pcvstack}
            \pcvspace
            \begin{pcvstack}
                \procedure[space=auto]{Driver License}{%
                 \id: 12345, \\
                 \ctx: "dmv", \\
                 \exp: "10/11/2028", \\
                }
            \end{pcvstack}
        \end{pchstack}
    \caption{Example Credentials, $\attrs$ holds arbitrary number of attributes such as expiry}
    \label{fig:two-creds}
\end{figure}
A user with these two credentials holds signatures over commitments

\[
\cmm = \mathsf{CM.Com}([\id, \k, \ctx, \exp]; r) = g_1^{\id}, g_2^{\k}, g_3^{\ctx}, g_4^{\exp} g^r \quad \wedge \quad \cmc = \mathsf{CM.Com}([\id, \ctx, \exp]; r_2) = g_1^{\id}g_2^{\ctx}g^{r_2}
\]
During Context Credential issuance, a user must prove to the issuer that their context credential hasn't been issued before, that is, the Context Credential issuance must be \emph{Sybil Resistant}. Our goal is to generate a unique, unlinkable nullifier for a specific context containing something in both the Master Credential and the Context Credential to protect the system from Sybil attacks while also retaining user privacy.

We leverage the structure and properties of the Dodis Yampolisky Verifiable Random Function (VRF)
\[
\text{Nullifier } \textsf{N} = g^{1/k + \textsf{ctx}}
\]

The Nullifier takes on the properties of correctness, pseudorandomness, and provable uniqueness from the VRF which we exploit in our protocol.


\subsection{Preliminaries}

\begin{definition}[q-DHI Assumption]
Let $\mathbb{G}$ be a cyclic group of prime order $p$ with generator $g$. The $q$-Diffie-Hellman Inversion ($q$-DHI) assumption \cite{mitsunari_new_2002} states that for any PPT adversary $\mathcal{A}$, there exists a negligible function $\negl$ such that:
\[
\Pr\left[ x \sample \Zp^*, \quad \mathcal{A}(g, g^x, g^{x^2}, \ldots, g^{x^q}) = g^{1/x} \right] \leq \negl 
\]
where the probability is taken over the random choice of $x$ and the random coins of $\mathcal{A}$. Informally, no $\PPT$ adversary can distinguish between $g^{1/\alpha}$ from a random group element.
\end{definition}

\begin{remark}
The $q$-DHI assumption is equivalent to the $(q+1)$-generalized Diffie-Hellman assumption (GDH) as shown by Boneh and Boyen \cite{kanade_efficient_2004}. This equivalence provides a solid theoretical foundation for our VRF construction's security.
\end{remark}




\begin{definition}[Verifiable Random Function in Prime-Order Group]
A Verifiable Random Function (VRF) in prime-order group $\G$ of order $q$ is a tuple of PPT algorithms $(\mathsf{VRF.Gen}, \mathsf{VRF.Eval}, \mathsf{VRF.Vfy})$ with associated message space $\setX$, output space $\setN$, and proof space $\Pi$, defined as:

\begin{itemize}
    \item $\mathsf{VRF.Gen}(1^\lambda) \to (sk, pk):$ Samples secret key $\alpha \sample \Zp^*$, computes public key $pk \gets g^\alpha$, returns $(sk = \alpha, pk)$
    
    \item $\mathsf{VRF.Eval}(sk, x) \to \textsf{N}, \pi:$ Returns output $\textsf{N} \gets g^{1/(x+sk)}$ and $\pi$ verifies the output $\textsf{N}$
    
    \item $\mathsf{VRF.Vfy}(pk, x, \textsf{N}, \pi) \to \bit:$ validates proof $\pi$ that $\textsf{N} = g^{1/(x+sk)}$, outputs 1 for success, 0 for failure
\end{itemize}
\end{definition}

\begin{itemize}
    \item \textbf{Correctness:} For all $(sk, pk) \gets \mathsf{VRF.Gen}(1^\lambda)$ and all $x \in \setX$:
    \[
    \Pr\left[\begin{aligned}
        (y, \pi) &\gets \mathsf{VRF.Eval}(sk, x) \\
        1 &\gets \mathsf{VRF.Vfy}(pk, x, \textsf{N}, \pi)
    \end{aligned}\right] = 1
    \]

    \item \textbf{Unique Provability:} For any $pk$ (possibly malicious) and $x \in \setX$, no $\PPT$ adversary $\AdvA$ can find two distinct pairs of outputs $(\textsf{N}_0, \pi_0) \neq (\textsf{N}_1, \pi_1)$ such that:
    \[
    \mathsf{VRF.Vfy}(pk, x, \textsf{N}_0, \pi_0) = \mathsf{VRF.Vfy}(pk, x, \textsf{N}_1, \pi_1) = 1
    \]

    \item \textbf{Pseudorandomness:} For every PPT adversary $\AdvA$, there exists negligible function $\negl$ such that:
    \[
    \left|\Pr\left[\mathsf{Exp}_{\mathsf{VRF}}^{\mathsf{PR}}(\AdvA, \lambda) = 1\right] - \frac{1}{2}\right| \leq \negl
    \]
    where the pseudorandomness experiment $\mathsf{Exp}_{\mathsf{VRF}}^{\mathsf{PR}}$ is defined in the standard framework for VRFs.
\end{itemize}


\subsection{Algebraic Analysis of Dodis Yampolskiy VRF}
We first recall the classical Dodis Yampolskiy VRF construction with bilinear pairings, we demonstrate with Type-3 pairings as they are generally used in practice. Let $\G_1, \G_2, \G_T$ be groups of a bilinear map with prime order $p$ where $g_1, g_2$ are generators for $\G_1, \G_2$ respectively and $e$ is an efficient map from $\G_1 \times \G_2 \to \G_T$:

% \begin{itemize}
%     \item $\mathsf{VRF.Gen}(\secparam)$: Samples $k \sample \Z_p$, set $pk = g^k$ 
    
%     \item $\mathsf{VRF.Eval}(k, \ctx) \to $(\mathsf{N}, \pi)$: $\pi = e(g_1, g_2)^{1/(k + \textsf{ctx})}$, $\mathsf{N} = g_2^{1/(k + \textsf{ctx})}$ 
    
%     \item $\mathsf{VRF.Vfy}(pk, \textsf{ctx}, \mathsf{N}, \pi) \to \bit$: assert $\quad$ $e(g^{\textsf{ctx}} \cdot pk, \mathsf{N})  \stackrel{?}{=} e(g_1, g_2) \quad \wedge \quad \pi  \stackrel{?}{=} e(g_1, \mathsf{N})$
% \end{itemize}

$\mathsf{Eval}$ computes the nullifier $\textsf{N}$ and generates a proof $\pi$ to prove that anyone in possession of $pk$ and the input $\textsf{ctx}$ can verify $\textsf{N}$ was computed correctly. $\mathsf{Vfy}$ resembles a signature verification as it binds  the public key $pk$, input $\textsf{ctx}$, and nullifier output together. 

The first pairing binds the public input $pk, \mathsf{ctx}$ with $\mathsf{N}$
\begin{align*}
    e(g_1^\mathsf{ctx} \cdot pk, \mathsf{N})  \quad  \stackrel{?}{=}& \quad  e(g_1, g_2) \\
    e(g_1^\mathsf{ctx}, g_2^{1/(k + \mathsf{ctx})}) \cdot  e(pk, g_2^{1/(k + \mathsf{ctx})}) \quad  \stackrel{?}{=}& \quad  e(g_1, g_2) \\
    e(g_1^\mathsf{ctx}, g_2)^{1/(k + \mathsf{ctx})} \cdot  e(g_1^k, g_2)^{1/(k + \mathsf{ctx})} \quad  \stackrel{?}{=}& \quad  e(g_1, g_2) \\
    e(g_1, g_2)^{\mathsf{ctx}/(k + \mathsf{ctx})} \cdot  e(g_1^k, g_2)^{k/(k + \mathsf{ctx})} \quad  \stackrel{?}{=}& \quad  e(g_1, g_2) \\
    e(g_1, g_2)^{\mathsf{ctx} + k/(k + \mathsf{ctx})}  \quad =& \quad e(g_1, g_2) \\
\end{align*}

\begin{align*}
     \pi  \quad  \stackrel{?}{=}& \quad e(g_1, \mathsf{N}) \\
     e(g_1, g_2)^{1/(k + \textsf{ctx})}  \stackrel{?}{=}& \quad  e(g_1, g_2^{1/(k + \mathsf{ctx})}) \\
     e(g_1, g_2)^{1/(k + \textsf{ctx})}  \stackrel{?}{=}& \quad  e(g_1, g_2)^{1/(k + \textsf{ctx})} \\
\end{align*}

% And the second pairing binds the proof $\pi$ to \mathsf{N}$

\subsubsection{Informal Security analysis of Bilinear Pairing VRF}
\begin{itemize}
    \item \textbf{Correctness:} Follows directly from pairing properties. The algebraic structure ensures verification equations hold when computed honestly.
    
    \item \textbf{Unique Provability:} Each nullifier $\mathsf{N} = g_2^{1/(k+\textsf{ctx})}$ is uniquely determined by the pairing equation $e(g_1^{k + \textsf{ctx}}, \mathsf{N}) = e(g_1, g_2)$. A forgery requires solving DLOG to create  $g_2^{1/(k+\textsf{ctx}')} = \mathsf{N}$.
    
    \item \textbf{Pseudorandomness:} Relies on the $q$-DHI assumption in bilinear groups. Given $g_1, g_1^k, g_1^{k^2}, \ldots$, distinguishing $\mathsf{N} = g_2^{1/(k+\textsf{ctx})}$ from random reduces to computing $g_2^{1/k}$ (a $q$-DHI instance).
\end{itemize}



\subsection{VRF with Committed Inputs}
As demonstrated above, the classical Dodis-Yampolskiy VRF uses pairings to verify the relationship between inputs and outputs through the equation: $e(g_1^{\textsf{ctx}} \cdot pk, \mathsf{N}) = e(g_1, g_2)$. Our key insight is that this pairing equation fundamentally verifies a multiplicative relationship $(k + \textsf{ctx}) \cdot \frac{1}{k + \textsf{ctx}} = 1$:

\begin{align*}
    e(g_1^{\textsf{ctx}} \cdot pk, \mathsf{N}) =& e(g_1, g_2)    \\
    e(g_1^{\textsf{ctx}} \cdot g_1^k, g_2^{1/(k + \textsf{ctx})}) =& e(g_1, g_2) \\
    e(g_1^{\textsf{ctx + k}}, g_2^{1/(k + \textsf{ctx})}) =& e(g_1, g_2) \\
    (\textsf{ctx + k}) \cdot 1/(k + \textsf{ctx})  =& 1 \\
\end{align*}

% This observation suggests an alternative approach: instead of using pairings to verify this relationship, we can prove it directly through a carefully constructed $\Sigma$-protocol. Let:
% \begin{itemize}
%     \item $m_1 = k + \textsf{ctx}$ (committed in $\cm_1$)
%     \item $m_2 = \frac{1}{k + \textsf{ctx}}$ (committed in $\cm_2$)
% \end{itemize}

% The VRF nullifier is then simply $\mathsf{N} = g^{m_2}$, and verification reduces to proving:
% \begin{enumerate}
%     \item $m_1$ is correctly formed from committed values $k$ and $\textsf{ctx}$
%     \item $m_1 \cdot m_2 = 1$ (multiplicative inverse relation)
%     \item $\mathsf{N} = g^{m_2}$ (nullifier structure)
% \end{enumerate}

% This reformulation eliminates the need for pairings while maintaining the security properties of the original VRF. The challenge now becomes constructing an efficient $\Sigma$-protocol that proves these relationships without revealing the underlying values.



% \subsection{Commitment Structure for VRF Verification}
% To privately prove the VRF relationship, we commit to both the input relationship and multiplicative inverse:

% % \begin{itemize}
% %     \item Primary commitments to inputs:
% %         \[\cm_k = g^k h^{r_1}, \quad \cm_{\textsf{ctx}} = g^{\textsf{ctx}} h^{r_2}\]
    
% %     \item Derived commitment to their sum:
% %         \[\cm_3 = \cm_k^{\textsf{ctx}} h^{r_3}
    
% %     \item Commitment to the inverse:
% %         \[\cm_4 = \cm^{m_2} h^{r_4} \text{ where } m_2 = \frac{1}{m_1}\]
% % \end{itemize}

% The algebraic structure of these commitments enables our $\Sigma$-protocol to efficiently prove the multiplicative inverse relationship while maintaining zero-knowledge.


% \subsection{Sigma-Protocol Construction}
% Given these commitments, we construct a $\Sigma$-protocol that proves the VRF relationship in zero-knowledge. The protocol leverages auxiliary commitments $\cm_3, \cm_4$
% to enforce the multiplicative inverse relationship: $\Pi^{\mathcal{R}_{\textsf{VRF}}}$ from 

%     \[
%         \mathcal{R}_{\mathsf{vrf}} = \left\{ (\cm_k, \cm_{\textsf{ctx}}, \mathsf{N}), (k, \textsf{ctx}, r_1, r_2) \; \Big| \;  \cm_k = g^k h^{r_1} \; \land \;
%                 \cm_{\textsf{ctx}} = g^{\textsf{ctx}} h^{r_2} \land \textsf{N} = g^{1/(k + \textsf{ctx})} \right\}
%     \]


\newpage
\begin{protocol}{Non-Pairing VRF Output Verification}{non-pairing-vrf-verify}\label{pok-non-pairing-vrf}
\textbf{Common Input:} Group generators $g_1, g_2, g_3, g_4, g_5, g \in \mathbb{G}$, and commitments $\cm_1, \cm_2, \cm_3, \cm_4, \cm_5, \cm_6 \in \mathbb{G}$\\
\textbf{Prover Input:} Witness $(\id, \k, \ctx, r_1, r_2, r_3, r_4, r_5, \textsf{n}, r_6)$ such that:
    \begin{align*}
        \cm_1 &= g_1^{\id} g_2^{\k} g^{r_1}     &    \cm_2 &= g_1^{\id} g_3^{\ctx} g^{r_2}  &   \cm_3 &= g_4^{\k + \ctx} g^{r_3}\\
        \cm_4 &= g_5^{\textsf{n}} g^{r_4}   &   \cm_5 &= \cm_3^{\textsf{n}} g^{r_5}     &   \cm_6 &= g^{r_6} \\
        \textsf{n} &= \frac{1}{\k + \ctx}   &   r_6 &= r_3 \cdot \textsf{n} + r_5    &   \frac{\cm_5}{\cm_6} &= g_4 \\
    \end{align*}

\begin{enumerate}
    \item \textbf{Commitment:} Prover samples random blinding factors from $\Z_q$:
    \[
        a_x \quad \text{ for } \quad x \in \{\ \id, \k, \ctx, \text{n}, r_1, \ldots,r_6\} \in \Z_q
    \]
    \textbf{Computes}:
    \begin{align*}
        T_1 &\gets g_1^{a_{\id}} g_2^{a_k} g^{a_{r_1}}  &   T_2 &\gets g_1^{a_{\id}} g_3^{a_{\ctx}} g^{a_{r_2}}     &   T_3 &\gets g_4^{a_k + a_{\ctx}} g^{a_{r_3}} \\
        T_4 &\gets g_5^{a_{\text{n}}} g^{a_{r_4}}   &   T_5 &\gets \cm_3^{a_{\text{n}}} g^{a_{r_5}}     &   T_6 &\gets g^{a_{r_6}}
    \end{align*}
    Sends $(T_1, T_2, T_3, T_4, T_5, T_6)$ to verifier.
    
    \item \textbf{Challenge:} Verifier samples $c \sample \mathbb{Z}_q$ and sends to prover.
    
    \item \textbf{Response:} Prover computes:
    \[
    z_x = a_x + c \cdot x \quad \text{ for } \quad x \in \{\ \id, \k, \ctx, \text{n}, r_1, \ldots,r_6\} 
    \]
    Sends $(z_{\id}, z_k, z_{\ctx}, z_{r_1}, z_{r_2}, z_{r_3}, z_{\text{n}}, z_{r_4}, z_{r_5}, z_{r_6})$ to verifier.
    
    \item \textbf{Verification:} Verifier checks:
    \begin{enumerate}[label=(\roman*)]
        \item $g_1^{z_{\id}} g_2^{z_k} g^{z_{r_1}} \stackrel{?}{=} T_1 \cdot \cm_1^c$
        \item $g_1^{z_{\id}} g_3^{z_{\ctx}} g^{z_{r_2}} \stackrel{?}{=} T_2 \cdot \cm_2^c$
        \item $g_4^{z_k + z_{\ctx}} g^{z_{r_3}} \stackrel{?}{=} T_3 \cdot \cm_3^c$
        \item $g_5^{z_{\text{n}}} g^{z_{r_4}} \stackrel{?}{=} T_4 \cdot \cm_4^c$
        \item $\cm_3^{z_{\text{n}}} g^{z_{r_5}} \stackrel{?}{=} T_5 \cdot \cm_5^c$
        \item $g^{z_{r_6}} \stackrel{?}{=} T_6 \cdot \cm_6^c$
        \item $\frac{\cm_5}{\cm_6} \stackrel{?}{=} g_4$
    \end{enumerate}
\end{enumerate}
\end{protocol}








\newpage
\paragraph{Security Analysis:}
The protocol satisfies the following security properties:

\begin{itemize}
    \item \textbf{Completeness:} For an honest prover and verifier, all verification equations hold algebraically:
\begin{align*}
        g_1^{z_{\id}} g_2^{z_k} g^{z_{r_1}} &= g_1^{a_{\id} + c \cdot \id} g_2^{a_k + c \cdot \k} g^{a_{r_1} + c \cdot r_1} = T_1 \cdot \cm_1^c \\
        g_1^{z_{\id}} g_3^{z_{\ctx}} g^{z_{r_2}} &= g_1^{a_{\id} + c \cdot \id} g_3^{a_{\ctx} + c \cdot \ctx} g^{a_{r_2} + c \cdot r_2} = T_2 \cdot \cm_2^c \\
        g_4^{z_k + z_{\ctx}} g^{z_{r_3}} &= g_4^{(a_k + c \cdot \k) + (a_{\ctx} + c \cdot \ctx)} g^{a_{r_3} + c \cdot r_3} = T_3 \cdot \cm_3^c \\
        g_5^{z_{\text{n}}} g^{z_{r_4}} &= g_5^{a_{\text{n}} + c \cdot \textsf{n}} g^{a_{r_4} + c \cdot r_4} = T_4 \cdot \cm_4^c \\
        \cm_3^{z_{\text{n}}} g^{z_{r_5}} &= \cm_3^{a_{\text{n}} + c \cdot \textsf{n}} g^{a_{r_5} + c \cdot r_5} = T_5 \cdot \cm_5^c \\
        g^{z_{r_6}} &= g^{a_{r_6} + c \cdot r_6} = T_6 \cdot \cm_6^c \\
        \frac{\cm_5}{\cm_6} &= g_4^{(\k + \ctx) \cdot \textsf{n}} = g_4 \quad \text{since} \quad (\k + \ctx) \cdot \textsf{n} = 1
    \end{align*}
    
    \item \textbf{Special Soundness:} Given two accepting transcripts $(T_1, T_2, T_3, T_4, T_5, T_6, c, z_{\id}, z_k, z_{\ctx}, z_{r_1}, z_{r_2}, z_{r_3}, z_{\text{n}}, z_{r_4}, z_{r_5}, z_{r_6})$ and $(T_1, T_2, T_3, T_4, T_5, T_6, c', z_{\id}', z_k', z_{\ctx}', z_{r_1}', z_{r_2}', z_{r_3}', z_{\text{n}}', z_{r_4}', z_{r_5}', z_{r_6}')$ with $c \neq c'$, the extractor $\mathcal{E}$ computes:
    \begin{align*}
        \id &= \frac{z_{\id} - z_{\id}'}{c - c'} & \k &= \frac{z_k - z_k'}{c - c'} & \ctx &= \frac{z_{\ctx} - z_{\ctx}'}{c - c'} \\
        r_1 &= \frac{z_{r_1} - z_{r_1}'}{c - c'} & r_2 &= \frac{z_{r_2} - z_{r_2}'}{c - c'} & r_3 &= \frac{z_{r_3} - z_{r_3}'}{c - c'} \\
        \textsf{n} &= \frac{z_{\text{n}} - z_{\text{n}}'}{c - c'} & r_4 &= \frac{z_{r_4} - z_{r_4}'}{c - c'} & r_5 &= \frac{z_{r_5} - z_{r_5}'}{c - c'} & r_6 &= \frac{z_{r_6} - z_{r_6}'}{c - c'}
    \end{align*}
    The extracted witness satisfies all commitment relations and the multiplicative inverse $\textsf{n} = \frac{1}{\k + \ctx}$ due to the binding property of Pedersen commitments.
    
    \item \textbf{Honest-Verifier Zero-Knowledge:} The simulator $\mathcal{S}$ operates as follows:
    \begin{enumerate}
        \item Sample $z_{\id}, z_k, z_{\ctx}, z_{r_1}, z_{r_2}, z_{r_3}, z_{\text{n}}, z_{r_4}, z_{r_5}, z_{r_6} \sample \mathbb{Z}_q$ uniformly.
        \item Compute simulated commitments:
        \begin{align*}
            T_1 &\gets g_1^{z_{\id}} g_2^{z_k} g^{z_{r_1}} \cdot \cm_1^{-c} \\
            T_2 &\gets g_1^{z_{\id}} g_3^{z_{\ctx}} g^{z_{r_2}} \cdot \cm_2^{-c} \\
            T_3 &\gets g_4^{z_k + z_{\ctx}} g^{z_{r_3}} \cdot \cm_3^{-c} \\
            T_4 &\gets g_5^{z_{\text{n}}} g^{z_{r_4}} \cdot \cm_4^{-c} \\
            T_5 &\gets \cm_3^{z_{\text{n}}} g^{z_{r_5}} \cdot \cm_5^{-c} \\
            T_6 &\gets g^{z_{r_6}} \cdot \cm_6^{-c}
        \end{align*}
        \item Output $(T_1, T_2, T_3, T_4, T_5, T_6, c, z_{\id}, z_k, z_{\ctx}, z_{r_1}, z_{r_2}, z_{r_3}, z_{\text{n}}, z_{r_4}, z_{r_5}, z_{r_6})$.
    \end{enumerate}
    The simulated transcript is perfectly indistinguishable from a real transcript since the $z$-values are uniformly random and the $T_i$ are uniquely determined by the verification equations.
\end{itemize}

\paragraph{Connection to VRF Security}
The protocol’s soundness ensures that $\textsf{n} = \frac{1}{\k + \ctx}$ is correctly computed and tied to the commitments, critical for:
\begin{itemize}
    \item \textbf{Pseudorandomness:} Under the $q$-DHI assumption, $\textsf{n}$ is indistinguishable from random without knowing $\k$.
    \item \textbf{Uniqueness:} The relation $\frac{\cm_5}{\cm_6} = g_4$ enforces $(\k + \ctx) \cdot \textsf{n} = 1$, ensuring a unique nullifier per $(\k, \ctx)$ pair.
\end{itemize}
Thus, the VRF’s security reduces to the discrete logarithm assumption and the soundness of the inverse proof.






















































































\paragraph{Security Analysis:}
The protocol satisfies the following security properties:

\begin{itemize}
    \item \textbf{Completeness:} For honest prover and verifier, all verification equations hold algebraically:
    \begin{align*}
        g^{s_1}h^{u_1} &= g^{\alpha_1 + cm_1}h^{\rho_1 + cr_1} = T_1 \cdot \cm_1^c\\
        g^{s_2}h^{u_2} &= g^{\alpha_2 + cm_2}h^{\rho_2 + cr_2} = T_2 \cdot \cm_2^c\\
        \cm_1^{s_2}h^{u_3} &= \cm_1^{\alpha_2 + cm_2}h^{\rho_3 + cr_3} = T_3 \cdot \cm_3^c\\
        h^{u_4} &= h^{\rho_4 + cr_4} = T_4 \cdot \cm_4^c
    \end{align*}
    
    \item \textbf{Special Soundness:} Given two accepting transcripts $(T_1, T_2, T_3, T_4, c, s_1, s_2, u_1, u_2, u_3, u_4)$ and $(T_1, T_2, T_3, T_4, c', s_1', s_2', u_1', u_2', u_3', u_4')$ with $c \neq c'$, the extractor $\mathcal{E}$ works as follows:
    \begin{align*}
        m_1 &= \frac{s_1 - s_1'}{c - c'} &r_1 &= \frac{u_1 - u_1'}{c - c'}\\
        m_2 &= \frac{s_2 - s_2'}{c - c'} &r_2 &= \frac{u_2 - u_2'}{c - c'}\\
        r_3 &= \frac{u_3 - u_3'}{c - c'} &r_4 &= \frac{u_4 - u_4'}{c - c'}
    \end{align*}
    The extracted witness satisfies all verification equations and the multiplicative inverse relation by the binding property of Pedersen commitments.
    
    \item \textbf{Honest-Verifier Zero-Knowledge:} The simulator $\mathcal{S}$ operates as follows:
    \begin{enumerate}
        \item Sample $s_1, s_2, u_1, u_2, u_3, u_4 \sample \Z_q$ uniformly
        \item Compute simulated commitments:
        \begin{align*}
            T_1 &\gets g^{s_1}h^{u_1} \cdot \cm_1^{-c}\\
            T_2 &\gets g^{s_2}h^{u_2} \cdot \cm_2^{-c}\\
            T_3 &\gets \cm_1^{s_2}h^{u_3} \cdot \cm_3^{-c}\\
            T_4 &\gets h^{u_4} \cdot \cm_4^{-c}
        \end{align*}
        \item Output $(T_1, T_2, T_3, T_4, c, s_1, s_2, u_1, u_2, u_3, u_4)$
    \end{enumerate}
    The simulated transcript is perfectly indistinguishable from a real transcript as the distribution of responses $(s_1, s_2, u_1, u_2, u_3, u_4)$ is uniform in both cases, and the commitments are uniquely determined by the verification equations.
\end{itemize}

\paragraph{Connection to VRF Security}  
The protocol’s soundness guarantees that $\textsf{N} = g^{m_2}$ is valid only if $m_2 = 1/m_1$ for $m_1 = k + \textsf{ctx}$. This is critical because:
\begin{itemize}
    \item \textbf{Pseudorandomness:} Under $q$-DHI, $g^{1/m_1}$ is indistinguishable from random without knowledge of $m_1$.
    \item \textbf{Uniqueness:} The equation $m_1 \cdot m_2 = 1$ has a unique solution in $\Zp^*$, preventing adversarial equivocation.
\end{itemize}
Thus, the security of the VRF directly reduces to the hardness of computing discrete logarithms and the soundness of the inverse proof.





\subsection{Performance Evaluation}

\begin{figure}
    \centering
    \includegraphics[width=0.75\linewidth]{Screenshot 2025-03-21 at 10.47.48 am.png}
    \caption{Enter Caption}
    % \label{fig:enter-label}
\end{figure}
\clearpage

















































% start broad - the sybil resistance challenge in anonymous credential systems
% narrow to MIMC-ABC
% Introduce our solution
% Highlight our novelty

% Why = Motivation, Problem 
% How - what can be done to solve this problem
% Here's how we solved it and why we're better, what: it's a  Credential Relationship Bound Verifier from Pairing-Free VRF

\section{Problem Statement and Motivation}

Anonymous credentials provide privacy-preserving authentication in identity systems, allowing users to selectively disclose attributes without revealing their full identity. However, in many applications, system designers must balance user privacy with protection against Sybil attacks, where a single entity creates multiple identities to gain disproportionate influence or access.

In our $\MIMCABC$ anonymous credential system, eusers possess a Master Credential containing a secret key $k$ and may obtain multiple Context Credentials for different services or contexts. Each Context Credential contains a unique identifier $\text{ctx}$ (e.g., $H(\text{``DriverLicense''})$). During issuance, the system must ensure that each user receives at most one credential per context—without compromising privacy by revealing user identities.

\subsection{The Sybil Resistance Challenge}

Specifically, we need a privacy-preserving mechanism that:
\begin{enumerate}
    \item Creates a unique, deterministic token (nullifier) for each user-context pair
    \item Prevents the creation of multiple credentials for the same user-context combination
    \item Maintains unlinkability between different presentations of the same credential
    \item Does not reveal the user's identity during verification
\end{enumerate}

Traditionally, non-private systems use unique credential identifiers to prevent credential reuse. In privacy-preserving systems, we require a different approach: a deterministic but unlinkable nullifier that depends cryptographically on both the user's secret credential and the specific context.

\subsection{Limitations of Existing Approaches}

Verifiable Random Functions (VRFs) offer a promising foundation for nullifier construction, but existing implementations have significant limitations:

\paragraph{Standard VRF Constructions.} Traditional VRFs compute nullifiers of the form $N \leftarrow g^{1/(k+\text{ctx})}$, where verification requires checking $N \cdot (pk)^{\text{ctx}} \stackrel{?}{=} g^k$. This approach exposes the public key $pk = g^k$ during each verification, breaking unlinkability between credential uses.

\paragraph{Secure Multi-party Computation.} Systems like CanDID employ MPC to compute PRF outputs during credential issuance. While this approach preserves anonymity, it introduces substantial computational and communication overhead, limiting scalability and preventing dynamic nullifier generation during credential use.

\paragraph{Pairing-based VRFs.} Recent constructions like UTT use bilinear pairings to verify nullifiers without revealing identities. While secure, pairing operations are computationally expensive—often 5-10 times slower than standard group operations—making them suboptimal for resource-constrained environments or high-throughput applications.

We address these limitations by introducing a pairing-free VRF construction specifically optimized for anonymous credential systems where users combine multiple credentials together, providing both strong privacy guarantees and practical efficiency.

% Anonymous credentials need Sybil resistance without privacy compromise

% In MIMC-ABC: users must prove one credential per context without revealing identity

% Key Challenge: Creating deterministic, verifiable, unlinkable nullifiers

% Limitations of Existing Approaches:
% - Standard VRFs: reveal public keys, breaking anonymity
% - MPC PRF (CanDID): high computation/communication overhead
% - Pairing-based VRFs (UTT): expensive bilinear operations








\section{Our Contributions}

We improve the state of the art in privacy-preserving credential systems by creating a lightweight, efficient VRF construction specifically tailored for sybil resistance in anonymous credentials:

\subsection{Pairing-Free VRF in Prime-Order Groups}

We present a novel adaptation of the Dodis-Yampolskiy VRF structure that eliminates the need for computationally expensive bilinear pairings. Our construction:

\begin{itemize}
    \item Operates entirely in a single prime-order group ($\G_1$)
    \item Achieves provable pseudorandomness under the $q$-Diffie-Hellman Inversion ($q$-DHI) assumption
    \item Produces verifiable nullifiers of the form $\nul = g^{1/(k+\text{ctx})}$ where $k$ is a credential-specific secret and $\text{ctx}$ is the context identifier
\end{itemize}

This adaptation significantly reduces computational overhead compared to pairing-based alternatives while maintaining the same security guarantees.

\subsection{Zero-Knowledge Proof of Multiplicative Inverse}

We introduce an efficient $\Sigma$-protocol that proves the relationship between committed values $m_1 = k+\text{ctx}$ and $m_2 = 1/m_1$ without revealing either value. This protocol:

\begin{itemize}
    \item Enables verification of VRF outputs without compromising credential privacy
    \item Uses auxiliary commitments to enforce the multiplicative inverse relation
    \item Achieves perfect honest-verifier zero-knowledge
    \item Generalizes naturally to other cryptographic scenarios requiring proofs of inverse relationships
\end{itemize}

Our protocol structure can be applied beyond VRFs to any system requiring proofs of multiplicative inverse relationships in zero-knowledge.

\subsection{Formal Security Guarantees}

We demonstrate that sybil resistance in our system reduces to:
\begin{itemize}
    \item The $q$-DHI assumption in prime-order groups
    \item The binding property of Pedersen commitments
    \item The soundness of our $\Sigma$-protocol
\end{itemize}

These formal security guarantees ensure our construction maintains:
\begin{itemize}
    \item \textbf{Pseudorandomness:} VRF outputs are indistinguishable from random without knowledge of the secret
    \item \textbf{Uniqueness:} One nullifier per $(k,\text{ctx})$ pair, preventing sybil attacks
    \item \textbf{Unlinkability:} Multiple uses of the same credential remain unlinkable
\end{itemize}

\subsection{Efficiency Improvements}

Our experimental evaluation demonstrates substantial performance gains over pairing-based approaches:
\begin{itemize}
    \item 33\% faster evaluation (3.89ms vs. 5.83ms)
    \item 60\% faster verification (2.52ms vs. 6.37ms)
\end{itemize}

These improvements directly translate to enhanced scalability and user experience in credential systems, particularly on resource-constrained devices where bilinear pairings are prohibitively expensive.












\newpage
\section{Technical Construction}

We now present our pairing-free VRF construction, starting with essential preliminaries and then detailing our protocol for creating and verifying nullifiers in zero-knowledge.

\subsection{Preliminaries}

\begin{definition}[$q$-DHI Assumption]
Let $\mathbb{G}$ be a cyclic group of prime order $p$ with generator $g$. The $q$-Diffie-Hellman Inversion ($q$-DHI) assumption states that for any PPT adversary $\mathcal{A}$, there exists a negligible function $\mathsf{negl}$ such that:
\[
\Pr\left[x \leftarrow \mathbb{Z}_p^*, \mathcal{A}(g, g^x, g^{x^2}, \ldots, g^{x^q}) = g^{1/x}\right] \leq \mathsf{negl}(\lambda)
\]
\end{definition}

\begin{remark}
The $q$-DHI assumption is equivalent to the $(q+1)$-generalized Diffie-Hellman assumption as shown by Boneh and Boyen \cite{BB04}. This equivalence provides a solid theoretical foundation for our VRF construction's security.
\end{remark}

\begin{definition}[Verifiable Random Function in Prime-Order Group]
A VRF in a prime-order group $\mathbb{G}$ is a tuple of algorithms $(\mathsf{VRF.Gen}, \mathsf{VRF.Eval}, \mathsf{VRF.Vfy})$ with message space $\mathcal{X}$, output space $\mathcal{Y}$, and proof space $\Pi$ satisfying:

\begin{itemize}
    \item $\mathsf{VRF.Gen}(1^\lambda) \rightarrow (sk, pk)$: Samples secret key $sk \leftarrow \mathbb{Z}_p^*$, computes public key $pk = g^{sk}$
    \item $\mathsf{VRF.Eval}(sk, x) \rightarrow (y, \pi)$: Computes output $y = g^{1/(sk+x)}$ and proof $\pi$
    \item $\mathsf{VRF.Vfy}(pk, x, y, \pi) \rightarrow \{0,1\}$: Verifies that $y = g^{1/(sk+x)}$
\end{itemize}

with correctness, unique provability, and pseudorandomness properties as defined in standard VRF literature.
\end{definition}

\subsection{From Pairing-Based to Pairing-Free VRF}

We begin by analyzing the classic Dodis-Yampolskiy VRF, which relies on bilinear pairings. In this construction, verification proceeds by checking:
\[
e(g_1^{\text{ctx}} \cdot pk, N) \stackrel{?}{=} e(g_1, g_2)
\]

where $N = g_2^{1/(k+\text{ctx})}$ is the VRF output, $pk = g_1^k$ is the public key, and $e: \mathbb{G}_1 \times \mathbb{G}_2 \rightarrow \mathbb{G}_T$ is a bilinear pairing.

Expanding this equation:
\[
e(g_1^{\text{ctx}} \cdot g_1^k, g_2^{1/(k+\text{ctx})}) = e(g_1, g_2)
\]

This verification essentially proves that $(k+\text{ctx}) \cdot \frac{1}{k+\text{ctx}} = 1$.

Our key insight is that we can eliminate the pairing by directly proving this multiplicative inverse relationship. We define:
\begin{align}
m_1 &= k + \text{ctx} \\
m_2 &= \frac{1}{k+\text{ctx}}
\end{align}

With these values, the nullifier becomes $N = g^{m_2}$, and verification reduces to proving that $m_1 \cdot m_2 = 1$.

\subsection{Commitment Structure for VRF Verification}

To support zero-knowledge proofs of the VRF relationship, we use the following commitment structure:

\begin{align}
\text{cm}_1 &= g_1^{\text{id}} \cdot g_2^{k} \cdot g^{r_1} \\
\text{cm}_2 &= g_1^{\text{id}} \cdot g_3^{\text{ctx}} \cdot g^{r_2} \\
\text{cm}_3 &= g_4^{\text{exponent\_k\_ctx}} \cdot g^{r_3} \\
\text{cm}_4 &= g_5^{\text{exponent\_k\_ctx\_inv}} \cdot g^{r_4} \\
\text{cm}_5 &= \text{cm}_3^{\text{exponent\_k\_ctx\_inv}} \cdot g^{r_5} \\
\text{cm}_6 &= g^{r_6}
\end{align}

where $\text{exponent\_k\_ctx} = k + \text{ctx}$ and $\text{exponent\_k\_ctx\_inv} = 1/\text{exponent\_k\_ctx}$.

This commitment structure allows us to prove:
\begin{enumerate}
    \item $\text{cm}_1$ and $\text{cm}_2$ contain the same id
    \item $\text{cm}_3$ contains the sum of $k$ and ctx from $\text{cm}_1$ and $\text{cm}_2$
    \item $\text{cm}_4$ contains the inverse of the value in $\text{cm}_3$
    \item $\text{cm}_3 \cdot \text{cm}_4$ equals the identity element (proving the inverse relationship)
    \item The nullifier $N = g_4$ is correctly formed
\end{enumerate}

\subsection{$\Sigma$-Protocol Construction}

We now present our $\Sigma$-protocol for proving the correctness of a VRF nullifier:

\begin{protocol}[Non-Pairing VRF Verification]
Common Input: Commitments $\text{cm}_1, \ldots, \text{cm}_6$, group generators $g, g_1, \ldots, g_5$, and nullifier $N$

Prover Input: Witness $(\text{id}, k, \text{ctx}, r_1, \ldots, r_6)$ satisfying the commitment structure

\begin{enumerate}
    \item \textbf{Commitment:} Prover samples random values:
    \begin{align}
        a_{\text{id}}, a_{k}, a_{\text{ctx}}, a_{\text{exponent\_k\_ctx\_inv}}, a_{r_1}, \ldots, a_{r_6} \leftarrow \mathbb{Z}_p
    \end{align}
    
    Computes commitments:
    \begin{align}
        T_1 &= g_1^{a_{\text{id}}} \cdot g_2^{a_{k}} \cdot g^{a_{r_1}} \\
        T_2 &= g_1^{a_{\text{id}}} \cdot g_3^{a_{\text{ctx}}} \cdot g^{a_{r_2}} \\
        T_3 &= g_4^{a_{k} + a_{\text{ctx}}} \cdot g^{a_{r_3}} \\
        T_4 &= g_5^{a_{\text{exponent\_k\_ctx\_inv}}} \cdot g^{a_{r_4}} \\
        T_5 &= \text{cm}_3^{a_{\text{exponent\_k\_ctx\_inv}}} \cdot g^{a_{r_5}} \\
        T_6 &= g^{a_{r_6}}
    \end{align}
    
    \item \textbf{Challenge:} Verifier samples $c \leftarrow \mathbb{Z}_p$
    
    \item \textbf{Response:} Prover computes:
    \begin{align}
        z_{\text{id}} &= a_{\text{id}} + c \cdot \text{id} \\
        z_{k} &= a_{k} + c \cdot k \\
        z_{\text{ctx}} &= a_{\text{ctx}} + c \cdot \text{ctx} \\
        z_{r_1} &= a_{r_1} + c \cdot r_1 \\
        \vdots \\
        z_{\text{exponent\_k\_ctx\_inv}} &= a_{\text{exponent\_k\_ctx\_inv}} + c \cdot \text{exponent\_k\_ctx\_inv}
    \end{align}
    
    \item \textbf{Verification:} Verifier checks:
    \begin{align}
        \text{cm}_1^c \cdot T_1 &\stackrel{?}{=} g_1^{z_{\text{id}}} \cdot g_2^{z_{k}} \cdot g^{z_{r_1}} \\
        \text{cm}_2^c \cdot T_2 &\stackrel{?}{=} g_1^{z_{\text{id}}} \cdot g_3^{z_{\text{ctx}}} \cdot g^{z_{r_2}} \\
        \text{cm}_3^c \cdot T_3 &\stackrel{?}{=} g_4^{z_{k} + z_{\text{ctx}}} \cdot g^{z_{r_3}} \\
        \text{cm}_4^c \cdot T_4 &\stackrel{?}{=} g_5^{z_{\text{exponent\_k\_ctx\_inv}}} \cdot g^{z_{r_4}} \\
        \text{cm}_5^c \cdot T_5 &\stackrel{?}{=} \text{cm}_3^{z_{\text{exponent\_k\_ctx\_inv}}} \cdot g^{z_{r_5}} \\
        \text{cm}_6^c \cdot T_6 &\stackrel{?}{=} g^{z_{r_6}} \\
        \text{cm}_5 + \text{cm}_6^{-1} &\stackrel{?}{=} g_4
    \end{align}
\end{enumerate}
\end{protocol}

\subsection{Security Analysis}

Our protocol satisfies the following security properties:

\paragraph{Completeness.} For honestly generated commitments and responses, all verification equations hold algebraically by construction.

\paragraph{Special Soundness.} Given two accepting transcripts $(T_1,\ldots,T_6,c,z_{\ldots})$ and $(T_1,\ldots,T_6,c',z'_{\ldots})$ with $c \neq c'$, we can extract a valid witness by computing:
\begin{align}
\text{id} &= \frac{z_{\text{id}} - z'_{\text{id}}}{c - c'} \\
k &= \frac{z_{k} - z'_{k}}{c - c'} \\
\vdots
\end{align}

\paragraph{Honest-Verifier Zero-Knowledge.} A simulator can generate accepting transcripts without knowing the witness by selecting random responses and computing the commitments to satisfy the verification equations.

\paragraph{Connection to VRF Security.} Our protocol's soundness guarantees that a valid nullifier $N = g_4$ is uniquely determined by the values $k$ and $\text{ctx}$, with an inverse relationship enforced between $\text{exponent\_k\_ctx}$ and $\text{exponent\_k\_ctx\_inv}$. By the $q$-DHI assumption, computing such a nullifier without knowing the inputs is computationally infeasible.

\paragraph{Sybil Resistance.} Our construction provides sybil resistance through the uniqueness property of the VRF and the binding property of our commitment scheme. For each pair $(k, \text{ctx})$, there exists exactly one valid nullifier that can be verified. Any attempt to create multiple credentials for the same context would result in the same nullifier being revealed, allowing detection of duplicate issuance.

















\section{Technical Construction}

We now present our pairing-free VRF construction, based on adapting the Dodis-Yampolskiy VRF to eliminate bilinear pairings while maintaining security guarantees.

\subsection{Preliminaries}

\begin{definition}[$q$-DHI Assumption]
Let $\mathbb{G}$ be a cyclic group of prime order $p$ with generator $g$. The $q$-Diffie-Hellman Inversion ($q$-DHI) assumption states that for any PPT adversary $\mathcal{A}$, there exists a negligible function $\mathsf{negl}$ such that:
\[
\Pr\left[x \leftarrow \mathbb{Z}_p^*, \mathcal{A}(g, g^x, g^{x^2}, \ldots, g^{x^q}) = g^{1/x}\right] \leq \mathsf{negl}(\lambda)
\]
\end{definition}

\subsection{Non-Pairing VRF Construction}

Our pairing-free VRF replaces the bilinear pairing verification with a novel commitment and zero-knowledge proof system. The key insight is to directly prove the multiplicative inverse relationship $(k + \text{ctx}) \cdot \frac{1}{k+\text{ctx}} = 1$ without requiring pairings.

\paragraph{VRF Evaluation.} To evaluate the VRF on input $\text{ctx}$ with secret key $k$ and user identifier $\text{id}$:

\begin{enumerate}
    \item Compute $\text{sum} = k + \text{ctx}$
    \item Compute $\text{sum\_inv} = \frac{1}{\text{sum}}$
    \item Compute the nullifier $N = g_4$
    \item Generate a zero-knowledge proof $\pi$ of correctness (detailed below)
    \item Output $(N, \pi)$
\end{enumerate}

\paragraph{Commitment Structure.} The prover creates the following commitments to enable verification:

\begin{align}
\text{cm}_1 &= g_1^{\text{id}} \cdot g_2^{k} \cdot g^{r_1} \\
\text{cm}_2 &= g_1^{\text{id}} \cdot g_3^{\text{ctx}} \cdot g^{r_2} \\
\text{cm}_3 &= g_4^{k + \text{ctx}} \cdot g^{r_3} \\
\text{cm}_4 &= g_5^{\frac{1}{k + \text{ctx}}} \cdot g^{r_4} \\
\text{cm}_5 &= \text{cm}_3^{\frac{1}{k + \text{ctx}}} \cdot g^{r_5} \\
\text{cm}_6 &= g^{r_6}
\end{align}

Here, $r_6 = \frac{r_3}{k + \text{ctx}} + r_5$ maintains the consistency of the commitment structure.

\paragraph{Zero-Knowledge Proof Protocol.} We use a $\Sigma$-protocol to prove that the nullifier $N = g_4$ is correctly computed:

\begin{protocol}{Non-Pairing VRF Verification}{non-pairing-vrf}
\textbf{Common Input:} Generators $g, g_1, g_2, g_3, g_4, g_5$, commitments $\text{cm}_1, \ldots, \text{cm}_6$\\
\textbf{Prover Input:} Values $(\text{id}, k, \text{ctx}, r_1, \ldots, r_6)$ satisfying the commitment structure

\begin{enumerate}
    \item \textbf{Commitment:} Prover samples randomness:
    \[
        a_{\text{id}}, a_k, a_{\text{ctx}}, a_{\text{inv}}, a_{r_1}, \ldots, a_{r_6} \leftarrow \mathbb{Z}_p
    \]
    where $a_{\text{inv}}$ represents a blinding for the inverse value $\frac{1}{k + \text{ctx}}$.
    
    Computes:
    \begin{align}
        T_1 &= g_1^{a_{\text{id}}} \cdot g_2^{a_k} \cdot g^{a_{r_1}} \\
        T_2 &= g_1^{a_{\text{id}}} \cdot g_3^{a_{\text{ctx}}} \cdot g^{a_{r_2}} \\
        T_3 &= g_4^{a_k + a_{\text{ctx}}} \cdot g^{a_{r_3}} \\
        T_4 &= g_5^{a_{\text{inv}}} \cdot g^{a_{r_4}} \\
        T_5 &= \text{cm}_3^{a_{\text{inv}}} \cdot g^{a_{r_5}} \\
        T_6 &= g^{a_{r_6}}
    \end{align}
    
    Sends $(T_1, T_2, T_3, T_4, T_5, T_6)$ to verifier.
    
    \item \textbf{Challenge:} Verifier samples $c \leftarrow \mathbb{Z}_p$ and sends to prover.
    
    \item \textbf{Response:} Prover computes:
    \begin{align}
        z_{\text{id}} &= a_{\text{id}} + c \cdot \text{id} \\
        z_k &= a_k + c \cdot k \\
        z_{\text{ctx}} &= a_{\text{ctx}} + c \cdot \text{ctx} \\
        z_{\text{inv}} &= a_{\text{inv}} + c \cdot \frac{1}{k + \text{ctx}} \\
        z_{r_1} &= a_{r_1} + c \cdot r_1 \\
        \vdots \\
        z_{r_6} &= a_{r_6} + c \cdot r_6
    \end{align}
    
    Sends $(z_{\text{id}}, z_k, z_{\text{ctx}}, z_{\text{inv}}, z_{r_1}, \ldots, z_{r_6})$ to verifier.
    
    \item \textbf{Verification:} Verifier checks:
    \begin{align}
        \text{cm}_1^c \cdot T_1 &\stackrel{?}{=} g_1^{z_{\text{id}}} \cdot g_2^{z_k} \cdot g^{z_{r_1}} \\
        \text{cm}_2^c \cdot T_2 &\stackrel{?}{=} g_1^{z_{\text{id}}} \cdot g_3^{z_{\text{ctx}}} \cdot g^{z_{r_2}} \\
        \text{cm}_3^c \cdot T_3 &\stackrel{?}{=} g_4^{z_k + z_{\text{ctx}}} \cdot g^{z_{r_3}} \\
        \text{cm}_4^c \cdot T_4 &\stackrel{?}{=} g_5^{z_{\text{inv}}} \cdot g^{z_{r_4}} \\
        \text{cm}_5^c \cdot T_5 &\stackrel{?}{=} \text{cm}_3^{z_{\text{inv}}} \cdot g^{z_{r_5}} \\
        \text{cm}_6^c \cdot T_6 &\stackrel{?}{=} g^{z_{r_6}} \\
        \text{cm}_5 + \text{cm}_6^{-1} &\stackrel{?}{=} g_4
    \end{align}
\end{enumerate}
\end{protocol}

This protocol proves the following crucial relationships:
\begin{itemize}
    \item $\text{cm}_1$ and $\text{cm}_2$ share the same user identifier $\text{id}$
    \item $\text{cm}_3$ commits to $k + \text{ctx}$ with the generator $g_4$
    \item $\text{cm}_4$ commits to $\frac{1}{k + \text{ctx}}$ with generator $g_5$
    \item $\text{cm}_5$ equals $\text{cm}_3$ raised to the power $\frac{1}{k + \text{ctx}}$
    \item $\text{cm}_5 \cdot \text{cm}_6^{-1} = g_4$, proving that $g_4$ is the correctly computed nullifier
\end{itemize}

\subsection{Security Analysis}

Our construction inherits security properties from the Dodis-Yampolskiy VRF while eliminating the need for bilinear pairings:

\paragraph{Pseudorandomness.} The security of our nullifier $g_4$ relies on the $q$-DHI assumption. Given public generators, no PPT adversary can distinguish $g_4$ from a random group element without knowing $k$ and $\text{ctx}$.

\paragraph{Uniqueness.} For each pair $(k, \text{ctx})$, there exists exactly one nullifier $g_4$ that can satisfy our zero-knowledge verification equations. This uniqueness prevents a user from generating multiple valid proofs for different nullifiers with the same input.

\paragraph{Zero-Knowledge.} Our $\Sigma$-protocol reveals no information about the user's secret values $k$ and $\text{id}$. The verification can be simulated perfectly using standard techniques.

\paragraph{Sybil Resistance.} The uniqueness property ensures that each user can generate exactly one valid nullifier per context. Any attempt to create multiple credentials for the same context will result in the same nullifier being revealed, allowing the system to detect duplicate issuance requests.






































\subsection{Technical Construction}

Preliminaries: q-DHI assumption, VRF definition
Our Construction:

From pairing-based to pairing-free VRF
Commitment structure for verification
Complete sigma-protocol description (aligned with your code)


Security Analysis: Sketch of completeness, soundness, zero-knowledge







4. Performance Evaluation (1/2 page)

Benchmark methodology
Results comparison with pairing-based approach
Interpretation of performance gains for credential systems
























In the $\MIMCABC$ system, identity binding ensures all credentials in a presentation belong to the same user by proving the equality of a committed identifier $\id$ across credentials. This enables users to prove multiple credentials together for application scenarios.
Credential Relationship binding extends this, enabling users to prove structured relationships between anonymous credentials, such as generating single-use tokens for integration with other systems e.g. privacy-pass-like applications \cite{davidson2018privacy} and for sybil-resistant context credentials.

Identity binding links credentials to a single user identifier, credential relationship binding enforces dependency constraints between credentials, and a credential relationship bound nullifier is a deterministic anonymous token that proves the user has this relationship. Because it's determinisitic and based on the users secret attributes, they can only derive it in the same way, so the token is used for Sybil Resistance scenarios where privacy is still required and furthermore can be used in Revocation checks.

Sybil Resistance in private systems is difficult and furthermore in a multi-issuer, multi-credential scenario, simple relationship binding is not enough, as in $\MIMCABC$ a user can more easily maliciously create credentials with lower-security issuers that allow them to prove identity binding with attributes of their choice. 

\subsection{Limitation of existing approaches}
\begin{enumerate}
    \item \textbf{Standard VRF} verifies a nullifier $\nul$ by computes a deterministic nullifier
    \[
        \nul \gets g^{1/(\key + \ctx)}    \qquad \nul \cdot (\pk)^{\ctx}
    \]
    
    where $\key$ is the secret key, $\pk = g^{\key}$ is the public key, and $\nul$ is verifiable by $\nul \cdot (\pk)^{\ctx}$ for a public $\ctx$. This does not preserve the anonymity notions required for Anonymous Credentials as $\pk$ is publicly used each usage
    \item \textbf{MPC PRF}: CanDID, a decentralized identity system, computes nullifiers from MPC PRF during credential issuance preserving anonymity properties with secure multiparty computation, which has large overhead, and because of the time spent during PRF generation, can't be used easily for other mechanisms like the output being in a revocation list.
    \item \textbf{Pairing-based VRF:}  We base our scheme on the notions in \cite{tomescu2022utt}, our novel contribution is its computation in $\G_1$ and thus removing the pairing computation and operation in $\G_2$, improving computation efficiency and allowing its use in non-pairing based schemes.
\end{enumerate}


\subsection{Credential Relationship Bound Verifier from Pairing-Free VRF}
\begin{itemize}
    \item VRF Overview: A Verifiable Random Function generates a pseudorandom, deterministic output nullifier 
    \[
    \nul \gets g^{1/(\key + \ctx)}
    \]
    Verifiable by a public key $\pk = g^{\key}$. In $\MIMCABC, \key$ is a committed attribute in a master credential and $\ctx$ is the unique identifier of the context credential

    \item Integration: Users commit $\key$ and $\ctx$ in Pedersen commitments e.g., $( \cm_k = g^{\key} h^r, \cm_{\ctx} = g^{\ctx} h^{r_2})$, compute the nullifier, and prove its correctness to the issuer using a zero-knowledge protocol. This ensures one nullifier per $(\key, \ctx)$ pair, preventing sybil attacks.
\end{itemize}


\subsection{Contributions}

\noindent We improve the state of the art by creating a lightweight VRF construction tailored for Anonymous Credential systems with 3 contributions:
\begin{enumerate}
        \item \textbf{Pairing-Free VRF in Prime-Order Groups:} We adapt the Dodis-Yampolskiy VRF structure to function efficiently in standard prime-order groups, achieving provable pseudorandomness under the $q$-Diffie-Hellman Inversion ($q$-DHI) assumption.

        \item \textbf{Zero-Knowledge Proof of Multiplicative Inverse:} We introduce a novel $\Sigma$-protocol that proves the multiplicative inverse relation between committed values $m_1 = k + \textsf{ctx}$ and $m_2 = 1/m_1$, we use it in our scheme to verify the correctness of the VRF nullifier without revealing user secrets. We show it generalizes naturally for similar requirements in $\Sigma$-protocols, especially those needing to prove the q-DHI.

         \item \textbf{Formal Security Guarantees:} We demonstrate sybil resistance reduces to the security of our construction, the unique provability of the vrf and the soundness of our $\Sigma$-protocol.
\end{enumerate}


\subsection{Related Work}
(explain where they're used, what construction, pros, cons, use-case) This might be what I need to benchmark against

UTT - Pairing based Verifiable Nullifier
CanDID - MPC PRF
tACT - 
Anonymous Counting Tokens: Verifiable Oblivious Pseudorandom function






Revocation: How does your nullifier support revocation checks? Mention this in 2.4.

\newpage
\section{OLD WORK}







\newpage
\begin{protocol}{VRF Output Verification}{vrf-verify}\label{pok-vrf}
\textbf{Common Input:} Commitments $\cmm, \cmc$, group generator $g$, and public parameters $h \in \G$\\
\textbf{Prover Input:} Witness $(m_1, m_2, r_1, r_2, r_3, r_4)$ such that:
\begin{itemize}
    \item $\cm_1 = g^{m_1}h^{r_1}$ and $\cm_2 = g^{m_2}h^{r_2}$
    \item $\cm_3 = \cm_1^{m_2}h^{r_3}$ and $\cm_4 = h^{r_4}$
    \item $m_1 \cdot m_2 = 1$ (multiplicative inverse relation)
\end{itemize}

\begin{enumerate}
    \item \textbf{Commitment:} Prover samples randomness:
    \[
        \alpha_1, \alpha_2, \rho_1, \rho_2, \rho_3, \rho_4 \sample \Z_q
    \]
    Computes:
    \begin{itemize}
        \item $T_1 \gets g^{\alpha_1}h^{\rho_1}$
        \item $T_2 \gets g^{\alpha_2}h^{\rho_2}$
        \item $T_3 \gets \cm_1^{\alpha_2}h^{\rho_3}$
        \item $T_4 \gets h^{\rho_4}$
    \end{itemize}
    Sends $(T_1, T_2, T_3, T_4)$ to verifier.
    
    \item \textbf{Challenge:} Verifier samples $c \sample \Z_q$ and sends to prover.
    
    \item \textbf{Response:} Prover computes:
    \begin{align*}
        s_1 &\gets \alpha_1 + c \cdot m_1 &u_1 &\gets \rho_1 + c \cdot r_1\\
        s_2 &\gets \alpha_2 + c \cdot m_2 &u_2 &\gets \rho_2 + c \cdot r_2\\
        u_3 &\gets \rho_3 + c \cdot r_3 &u_4 &\gets \rho_4 + c \cdot r_4
    \end{align*}
    Sends $(s_1, s_2, u_1, u_2, u_3, u_4)$ to verifier.
    
    \item \textbf{Verification:} Verifier checks:
    \begin{enumerate}[label=(\roman*)]
        \item $g^{s_1}h^{u_1} \stackrel{?}{=} T_1 \cdot \cm_1^c$
        \item $g^{s_2}h^{u_2} \stackrel{?}{=} T_2 \cdot \cm_2^c$
        \item $\cm_1^{s_2}h^{u_3} \stackrel{?}{=} T_3 \cdot \cm_3^c$
        \item $h^{u_4} \stackrel{?}{=} T_4 \cdot \cm_4^c$
        \item $\frac{\cm_3}{\cm_4} \stackrel{?}{=} g$
    \end{enumerate}
\end{enumerate}
\end{protocol}






































